#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Starbreeze

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "AccelByteUe4Sdk_structs.hpp"
#include "Engine_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "AccelByteCustomization_structs.hpp"
#include "AnimGraphRuntime_structs.hpp"
#include "AIModule_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "Slate_structs.hpp"
#include "InputCore_structs.hpp"


namespace SDK
{

// Enum Starbreeze.ESBZDialogEndedReason
// NumValues: 0x0004
enum class ESBZDialogEndedReason : uint8
{
	Completed                                = 0,
	Interrupted                              = 1,
	FailedToStart                            = 2,
	ESBZDialogEndedReason_MAX                = 3,
};

// Enum Starbreeze.ESBZLifeActionStopReason
// NumValues: 0x0003
enum class ESBZLifeActionStopReason : uint8
{
	Finished                                 = 0,
	Interrupted                              = 1,
	ESBZLifeActionStopReason_MAX             = 2,
};

// Enum Starbreeze.ESBZChallengeConversion
// NumValues: 0x0003
enum class ESBZChallengeConversion : uint8
{
	None                                     = 0,
	ConvertToMeters                          = 1,
	ESBZChallengeConversion_MAX              = 2,
};

// Enum Starbreeze.EChallengeStatusEnum
// NumValues: 0x0005
enum class EChallengeStatusEnum : uint8
{
	INIT                                     = 0,
	INPROGRESS                               = 1,
	COMPLETED                                = 2,
	UNAVAILABLE                              = 3,
	EChallengeStatusEnum_MAX                 = 4,
};

// Enum Starbreeze.ESBZArmorChunkType
// NumValues: 0x0004
enum class ESBZArmorChunkType : uint8
{
	Normal                                   = 0,
	Adaptive                                 = 1,
	Shield                                   = 2,
	MAX                                      = 3,
};

// Enum Starbreeze.ESBZFirstPartyPlatform
// NumValues: 0x0007
enum class ESBZFirstPartyPlatform : uint8
{
	Unknown                                  = 0,
	Null                                     = 1,
	Steam                                    = 2,
	PlayStationNetwork                       = 3,
	XboxLive                                 = 4,
	EpicOnlineSystem                         = 5,
	MAX                                      = 6,
};

// Enum Starbreeze.ESBZPlatform
// NumValues: 0x0005
enum class ESBZPlatform : uint8
{
	Unknown                                  = 0,
	Windows                                  = 1,
	Playstation                              = 2,
	Xbox                                     = 3,
	MAX                                      = 4,
};

// Enum Starbreeze.ESBZSlotStatus
// NumValues: 0x000A
enum class ESBZSlotStatus : uint8
{
	Initializing                             = 0,
	PreMatch                                 = 1,
	Connecting                               = 2,
	JobOverview                              = 3,
	JobOverviewReady                         = 4,
	ActionPhase                              = 5,
	ResultScreen                             = 6,
	Disconnected                             = 7,
	Default                                  = 0,
	ESBZSlotStatus_MAX                       = 8,
};

// Enum Starbreeze.ESBZOnlineJoinType
// NumValues: 0x0007
enum class ESBZOnlineJoinType : uint8
{
	Debug_DEPRECATED                         = 0,
	Public                                   = 1,
	Private                                  = 2,
	FriendsOnly                              = 3,
	InviteOnly                               = 4,
	Default                                  = 1,
	ESBZOnlineJoinType_MAX                   = 5,
};

// Enum Starbreeze.ESBZServerSessionType
// NumValues: 0x0003
enum class ESBZServerSessionType : uint8
{
	ListenServer                             = 0,
	DedicatedServer                          = 1,
	ESBZServerSessionType_MAX                = 2,
};

// Enum Starbreeze.ESBZOnlineSessionPhase
// NumValues: 0x000D
enum class ESBZOnlineSessionPhase : uint8
{
	Undefined                                = 0,
	PartyCreation                            = 1,
	Matchmaking                              = 2,
	Lobby                                    = 3,
	Loading                                  = 4,
	WaitActionPhase                          = 5,
	DSWaitingForClients                      = 6,
	ActionPhase                              = 7,
	ActionPhaseEnd                           = 8,
	WaitingResult                            = 9,
	ResultSuccess                            = 10,
	ResultFail                               = 11,
	ESBZOnlineSessionPhase_MAX               = 12,
};

// Enum Starbreeze.ESBZOnlineCode
// NumValues: 0x0026
enum class ESBZOnlineCode : uint8
{
	Success                                  = 0,
	Interrupted                              = 1,
	PlatformTimedOut                         = 2,
	InvalidRequest                           = 3,
	InternalError                            = 4,
	LostConnectionToHost                     = 5,
	HostFailedToStartLoading                 = 6,
	PrivilegeError                           = 7,
	MissionAlreadyFinished                   = 8,
	QuickMatchLostConnection                 = 9,
	BeaconSlotReservationFailed              = 10,
	BeaconConnectionFailed                   = 11,
	OnlinePlatformRequestError               = 12,
	WrongBeaconPort                          = 13,
	WrongSessionPhase                        = 14,
	PartyFailedToJoinLobby                   = 15,
	ServerVersionMismatch                    = 16,
	LostConnectionToMatchMakingService       = 17,
	MatchmakingRequestFailed                 = 18,
	DataParsingError                         = 19,
	PartyLeaderCancelledMatchmaking          = 20,
	JoinedCrossPlatformLobby                 = 21,
	SessionIsFull                            = 22,
	SessionDoesNotExist                      = 23,
	CouldNotRetrieveAddress                  = 24,
	AlreadyInSession                         = 25,
	InvalidFriendship                        = 26,
	InvalidCode                              = 27,
	MaxActiveSessionReached                  = 28,
	InvalidJoinability                       = 29,
	InvalidMemberStatus                      = 30,
	InactiveTimeout                          = 31,
	MemberBlock                              = 32,
	EmptyMember                              = 33,
	ReturnToIIS                              = 34,
	UserHasChanged                           = 35,
	SoloGameRequested                        = 36,
	ESBZOnlineCode_MAX                       = 37,
};

// Enum Starbreeze.EBlackScreenTransitionType
// NumValues: 0x0003
enum class EBlackScreenTransitionType : uint8
{
	Short                                    = 0,
	Long                                     = 1,
	EBlackScreenTransitionType_MAX           = 2,
};

// Enum Starbreeze.ESBZRandomRewardReason
// NumValues: 0x0004
enum class ESBZRandomRewardReason : uint8
{
	HeistSuccessfullyCompleted               = 0,
	RenownLeveledUp                          = 1,
	InfamyLeveledUp                          = 2,
	ESBZRandomRewardReason_MAX               = 3,
};

// Enum Starbreeze.ESBZMetaRequestResult
// NumValues: 0x0042
enum class ESBZMetaRequestResult : uint8
{
	Ok                                       = 0,
	AccelByteHttpClientRequestError          = 1,
	AccelByteHttpServerError                 = 2,
	AccelBytePlatformError                   = 3,
	AccelByteNamespaceError                  = 4,
	AccelByteProfileError                    = 5,
	AccelByteBuildInfoError                  = 6,
	AccelByteCategoryError                   = 7,
	AccelByteEntitlementError                = 8,
	AccelByteOrderError                      = 9,
	AccelBytePaymentError                    = 10,
	AccelByteWalletError                     = 11,
	AccelByteCurrencyError                   = 12,
	AccelByteCampaignError                   = 13,
	AccelByteSocialError                     = 14,
	AccelByteFavoriteError                   = 15,
	AccelByteOffenseError                    = 16,
	AccelByteStatisticError                  = 17,
	AccelByteLeaderboardError                = 18,
	AccelByteCloudSaveError                  = 19,
	AccelByteDedicatedServerNotFound         = 20,
	AccelByteDedicatedServerConfigNotFound   = 21,
	AccelByteUnknownError                    = 22,
	AccelByteJsonDeserializationFailed       = 23,
	AccelByteInvalidRequest                  = 24,
	AccelByteInvalidResponse                 = 25,
	AccelByteNetworkError                    = 26,
	AccelByteIsNotLoggedIn                   = 27,
	AccelByteDsRegistrationConflict          = 28,
	AccelBytePartyStorageError               = 29,
	AccelByteInsufficientFunds               = 30,
	AccelByteBackendFailure                  = 31,
	AccelByteUnauthorized                    = 32,
	AccelByteInvalidOrder                    = 33,
	AccelBytePlayerRecordNotFoundException   = 34,
	AccelByteLobbyNotConnectedError          = 35,
	AccelByteLobbySetupChallengesError       = 36,
	AccelByteFailedToSyncDLC                 = 37,
	NoAvailableInventorySlot                 = 38,
	AccelByteSavedDataAfterResetOK           = 39,
	AccelByteSavedDataAfterResetFailed       = 40,
	LoadoutIndexOutOfRange                   = 41,
	WeaponSlotIndexOutOfRange                = 42,
	InvalidAccelByteOperationForClient       = 43,
	SkillNotProgressed                       = 44,
	SkillAlreadyResearched                   = 45,
	SkillEquipped                            = 46,
	SkillNotEquipped                         = 47,
	MissingLoadoutItem                       = 48,
	MissingStoreItem                         = 49,
	InvalidItemTypeInStoreRequest            = 50,
	FailedToAddWeaponToInventorySlot         = 51,
	InvalidGameConfiguration                 = 52,
	FailedToDeleteUserAccount                = 53,
	MissingEntitlementToConsume              = 54,
	ApplyCosmeticsFailed                     = 55,
	UpgradeSaveDataFailed                    = 56,
	InvalidState                             = 57,
	FailedToPurchaseRealMoneyItem            = 58,
	FailedToQueryAchievements                = 59,
	InventoryItemCannotBeDiscarded           = 60,
	FailedToGetReceipts                      = 61,
	HaveNotReceivedInitialRewards            = 62,
	MissingEnitlementPermission              = 63,
	VendorItemLocked                         = 64,
	ESBZMetaRequestResult_MAX                = 65,
};

// Enum Starbreeze.ESBZBagCategory
// NumValues: 0x0005
enum class ESBZBagCategory : uint8
{
	Loot                                     = 0,
	Secret                                   = 1,
	Equipment                                = 2,
	None                                     = 3,
	ESBZBagCategory_MAX                      = 4,
};

// Enum Starbreeze.ESBZMetaEventType
// NumValues: 0x000B
enum class ESBZMetaEventType : uint8
{
	None                                     = 0,
	IncreasedXP                              = 1,
	IncreasedCash                            = 2,
	IncreasedInfamy                          = 3,
	FreeHeist                                = 4,
	NewYear                                  = 5,
	Halloween                                = 6,
	AprilsFool                               = 7,
	Midsummer                                = 8,
	FreeDlc                                  = 9,
	ESBZMetaEventType_MAX                    = 10,
};

// Enum Starbreeze.ESBZRewardReductionType
// NumValues: 0x0003
enum class ESBZRewardReductionType : uint8
{
	KillingCivilian                          = 0,
	PlayerInCustody                          = 1,
	ESBZRewardReductionType_MAX              = 2,
};

// Enum Starbreeze.ESBZEndMissionResult
// NumValues: 0x0005
enum class ESBZEndMissionResult : uint8
{
	Fail                                     = 0,
	Success                                  = 1,
	Timeout                                  = 2,
	Unknown                                  = 3,
	ESBZEndMissionResult_MAX                 = 4,
};

// Enum Starbreeze.ESBZMilestoneType
// NumValues: 0x0003
enum class ESBZMilestoneType : uint8
{
	ExperienceMilestone                      = 0,
	ExperienceObjective                      = 1,
	ESBZMilestoneType_MAX                    = 2,
};

// Enum Starbreeze.EPD3HeistState
// NumValues: 0x000F
enum class EPD3HeistState : uint8
{
	Stealth                                  = 0,
	Search                                   = 1,
	Alarm                                    = 2,
	FirstResponse                            = 3,
	Negotiation                              = 4,
	Anticipation                             = 5,
	Assault                                  = 6,
	Control                                  = 7,
	PointOfNoReturn                          = 8,
	MAX                                      = 9,
	STEALTH_MAX                              = 1,
	PAGER_MAX                                = 1,
	CARRY_MAX                                = 1,
	CASING_MAX                               = 1,
	NO_CUFFED_TIMER_MAX                      = 1,
};

// Enum Starbreeze.ESBZNegotiationTradeType
// NumValues: 0x0005
enum class ESBZNegotiationTradeType : uint8
{
	None                                     = 0,
	Time                                     = 1,
	Player                                   = 2,
	Pack                                     = 3,
	ESBZNegotiationTradeType_MAX             = 4,
};

// Enum Starbreeze.ESBZAIBehaviorCategory
// NumValues: 0x0005
enum class ESBZAIBehaviorCategory : uint8
{
	None                                     = 0,
	Idle                                     = 1,
	Suspiscious                              = 2,
	Combat                                   = 3,
	MAX                                      = 4,
};

// Enum Starbreeze.ESBZCosmeticDestructionType
// NumValues: 0x0004
enum class ESBZCosmeticDestructionType : uint8
{
	Bullet                                   = 0,
	Explosion                                = 1,
	Melee                                    = 2,
	ESBZCosmeticDestructionType_MAX          = 3,
};

// Enum Starbreeze.ESBZGateState
// NumValues: 0x000C
enum class ESBZGateState : uint8
{
	OpenForward                              = 0,
	OpenBackward                             = 1,
	SlammedClose                             = 2,
	Closed                                   = 3,
	Locked                                   = 4,
	Sealed                                   = 5,
	Barricaded                               = 6,
	BreachedForward                          = 7,
	BreachedBackward                         = 8,
	SlammedOpenForward                       = 9,
	SlammedOpenBackward                      = 10,
	ESBZGateState_MAX                        = 11,
};

// Enum Starbreeze.ESBZHackingState
// NumValues: 0x0006
enum class ESBZHackingState : uint8
{
	NotHacked                                = 0,
	Hacked                                   = 1,
	Overloaded                               = 2,
	Disabled                                 = 3,
	Destroyed                                = 4,
	ESBZHackingState_MAX                     = 5,
};

// Enum Starbreeze.EPD3MiniGameState
// NumValues: 0x0007
enum class EPD3MiniGameState : uint8
{
	None                                     = 0,
	Initiated                                = 1,
	InProgress                               = 2,
	Failed                                   = 3,
	Aborted                                  = 4,
	Success                                  = 5,
	EPD3MiniGameState_MAX                    = 6,
};

// Enum Starbreeze.ESBZTimerState
// NumValues: 0x0006
enum class ESBZTimerState : uint8
{
	Inactive                                 = 0,
	Running                                  = 1,
	Paused                                   = 2,
	Sabotaged                                = 3,
	Done                                     = 4,
	ESBZTimerState_MAX                       = 5,
};

// Enum Starbreeze.ESBZVehicleSpawnResult
// NumValues: 0x0003
enum class ESBZVehicleSpawnResult : uint8
{
	Success                                  = 0,
	Aborted                                  = 1,
	ESBZVehicleSpawnResult_MAX               = 2,
};

// Enum Starbreeze.ESBZServiceStatus
// NumValues: 0x0004
enum class ESBZServiceStatus : uint8
{
	OK                                       = 0,
	InternetFailure                          = 1,
	NebulaFailure                            = 2,
	ESBZServiceStatus_MAX                    = 3,
};

// Enum Starbreeze.ESBZKickingMode
// NumValues: 0x0006
enum class ESBZKickingMode : uint8
{
	PartyDirectKicking                       = 0,
	PartyKickRequest                         = 1,
	GameKickInitiation                       = 2,
	GameKickVoteUp                           = 3,
	GameKickVoteDown                         = 4,
	ESBZKickingMode_MAX                      = 5,
};

// Enum Starbreeze.ESBZKickingError
// NumValues: 0x0003
enum class ESBZKickingError : uint8
{
	NotEnoughPlayers                         = 0,
	KickingInProgress                        = 1,
	ESBZKickingError_MAX                     = 2,
};

// Enum Starbreeze.ESBZChatType
// NumValues: 0x0005
enum class ESBZChatType : uint8
{
	Party                                    = 0,
	Lobby                                    = 1,
	Whisper                                  = 2,
	System                                   = 3,
	ESBZChatType_MAX                         = 4,
};

// Enum Starbreeze.ESBZUserPrivilegesProxy
// NumValues: 0x0006
enum class ESBZUserPrivilegesProxy : uint8
{
	CanPlay                                  = 0,
	CanPlayOnline                            = 1,
	CanCommunicateOnline                     = 2,
	CanUseUserGeneratedContent               = 3,
	CanUserCrossPlay                         = 4,
	ESBZUserPrivilegesProxy_MAX              = 5,
};

// Enum Starbreeze.EPD3DefeatState
// NumValues: 0x000B
enum class EPD3DefeatState : uint8
{
	None                                     = 0,
	TasedGently                              = 1,
	Tased                                    = 2,
	Cuffed                                   = 3,
	Downed                                   = 4,
	BleedOut                                 = 5,
	InCustody                                = 6,
	Subdued                                  = 7,
	CuffedSubdued                            = 8,
	EnragedSubdued                           = 9,
	EPD3DefeatState_MAX                      = 10,
};

// Enum Starbreeze.ESBZEquippableLoadoutSlot
// NumValues: 0x0003
enum class ESBZEquippableLoadoutSlot : uint8
{
	PrimaryWeapon                            = 0,
	SecondaryWeapon                          = 1,
	ESBZEquippableLoadoutSlot_MAX            = 2,
};

// Enum Starbreeze.EPlayerReadyStatusValue
// NumValues: 0x0006
enum class EPlayerReadyStatusValue : uint8
{
	Loading                                  = 0,
	NotReady                                 = 1,
	Ready                                    = 2,
	Transition                               = 3,
	InGame                                   = 4,
	EPlayerReadyStatusValue_MAX              = 5,
};

// Enum Starbreeze.ESBZSecurityCompany
// NumValues: 0x000E
enum class ESBZSecurityCompany : uint8
{
	None                                     = 0,
	GenSec                                   = 1,
	Senturian                                = 2,
	AmGuard                                  = 3,
	DebilitatingSpecials                     = 4,
	FacialRecognition                        = 5,
	ArmorPiercing                            = 6,
	BuddySystem                              = 7,
	AlphaStrike                              = 8,
	HardBargain                              = 9,
	AICore                                   = 10,
	ReflectorShields                         = 11,
	AIShielding                              = 12,
	ESBZSecurityCompany_MAX                  = 13,
};

// Enum Starbreeze.ESBZDisplayCaseState
// NumValues: 0x0007
enum class ESBZDisplayCaseState : uint8
{
	None                                     = 0,
	Closed                                   = 1,
	Open                                     = 2,
	Cut                                      = 3,
	Broken                                   = 4,
	Lockdown                                 = 5,
	ESBZDisplayCaseState_MAX                 = 6,
};

// Enum Starbreeze.ESBZHackableActorInterruptReason
// NumValues: 0x0004
enum class ESBZHackableActorInterruptReason : uint8
{
	Sabotage                                 = 0,
	NeedClearance                            = 1,
	PendingSabotage                          = 2,
	ESBZHackableActorInterruptReason_MAX     = 3,
};

// Enum Starbreeze.ESBZModuleActorState
// NumValues: 0x0007
enum class ESBZModuleActorState : uint8
{
	None                                     = 0,
	Failed                                   = 1,
	Disabled                                 = 2,
	Interacted                               = 3,
	Cut                                      = 4,
	Hacked                                   = 5,
	ESBZModuleActorState_MAX                 = 6,
};

// Enum Starbreeze.ESBZTickingLootType
// NumValues: 0x0005
enum class ESBZTickingLootType : uint8
{
	NotTicking                               = 0,
	Sabotaged                                = 1,
	Increasing                               = 2,
	Decreasing                               = 3,
	ESBZTickingLootType_MAX                  = 4,
};

// Enum Starbreeze.ESBZHoldOutObjectiveResult
// NumValues: 0x0004
enum class ESBZHoldOutObjectiveResult : uint8
{
	Succeeded                                = 0,
	Failed                                   = 1,
	Aborted                                  = 2,
	ESBZHoldOutObjectiveResult_MAX           = 3,
};

// Enum Starbreeze.ESBZHoldOutModeDifficulty
// NumValues: 0x0008
enum class ESBZHoldOutModeDifficulty : uint8
{
	Normal                                   = 0,
	Hard                                     = 1,
	VeryHard                                 = 2,
	Overkill                                 = 3,
	OverkillPlus                             = 4,
	OverkillPlusPlus                         = 5,
	MAX                                      = 6,
	Default                                  = 2,
};

// Enum Starbreeze.ESBZLootProcessorState
// NumValues: 0x0005
enum class ESBZLootProcessorState : uint8
{
	Inactive                                 = 0,
	Running                                  = 1,
	Paused                                   = 2,
	ProcessedBag                             = 3,
	ESBZLootProcessorState_MAX               = 4,
};

// Enum Starbreeze.ESBZCookingState
// NumValues: 0x0009
enum class ESBZCookingState : uint8
{
	Inactive                                 = 0,
	WaitingForIngredients                    = 1,
	Cooking                                  = 2,
	UnderCooked                              = 3,
	Cooked                                   = 4,
	OverCooked                               = 5,
	Sabotaged                                = 6,
	Destroyed                                = 7,
	ESBZCookingState_MAX                     = 8,
};

// Enum Starbreeze.ESBZCameraState
// NumValues: 0x0004
enum class ESBZCameraState : uint8
{
	Enabled                                  = 0,
	Disabled                                 = 1,
	Destroyed                                = 2,
	ESBZCameraState_MAX                      = 3,
};

// Enum Starbreeze.ESBZPowerUpChargesState
// NumValues: 0x0005
enum class ESBZPowerUpChargesState : uint8
{
	NotPlaced                                = 0,
	Placed                                   = 1,
	Interactable                             = 2,
	Empty                                    = 3,
	ESBZPowerUpChargesState_MAX              = 4,
};

// Enum Starbreeze.ESBZSpawnRequestStatus
// NumValues: 0x0006
enum class ESBZSpawnRequestStatus : uint8
{
	Pending                                  = 0,
	Started                                  = 1,
	Finished                                 = 2,
	Canceled                                 = 3,
	TimedOut                                 = 4,
	ESBZSpawnRequestStatus_MAX               = 5,
};

// Enum Starbreeze.ESBZItemLoadoutSlot
// NumValues: 0x0006
enum class ESBZItemLoadoutSlot : uint8
{
	Throwable                                = 0,
	Placeable                                = 1,
	Tool                                     = 2,
	Armour                                   = 3,
	OverkillWeapon                           = 4,
	ESBZItemLoadoutSlot_MAX                  = 5,
};

// Enum Starbreeze.ESBZOnlineTacticType
// NumValues: 0x0005
enum class ESBZOnlineTacticType : uint8
{
	Any                                      = 0,
	Stealth                                  = 1,
	Loud                                     = 2,
	Default                                  = 0,
	ESBZOnlineTacticType_MAX                 = 3,
};

// Enum Starbreeze.ESBZDifficulty
// NumValues: 0x0006
enum class ESBZDifficulty : uint8
{
	Normal                                   = 0,
	Hard                                     = 1,
	VeryHard                                 = 2,
	Overkill                                 = 3,
	MAX                                      = 4,
	Default                                  = 0,
};

// Enum Starbreeze.EPD3AssaultPhase
// NumValues: 0x0008
enum class EPD3AssaultPhase : uint8
{
	Disabled                                 = 0,
	Anticipation                             = 1,
	Build                                    = 2,
	Sustain                                  = 3,
	Fade                                     = 4,
	Regroup                                  = 5,
	Wait                                     = 6,
	EPD3AssaultPhase_MAX                     = 7,
};

// Enum Starbreeze.EPD3DispatchCallerReason
// NumValues: 0x0013
enum class EPD3DispatchCallerReason : uint8
{
	Criminal                                 = 0,
	DeadBody                                 = 1,
	Hostage                                  = 2,
	Object                                   = 3,
	Gunfire                                  = 4,
	Suspect                                  = 5,
	Hostile                                  = 6,
	GenericAlarm                             = 7,
	GenericSearch                            = 8,
	Escaped                                  = 9,
	Cuffed                                   = 10,
	UnlockedGate                             = 11,
	Sabotage                                 = 12,
	BrokenWindow                             = 13,
	BrokenCamera                             = 14,
	None                                     = 15,
	MAX                                      = 16,
	Default                                  = 7,
	GenericAlarm_0                           = 7,
};

// Enum Starbreeze.EPD3DispatchCaller
// NumValues: 0x0007
enum class EPD3DispatchCaller : uint8
{
	Cop                                      = 0,
	Civilian                                 = 1,
	Camera                                   = 2,
	Dispatch                                 = 3,
	MAX                                      = 4,
	Default                                  = 0,
	Cop_0                                    = 0,
};

// Enum Starbreeze.ESBZHeistPlaystyle
// NumValues: 0x0004
enum class ESBZHeistPlaystyle : uint8
{
	Hybrid                                   = 0,
	StealthOnly                              = 1,
	LoudOnly                                 = 2,
	ESBZHeistPlaystyle_MAX                   = 3,
};

// Enum Starbreeze.ESBZHeistComplexity
// NumValues: 0x0004
enum class ESBZHeistComplexity : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	ESBZHeistComplexity_MAX                  = 3,
};

// Enum Starbreeze.ESBZStealthBranch
// NumValues: 0x0003
enum class ESBZStealthBranch : uint8
{
	Stealth                                  = 0,
	Loud                                     = 1,
	ESBZStealthBranch_MAX                    = 2,
};

// Enum Starbreeze.EPD3ECMType
// NumValues: 0x0004
enum class EPD3ECMType : uint8
{
	Radio                                    = 0,
	Pager                                    = 1,
	Camera                                   = 2,
	EPD3ECMType_MAX                          = 3,
};

// Enum Starbreeze.EPD3PawnVariationType
// NumValues: 0x0003
enum class EPD3PawnVariationType : uint8
{
	America                                  = 0,
	MAX                                      = 1,
	DEFAULT                                  = 0,
};

// Enum Starbreeze.EPD3ThreatLevel
// NumValues: 0x0006
enum class EPD3ThreatLevel : uint8
{
	None                                     = 0,
	Low                                      = 1,
	Mid                                      = 2,
	High                                     = 3,
	VeryHigh                                 = 4,
	EPD3ThreatLevel_MAX                      = 5,
};

// Enum Starbreeze.EPD3TickerMode
// NumValues: 0x0006
enum class EPD3TickerMode : uint8
{
	None                                     = 0,
	Casing                                   = 1,
	Assault                                  = 2,
	Negotiation                              = 3,
	Search                                   = 4,
	MAX                                      = 5,
};

// Enum Starbreeze.EPD3AmmoState
// NumValues: 0x0006
enum class EPD3AmmoState : uint8
{
	Normal                                   = 0,
	Low                                      = 1,
	Critical                                 = 2,
	Default                                  = 0,
	Normal_0                                 = 0,
	EPD3AmmoState_MAX                        = 3,
};

// Enum Starbreeze.ESBZAbilityInput
// NumValues: 0x0028
enum class ESBZAbilityInput : uint8
{
	None                                     = 0,
	Jump                                     = 1,
	Slide                                    = 2,
	Crouch                                   = 3,
	Run                                      = 4,
	Targeting                                = 5,
	Fire                                     = 6,
	EquipPrimaryWeapon                       = 7,
	EquipSecondaryWeapon                     = 8,
	Interact                                 = 9,
	Reload                                   = 10,
	RequestOverkillWeapon                    = 11,
	EquipNextWeapon                          = 12,
	EquipPreviousWeapon                      = 13,
	ThrowItem                                = 14,
	ThrowBag                                 = 15,
	Traverse                                 = 16,
	Melee                                    = 17,
	MaskOn                                   = 18,
	PlaceItem                                = 19,
	EquipNextGadget                          = 20,
	PrimaryTool                              = 21,
	PlaceableTool                            = 22,
	ToolSkill                                = 23,
	Shout                                    = 24,
	ShoveHumanShield                         = 25,
	Tackle                                   = 26,
	ToolEquip                                = 27,
	ToolUnequip                              = 28,
	ToolActivate                             = 29,
	ToolInteractAlt                          = 30,
	ToolInteract1                            = 31,
	ToolInteract2                            = 32,
	ToolNavUp                                = 33,
	ToolNavDown                              = 34,
	ToolNavLeft                              = 35,
	ToolNavRight                             = 36,
	AnticipateExplosion                      = 37,
	UseConsumable                            = 38,
	MAX                                      = 39,
};

// Enum Starbreeze.ESBZWeaponType
// NumValues: 0x0003
enum class ESBZWeaponType : uint8
{
	Projectile                               = 0,
	Explosive                                = 1,
	ESBZWeaponType_MAX                       = 2,
};

// Enum Starbreeze.ESBZGlobalLobbyConnectionResult
// NumValues: 0x0003
enum class ESBZGlobalLobbyConnectionResult : uint8
{
	Success                                  = 0,
	Failed                                   = 1,
	ESBZGlobalLobbyConnectionResult_MAX      = 2,
};

// Enum Starbreeze.ESBZUserCreationCode
// NumValues: 0x0004
enum class ESBZUserCreationCode : uint8
{
	Success                                  = 0,
	Duplicate                                = 1,
	Failed                                   = 2,
	ESBZUserCreationCode_MAX                 = 3,
};

// Enum Starbreeze.ESBZLoginCode
// NumValues: 0x000B
enum class ESBZLoginCode : uint8
{
	Success                                  = 0,
	LoginFailed                              = 1,
	NebulaConnectionFailed                   = 2,
	LoginBadRequest                          = 3,
	LoginUnauthorized                        = 4,
	LoginWrongCreds                          = 5,
	LoginLinkingTokenNotFound                = 6,
	LoginLinkingDiffNAccount                 = 7,
	LoginPlayerBanned                        = 8,
	LoginHttpError500                        = 9,
	ESBZLoginCode_MAX                        = 10,
};

// Enum Starbreeze.ESBZAerialVehicleDoor
// NumValues: 0x0003
enum class ESBZAerialVehicleDoor : uint8
{
	Left                                     = 0,
	Right                                    = 1,
	MAX                                      = 2,
};

// Enum Starbreeze.ESBZShapeType
// NumValues: 0x0003
enum class ESBZShapeType : uint8
{
	Box                                      = 0,
	Capsule                                  = 1,
	ESBZShapeType_MAX                        = 2,
};

// Enum Starbreeze.ESBZMovementMode
// NumValues: 0x0008
enum class ESBZMovementMode : uint8
{
	None                                     = 0,
	Walking                                  = 1,
	NavWalking                               = 2,
	Falling                                  = 3,
	Swimming                                 = 4,
	Flying                                   = 5,
	Custom                                   = 6,
	ESBZMovementMode_MAX                     = 7,
};

// Enum Starbreeze.ESBZTurnDirection
// NumValues: 0x0004
enum class ESBZTurnDirection : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	ESBZTurnDirection_MAX                    = 3,
};

// Enum Starbreeze.ESBZAgilitySegmentAxis
// NumValues: 0x0005
enum class ESBZAgilitySegmentAxis : uint8
{
	All                                      = 0,
	Forward                                  = 1,
	Up                                       = 2,
	Side                                     = 3,
	ESBZAgilitySegmentAxis_MAX               = 4,
};

// Enum Starbreeze.ESBZAgilityWarpingDirection
// NumValues: 0x0003
enum class ESBZAgilityWarpingDirection : uint8
{
	FacingFront                              = 0,
	FacingBack                               = 1,
	ESBZAgilityWarpingDirection_MAX          = 2,
};

// Enum Starbreeze.ESBZAgilityPointType
// NumValues: 0x0008
enum class ESBZAgilityPointType : uint8
{
	FloorStart                               = 0,
	FloorEnd                                 = 1,
	Wall                                     = 2,
	FrontEdgeTop                             = 3,
	BackEdgeTop                              = 4,
	FrontEdgeBottom                          = 5,
	BackEdgeBottom                           = 6,
	ESBZAgilityPointType_MAX                 = 7,
};

// Enum Starbreeze.ESBZAgilityType
// NumValues: 0x0016
enum class ESBZAgilityType : uint8
{
	JumpingDown                              = 0,
	JumpingDownRolling                       = 1,
	Vaulting                                 = 2,
	Mantling                                 = 3,
	GrapplingHook                            = 4,
	RappellingThroughWindow                  = 5,
	Rappelling                               = 6,
	RappellingFromHelicopter                 = 7,
	SlideUnder                               = 8,
	SlideUnderFallDown                       = 9,
	ClimbOver                                = 10,
	ClimbOnTop                               = 11,
	JumpingStraight                          = 12,
	CeilingVent                              = 13,
	WallRunningRight                         = 14,
	WallRunningLeft                          = 15,
	ExitFromCarSide                          = 16,
	ExitFromCarBack                          = 17,
	SpawnProneToStand                        = 18,
	SpawnCrouchToStand                       = 19,
	Invalid                                  = 20,
	ESBZAgilityType_MAX                      = 21,
};

// Enum Starbreeze.ESBZAgilityTraversalType
// NumValues: 0x000D
enum class ESBZAgilityTraversalType : uint8
{
	VaultLowSlow                             = 0,
	VaultLowFast                             = 1,
	VaultMediumSlow                          = 2,
	VaultMediumFast                          = 3,
	VaultHighSlow                            = 4,
	VaultHighFast                            = 5,
	MantleLowSlow                            = 6,
	MantleLowFast                            = 7,
	MantleMediumSlow                         = 8,
	MantleMediumFast                         = 9,
	MantleHighSlow                           = 10,
	MantleHighFast                           = 11,
	ESBZAgilityTraversalType_MAX             = 12,
};

// Enum Starbreeze.ESBZAgilityTraversalFamily
// NumValues: 0x0003
enum class ESBZAgilityTraversalFamily : uint8
{
	Vault                                    = 0,
	Mantle                                   = 1,
	ESBZAgilityTraversalFamily_MAX           = 2,
};

// Enum Starbreeze.ESBZComparisonType
// NumValues: 0x0006
enum class ESBZComparisonType : uint8
{
	EQUAL                                    = 0,
	SMALLER                                  = 1,
	SMALLEREQUAL                             = 2,
	LARGER                                   = 3,
	LARGEREQUAL                              = 4,
	ESBZComparisonType_MAX                   = 5,
};

// Enum Starbreeze.ESBZAIActionResult
// NumValues: 0x0004
enum class ESBZAIActionResult : uint8
{
	Failed                                   = 0,
	Succeeded                                = 1,
	InProgress                               = 2,
	ESBZAIActionResult_MAX                   = 3,
};

// Enum Starbreeze.ESBZLifeActionDataExecutionMode
// NumValues: 0x0007
enum class ESBZLifeActionDataExecutionMode : uint8
{
	None                                     = 0,
	DoOnceInterruptible                      = 1,
	DoOnceNonInterruptible                   = 2,
	RepeatInterruptible                      = 3,
	RepeatNonInterruptible                   = 4,
	PeristentDuringLifeAction                = 5,
	ESBZLifeActionDataExecutionMode_MAX      = 6,
};

// Enum Starbreeze.ESBZAIAttractorPriority
// NumValues: 0x0006
enum class ESBZAIAttractorPriority : uint8
{
	VeryLow                                  = 0,
	Low                                      = 25,
	Medium                                   = 50,
	High                                     = 75,
	VeryHigh                                 = 100,
	MAX                                      = 101,
};

// Enum Starbreeze.ESBZAsObjectiveState
// NumValues: 0x0003
enum class ESBZAsObjectiveState : uint8
{
	Outline                                  = 0,
	Marker                                   = 1,
	ESBZAsObjectiveState_MAX                 = 2,
};

// Enum Starbreeze.ESBZInteractionAction
// NumValues: 0x0006
enum class ESBZInteractionAction : uint8
{
	None                                     = 0,
	GetDown                                  = 1,
	HogTie                                   = 2,
	Follow                                   = 3,
	TradeHostage                             = 4,
	MAX                                      = 5,
};

// Enum Starbreeze.ESBZBlockPlayerPawnContext
// NumValues: 0x0005
enum class ESBZBlockPlayerPawnContext : uint8
{
	Init                                     = 0,
	Carried                                  = 1,
	Death                                    = 2,
	WrongDeathPrediction                     = 3,
	ESBZBlockPlayerPawnContext_MAX           = 4,
};

// Enum Starbreeze.ESBZHostageState
// NumValues: 0x0008
enum class ESBZHostageState : uint8
{
	None                                     = 0,
	WantsToGoUpFromGround                    = 1,
	DownOnGround                             = 2,
	HogTied                                  = 4,
	Trade                                    = 8,
	Follow                                   = 16,
	Released                                 = 32,
	ESBZHostageState_MAX                     = 33,
};

// Enum Starbreeze.ESBZAICharacterVariationCategory
// NumValues: 0x0004
enum class ESBZAICharacterVariationCategory : uint8
{
	Default                                  = 0,
	Rescue                                   = 1,
	Sabotage                                 = 2,
	MAX                                      = 3,
};

// Enum Starbreeze.ESBZAICharacterInteractableMode
// NumValues: 0x000C
enum class ESBZAICharacterInteractableMode : uint8
{
	PickUp                                   = 0,
	HumanShield                              = 1,
	AnswerPager                              = 2,
	OrderDownOnGround                        = 3,
	TieHands                                 = 4,
	OrderFollow                              = 5,
	TradeHostage                             = 6,
	KillHumanShield                          = 7,
	PickUpKilledHumanShield                  = 8,
	HackerGlitchProtocol                     = 9,
	None                                     = 10,
	MAX                                      = 11,
};

// Enum Starbreeze.ESBZAICrewCharacterInteractableMode
// NumValues: 0x0005
enum class ESBZAICrewCharacterInteractableMode : uint8
{
	PickUp                                   = 0,
	Revive                                   = 1,
	Uncuff                                   = 2,
	None                                     = 3,
	MAX                                      = 4,
};

// Enum Starbreeze.EAIObjectivePriority
// NumValues: 0x0004
enum class EAIObjectivePriority : uint8
{
	LowPriority                              = 0,
	StandardPriority                         = 1,
	HighPriority                             = 2,
	MAX                                      = 3,
};

// Enum Starbreeze.EAIObjectiveInteractionTypes
// NumValues: 0x0005
enum class EAIObjectiveInteractionTypes : uint8
{
	DirectInteraction                        = 0,
	CutGlassInteraction                      = 1,
	ThrowInteraction                         = 2,
	MoveToAndWait                            = 3,
	MAX                                      = 4,
};

// Enum Starbreeze.ESBZAIInvestigateState
// NumValues: 0x0005
enum class ESBZAIInvestigateState : uint8
{
	None                                     = 0,
	Move                                     = 1,
	UrgentMove                               = 2,
	Investigate                              = 3,
	MAX                                      = 4,
};

// Enum Starbreeze.ESBZAITacticalMoveOrderState
// NumValues: 0x0006
enum class ESBZAITacticalMoveOrderState : uint8
{
	None                                     = 0,
	Move                                     = 1,
	Wait                                     = 2,
	Breach                                   = 3,
	End                                      = 4,
	MAX                                      = 5,
};

// Enum Starbreeze.ESBZAIOrderMode
// NumValues: 0x0006
enum class ESBZAIOrderMode : uint8
{
	Instant                                  = 0,
	Deferred                                 = 1,
	Reset                                    = 2,
	Forced                                   = 3,
	None                                     = 4,
	ESBZAIOrderMode_MAX                      = 5,
};

// Enum Starbreeze.ESBZSenseConfig
// NumValues: 0x0004
enum class ESBZSenseConfig : uint8
{
	Default                                  = 0,
	Combat                                   = 1,
	Distracted                               = 2,
	ESBZSenseConfig_MAX                      = 3,
};

// Enum Starbreeze.ESBZAirNavigationGenerationErrorCode
// NumValues: 0x0004
enum class ESBZAirNavigationGenerationErrorCode : uint8
{
	Success                                  = 0,
	MaxSizeExceeded                          = 1,
	MaxNodesExceeded                         = 2,
	ESBZAirNavigationGenerationErrorCode_MAX = 3,
};

// Enum Starbreeze.ESBZAirPathStatus
// NumValues: 0x0006
enum class ESBZAirPathStatus : uint8
{
	Rejected                                 = 0,
	Failed                                   = 1,
	Partial                                  = 2,
	Succeeded                                = 3,
	InProgress                               = 4,
	ESBZAirPathStatus_MAX                    = 5,
};

// Enum Starbreeze.ESBZInvestigationMode
// NumValues: 0x0003
enum class ESBZInvestigationMode : uint8
{
	Add                                      = 0,
	Update                                   = 1,
	ESBZInvestigationMode_MAX                = 2,
};

// Enum Starbreeze.ESBZAISquadOrderType
// NumValues: 0x0007
enum class ESBZAISquadOrderType : uint8
{
	None                                     = 0,
	Attack                                   = 1,
	Defend                                   = 2,
	Protect                                  = 3,
	Sabotage                                 = 4,
	Retreat                                  = 5,
	ESBZAISquadOrderType_MAX                 = 6,
};

// Enum Starbreeze.ESBZTagsQuerySetting
// NumValues: 0x0003
enum class ESBZTagsQuerySetting : uint32
{
	Any                                      = 0,
	All                                      = 1,
	ESBZTagsQuerySetting_MAX                 = 2,
};

// Enum Starbreeze.ESBZPredicateQueryTarget
// NumValues: 0x0004
enum class ESBZPredicateQueryTarget : uint32
{
	ListenerActor                            = 0,
	StimuliActor                             = 1,
	Stimuli                                  = 2,
	ESBZPredicateQueryTarget_MAX             = 3,
};

// Enum Starbreeze.ESBZAIEscortState
// NumValues: 0x0007
enum class ESBZAIEscortState : uint8
{
	None                                     = 0,
	GoToEscortPoint                          = 1,
	Pickup                                   = 2,
	Start                                    = 3,
	Warn                                     = 4,
	EscortEndWarning                         = 5,
	MAX                                      = 6,
};

// Enum Starbreeze.ETimerScorerSetting
// NumValues: 0x0008
enum class ETimerScorerSetting : uint8
{
	Activate                                 = 0,
	Deactivate                               = 1,
	Select                                   = 2,
	Deselect                                 = 3,
	Success                                  = 4,
	Fail                                     = 5,
	Abort                                    = 6,
	ETimerScorerSetting_MAX                  = 7,
};

// Enum Starbreeze.ESBZRangeTestTargetType
// NumValues: 0x0005
enum class ESBZRangeTestTargetType : uint8
{
	Enemy                                    = 0,
	Player                                   = 1,
	Cop                                      = 2,
	NonAlertedCop                            = 3,
	ESBZRangeTestTargetType_MAX              = 4,
};

// Enum Starbreeze.ESBZAIVisibilityNodeComputationFrequency
// NumValues: 0x0004
enum class ESBZAIVisibilityNodeComputationFrequency : uint8
{
	Once                                     = 0,
	EveryFrame                               = 1,
	Automatic                                = 2,
	ESBZAIVisibilityNodeComputationFrequency_MAX = 3,
};

// Enum Starbreeze.ESBZAIVisibilityStances
// NumValues: 0x0005
enum class ESBZAIVisibilityStances : uint8
{
	None                                     = 0,
	Crouch                                   = 1,
	Stand                                    = 2,
	Invalid                                  = 3,
	ESBZAIVisibilityStances_MAX              = 4,
};

// Enum Starbreeze.ESBZAIWeakPointType
// NumValues: 0x0006
enum class ESBZAIWeakPointType : uint8
{
	None                                     = 0,
	DozerFaceplate                           = 1,
	ShieldVisor                              = 2,
	GrenadeBelt                              = 3,
	TaserBattery                             = 4,
	ESBZAIWeakPointType_MAX                  = 5,
};

// Enum Starbreeze.ESBZHeistEndReason
// NumValues: 0x0004
enum class ESBZHeistEndReason : uint8
{
	GameFinished                             = 0,
	PlayerDroppedOut                         = 1,
	GameTerminated                           = 2,
	ESBZHeistEndReason_MAX                   = 3,
};

// Enum Starbreeze.ESBZAnimatedInteractionStartType
// NumValues: 0x0003
enum class ESBZAnimatedInteractionStartType : uint8
{
	OnStart                                  = 0,
	OnCompleted                              = 1,
	ESBZAnimatedInteractionStartType_MAX     = 2,
};

// Enum Starbreeze.ESBZInertializationSpace
// NumValues: 0x0004
enum class ESBZInertializationSpace : uint8
{
	Default                                  = 0,
	WorldSpace                               = 1,
	WorldRotation                            = 2,
	ESBZInertializationSpace_MAX             = 3,
};

// Enum Starbreeze.ESBZInertializationBoneState
// NumValues: 0x0004
enum class ESBZInertializationBoneState : uint8
{
	Invalid                                  = 0,
	Valid                                    = 1,
	Excluded                                 = 2,
	ESBZInertializationBoneState_MAX         = 3,
};

// Enum Starbreeze.ESBZInertializationState
// NumValues: 0x0004
enum class ESBZInertializationState : uint8
{
	Inactive                                 = 0,
	Pending                                  = 1,
	Active                                   = 2,
	ESBZInertializationState_MAX             = 3,
};

// Enum Starbreeze.ESBZMainMenuAnimationName
// NumValues: 0x0009
enum class ESBZMainMenuAnimationName : uint8
{
	IdleSequence                             = 0,
	PrePlanningSequence                      = 1,
	SuitVisualization                        = 2,
	GloveVisualization                       = 3,
	MainScreenMontageSlot_0                  = 4,
	MainScreenMontageSlot_1                  = 5,
	MainScreenMontageSlot_2                  = 6,
	MainScreenMontageSlot_3                  = 7,
	ESBZMainMenuAnimationName_MAX            = 8,
};

// Enum Starbreeze.ESBZPoseType
// NumValues: 0x0009
enum class ESBZPoseType : uint8
{
	FullBody                                 = 0,
	UpperBody                                = 1,
	UpperBodyEquipped                        = 2,
	UpperBodyEquippedReady                   = 3,
	UpperBodyEquippedRelaxed                 = 4,
	UpperBodyUsingEquipped                   = 5,
	UpperBodyLeftHandEquipped                = 6,
	UpperBodyLeftHandEquippedUsing           = 7,
	ESBZPoseType_MAX                         = 8,
};

// Enum Starbreeze.ESBZCharacterAnimationEvent
// NumValues: 0x0002
enum class ESBZCharacterAnimationEvent : uint8
{
	MoveShieldToBack                         = 0,
	ESBZCharacterAnimationEvent_MAX          = 1,
};

// Enum Starbreeze.ESBZAimOffsetType
// NumValues: 0x0006
enum class ESBZAimOffsetType : uint8
{
	Head                                     = 0,
	UpperBody                                = 1,
	UpperBodyCrouched                        = 2,
	Custom                                   = 3,
	None                                     = 4,
	ESBZAimOffsetType_MAX                    = 5,
};

// Enum Starbreeze.ESBZDisabledAimOffsetType
// NumValues: 0x0004
enum class ESBZDisabledAimOffsetType : uint8
{
	All                                      = 0,
	Head                                     = 1,
	UpperBody                                = 2,
	ESBZDisabledAimOffsetType_MAX            = 3,
};

// Enum Starbreeze.ESBZLookFocusType
// NumValues: 0x0004
enum class ESBZLookFocusType : uint8
{
	Head                                     = 0,
	UpperBody                                = 1,
	Mix                                      = 2,
	ESBZLookFocusType_MAX                    = 3,
};

// Enum Starbreeze.ESBZAnimationAxisDirection
// NumValues: 0x000C
enum class ESBZAnimationAxisDirection : uint8
{
	Forward                                  = 0,
	ForwardLeft45                            = 1,
	ForwardRight45                           = 2,
	Backward                                 = 3,
	BackwardLeft45                           = 4,
	BackwardRight45                          = 5,
	Left                                     = 6,
	Right                                    = 7,
	Up                                       = 8,
	Down                                     = 9,
	Custom                                   = 10,
	ESBZAnimationAxisDirection_MAX           = 11,
};

// Enum Starbreeze.ESBZAdditiveMoveType
// NumValues: 0x0005
enum class ESBZAdditiveMoveType : uint8
{
	Equipped                                 = 0,
	EquippedADS                              = 1,
	LeftHandEquipped                         = 2,
	LeftHandEquippedADS                      = 3,
	ESBZAdditiveMoveType_MAX                 = 4,
};

// Enum Starbreeze.ESBZCoverPoseType
// NumValues: 0x0004
enum class ESBZCoverPoseType : uint8
{
	Stand                                    = 0,
	Crouch                                   = 1,
	None                                     = 2,
	ESBZCoverPoseType_MAX                    = 3,
};

// Enum Starbreeze.ESBZRoomScanningType
// NumValues: 0x0004
enum class ESBZRoomScanningType : uint8
{
	None                                     = 0,
	Static                                   = 1,
	Moving                                   = 2,
	ESBZRoomScanningType_MAX                 = 3,
};

// Enum Starbreeze.ESBZEvadeType
// NumValues: 0x000A
enum class ESBZEvadeType : uint8
{
	StandRightSlow                           = 0,
	StandRightFast                           = 1,
	StandLeftSlow                            = 2,
	StandLeftFast                            = 3,
	CrouchRightSlow                          = 4,
	CrouchRightFast                          = 5,
	CrouchLeftSlow                           = 6,
	CrouchLeftFast                           = 7,
	None                                     = 8,
	ESBZEvadeType_MAX                        = 9,
};

// Enum Starbreeze.ESBZMovementDirection
// NumValues: 0x0003
enum class ESBZMovementDirection : uint8
{
	Forward                                  = 0,
	Backward                                 = 1,
	ESBZMovementDirection_MAX                = 2,
};

// Enum Starbreeze.ESBZAnimLODType
// NumValues: 0x0004
enum class ESBZAnimLODType : uint8
{
	Full                                     = 0,
	LocomotionOnly                           = 1,
	IdleOnly                                 = 2,
	ESBZAnimLODType_MAX                      = 3,
};

// Enum Starbreeze.ESBZFootContactIntensity
// NumValues: 0x0004
enum class ESBZFootContactIntensity : uint8
{
	Medium                                   = 0,
	Low                                      = 1,
	High                                     = 2,
	ESBZFootContactIntensity_MAX             = 3,
};

// Enum Starbreeze.ESBZFootContactType
// NumValues: 0x0003
enum class ESBZFootContactType : uint8
{
	Heel                                     = 0,
	Toe                                      = 1,
	ESBZFootContactType_MAX                  = 2,
};

// Enum Starbreeze.ESBZFootType
// NumValues: 0x0003
enum class ESBZFootType : uint8
{
	LeftFoot                                 = 0,
	RightFoot                                = 1,
	ESBZFootType_MAX                         = 2,
};

// Enum Starbreeze.ESBZPhonemeType
// NumValues: 0x0013
enum class ESBZPhonemeType : uint8
{
	AAA                                      = 0,
	SSS                                      = 1,
	MBP                                      = 2,
	NTD                                      = 3,
	TTH                                      = 4,
	GK                                       = 5,
	OHH                                      = 6,
	RRR                                      = 7,
	AHH                                      = 8,
	EH                                       = 9,
	IEE                                      = 10,
	H                                        = 11,
	UUU                                      = 12,
	WWW                                      = 13,
	SSH                                      = 14,
	FFF                                      = 15,
	L                                        = 16,
	SP                                       = 17,
	ESBZPhonemeType_MAX                      = 18,
};

// Enum Starbreeze.ESBZFacialEmotion
// NumValues: 0x0013
enum class ESBZFacialEmotion : uint8
{
	Invalid                                  = 0,
	Anger                                    = 1,
	Fear                                     = 2,
	Disgust                                  = 3,
	Happiness                                = 4,
	Sadness                                  = 5,
	Surprise                                 = 6,
	Contempt                                 = 7,
	Neutral                                  = 8,
	Effort                                   = 9,
	Pain                                     = 10,
	Drunk                                    = 11,
	Suspicious                               = 12,
	Tough                                    = 13,
	Rage                                     = 14,
	HumanShieldVictim                        = 15,
	Sleep                                    = 16,
	Chew                                     = 17,
	ESBZFacialEmotion_MAX                    = 18,
};

// Enum Starbreeze.ESBZAnimationScalePlayRateType
// NumValues: 0x0005
enum class ESBZAnimationScalePlayRateType : uint8
{
	Native                                   = 0,
	UpAndDown                                = 1,
	OnlyUp                                   = 2,
	OnlyDown                                 = 3,
	ESBZAnimationScalePlayRateType_MAX       = 4,
};

// Enum Starbreeze.ESBZArmorSpeedPenalty
// NumValues: 0x0005
enum class ESBZArmorSpeedPenalty : uint8
{
	None                                     = 0,
	Light                                    = 1,
	Medium                                   = 2,
	Heavy                                    = 3,
	ESBZArmorSpeedPenalty_MAX                = 4,
};

// Enum Starbreeze.ESBZBagTriggerMode
// NumValues: 0x0005
enum class ESBZBagTriggerMode : uint8
{
	SecureAndDestroy                         = 0,
	DestroyOnly                              = 1,
	Teleport                                 = 2,
	Nothing                                  = 3,
	ESBZBagTriggerMode_MAX                   = 4,
};

// Enum Starbreeze.ESBZBlackMarketVendorType
// NumValues: 0x0008
enum class ESBZBlackMarketVendorType : uint8
{
	Featured                                 = 0,
	Combat                                   = 1,
	Character                                = 2,
	Tailor                                   = 3,
	Gold                                     = 4,
	Armor                                    = 5,
	None                                     = 6,
	ESBZBlackMarketVendorType_MAX            = 7,
};

// Enum Starbreeze.ESBZBreachingEquipmentState
// NumValues: 0x0009
enum class ESBZBreachingEquipmentState : uint8
{
	HeatingUp                                = 0,
	Running                                  = 1,
	NotAssembled                             = 2,
	Off                                      = 3,
	NeedsAdjusting                           = 4,
	Jammed                                   = 5,
	Done                                     = 6,
	AbortedAndDisabled                       = 7,
	ESBZBreachingEquipmentState_MAX          = 8,
};

// Enum Starbreeze.ESBZOnBreakableBrokenAction
// NumValues: 0x0003
enum class ESBZOnBreakableBrokenAction : uint8
{
	Fall                                     = 0,
	Destroy                                  = 1,
	ESBZOnBreakableBrokenAction_MAX          = 2,
};

// Enum Starbreeze.ESBZBreakableMachineState
// NumValues: 0x0005
enum class ESBZBreakableMachineState : uint8
{
	Closed                                   = 0,
	Open                                     = 1,
	OpenBroken                               = 2,
	None                                     = 3,
	ESBZBreakableMachineState_MAX            = 4,
};

// Enum Starbreeze.ESBZBreakableMachineInteractionMode
// NumValues: 0x0005
enum class ESBZBreakableMachineInteractionMode : uint8
{
	ForceOpen                                = 0,
	Open                                     = 1,
	Loot                                     = 2,
	None                                     = 3,
	MAX                                      = 4,
};

// Enum Starbreeze.ESBZFocusPriority
// NumValues: 0x0004
enum class ESBZFocusPriority : uint8
{
	AI                                       = 3,
	Attack                                   = 4,
	Override                                 = 5,
	ESBZFocusPriority_MAX                    = 6,
};

// Enum Starbreeze.ESBZAIPlaceDeployableType
// NumValues: 0x0004
enum class ESBZAIPlaceDeployableType : uint8
{
	Ammo                                     = 0,
	Armor                                    = 1,
	Health                                   = 2,
	MAX                                      = 3,
};

// Enum Starbreeze.ESBZArrestType
// NumValues: 0x0003
enum class ESBZArrestType : uint8
{
	Criminal                                 = 0,
	Enemy                                    = 1,
	ESBZArrestType_MAX                       = 2,
};

// Enum Starbreeze.ESBZBuiltInAnimMontageTrackType
// NumValues: 0x0007
enum class ESBZBuiltInAnimMontageTrackType : uint8
{
	X                                        = 0,
	Y                                        = 1,
	Z                                        = 2,
	Pitch                                    = 3,
	Yaw                                      = 4,
	Roll                                     = 5,
	ESBZBuiltInAnimMontageTrackType_MAX      = 6,
};

// Enum Starbreeze.ESBZCharacterCapsuleShadowingQuality
// NumValues: 0x0006
enum class ESBZCharacterCapsuleShadowingQuality : uint8
{
	Disabled                                 = 0,
	Low                                      = 1,
	Medium                                   = 2,
	High                                     = 3,
	Epic                                     = 4,
	ESBZCharacterCapsuleShadowingQuality_MAX = 5,
};

// Enum Starbreeze.ESBZHurtReactionType
// NumValues: 0x0019
enum class ESBZHurtReactionType : uint8
{
	Hurt                                     = 0,
	Death                                    = 1,
	SprintForwardHurt                        = 2,
	SprintForwardDeath                       = 3,
	ExplosionHurt                            = 4,
	ExplosionDeath                           = 5,
	NeutralHurt                              = 6,
	NeutralDeath                             = 7,
	NeutralSprintForwardHurt                 = 8,
	NeutralSprintForwardDeath                = 9,
	NeutralExplosionHurt                     = 10,
	NeutralExplosionDeath                    = 11,
	BracedHurt                               = 12,
	BracedDeath                              = 13,
	BracedSprintForwardHurt                  = 14,
	BracedSprintForwardDeath                 = 15,
	BracedExplosionHurt                      = 16,
	BracedExplosionDeath                     = 17,
	NeutralBracedHurt                        = 18,
	NeutralBracedDeath                       = 19,
	NeutralBracedSprintForwardHurt           = 20,
	NeutralBracedSprintForwardDeath          = 21,
	NeutralBracedExplosionHurt               = 22,
	NeutralBracedExplosionDeath              = 23,
	MAX                                      = 24,
};

// Enum Starbreeze.ESBZCharacterLockReason
// NumValues: 0x0003
enum class ESBZCharacterLockReason : uint8
{
	NotLocked                                = 0,
	NotOwningDLC                             = 1,
	ESBZCharacterLockReason_MAX              = 2,
};

// Enum Starbreeze.ESBZCharacterSlotStatus
// NumValues: 0x0003
enum class ESBZCharacterSlotStatus : uint8
{
	Available                                = 0,
	Taken                                    = 1,
	ESBZCharacterSlotStatus_MAX              = 2,
};

// Enum Starbreeze.ESBZHumanShieldEnterType
// NumValues: 0x0006
enum class ESBZHumanShieldEnterType : uint8
{
	Front                                    = 0,
	Back                                     = 1,
	Left                                     = 2,
	Right                                    = 3,
	Invalid                                  = 4,
	ESBZHumanShieldEnterType_MAX             = 5,
};

// Enum Starbreeze.ESBZHumanShieldInstigatorState
// NumValues: 0x0007
enum class ESBZHumanShieldInstigatorState : uint8
{
	None                                     = 0,
	ReachingSlot                             = 1,
	EnterGrabbing                            = 2,
	Grabbing                                 = 3,
	Choking                                  = 4,
	Exiting                                  = 5,
	ESBZHumanShieldInstigatorState_MAX       = 6,
};

// Enum Starbreeze.ESBZCharacterMovementState
// NumValues: 0x0009
enum class ESBZCharacterMovementState : uint8
{
	Walking                                  = 0,
	Running                                  = 1,
	Crouching                                = 2,
	Jumping                                  = 3,
	Traversing                               = 4,
	Sliding                                  = 5,
	Proning                                  = 6,
	Falling                                  = 7,
	MAX                                      = 8,
};

// Enum Starbreeze.ESBZCharacterStanceVariation
// NumValues: 0x0004
enum class ESBZCharacterStanceVariation : uint8
{
	Normal                                   = 0,
	Slow                                     = 1,
	Fast                                     = 2,
	ESBZCharacterStanceVariation_MAX         = 3,
};

// Enum Starbreeze.ESBZCharacterStance
// NumValues: 0x000E
enum class ESBZCharacterStance : uint8
{
	Neutral                                  = 0,
	Suspicious                               = 1,
	Investigate                              = 2,
	Stealth                                  = 3,
	Combat                                   = 4,
	Panic                                    = 5,
	Hostage                                  = 6,
	HumanShieldInstigator                    = 7,
	HumanShieldVictim                        = 8,
	DownedDefeated                           = 9,
	Impaired                                 = 10,
	Last                                     = 11,
	First                                    = 0,
	ESBZCharacterStance_MAX                  = 12,
};

// Enum Starbreeze.ESBZPlayerHandRigTransformType
// NumValues: 0x0004
enum class ESBZPlayerHandRigTransformType : uint8
{
	None                                     = 0,
	Default                                  = 1,
	Crouched                                 = 2,
	ESBZPlayerHandRigTransformType_MAX       = 3,
};

// Enum Starbreeze.ESBZVoiceEvent
// NumValues: 0x0003
enum class ESBZVoiceEvent : uint8
{
	CharacterEvent                           = 0,
	WheelEvent                               = 1,
	MAX                                      = 2,
};

// Enum Starbreeze.ESBZVoicePriority
// NumValues: 0x0008
enum class ESBZVoicePriority : uint8
{
	VeryLowPriority                          = 0,
	LowPriority                              = 1,
	MediumPriority                           = 2,
	HighPriority                             = 3,
	VeryHighPriority                         = 4,
	ExtremelyHighPriority                    = 100,
	MaxPriority                              = 255,
	ESBZVoicePriority_MAX                    = 256,
};

// Enum Starbreeze.ESBZVoiceGruntType
// NumValues: 0x0007
enum class ESBZVoiceGruntType : uint8
{
	Light                                    = 0,
	Heavy                                    = 1,
	HurtLight                                = 2,
	HurtHeavy                                = 3,
	Upwards                                  = 4,
	Downwards                                = 5,
	ESBZVoiceGruntType_MAX                   = 6,
};

// Enum Starbreeze.ESBZChatCommandTypes
// NumValues: 0x0007
enum class ESBZChatCommandTypes : uint8
{
	CommandWhisperTo                         = 0,
	CommandPartyChat                         = 1,
	CommandGroupChat                         = 2,
	CommandInvitePlayer                      = 3,
	CommandVoteKick                          = 4,
	CommandMute                              = 5,
	ESBZChatCommandTypes_MAX                 = 6,
};

// Enum Starbreeze.ESBZFriendlyFireSettings
// NumValues: 0x0004
enum class ESBZFriendlyFireSettings : uint8
{
	NoOverride                               = 0,
	Allowed                                  = 1,
	NotAllowed                               = 2,
	ESBZFriendlyFireSettings_MAX             = 3,
};

// Enum Starbreeze.ESBZLogVerbosityType
// NumValues: 0x000A
enum class ESBZLogVerbosityType : uint8
{
	NoLogging                                = 0,
	Fatal                                    = 1,
	Error                                    = 2,
	Warning                                  = 3,
	Display                                  = 4,
	Log                                      = 5,
	Verbose                                  = 6,
	VeryVerbose                              = 7,
	All                                      = 7,
	ESBZLogVerbosityType_MAX                 = 8,
};

// Enum Starbreeze.ESBZDebugNetEmulationType
// NumValues: 0x0004
enum class ESBZDebugNetEmulationType : uint8
{
	None                                     = 0,
	Average                                  = 1,
	Bad                                      = 2,
	ESBZDebugNetEmulationType_MAX            = 3,
};

// Enum Starbreeze.ESBZDebugNetEmulationTarget
// NumValues: 0x0004
enum class ESBZDebugNetEmulationTarget : uint8
{
	Local                                    = 0,
	Server                                   = 1,
	All                                      = 2,
	ESBZDebugNetEmulationTarget_MAX          = 3,
};

// Enum Starbreeze.ESBZChromaDevice
// NumValues: 0x0008
enum class ESBZChromaDevice : uint8
{
	Keyboard                                 = 0,
	Mouse                                    = 1,
	Headset                                  = 2,
	Mousepad                                 = 3,
	Keypad                                   = 4,
	ChromaLink                               = 5,
	NumDevices                               = 6,
	ESBZChromaDevice_MAX                     = 7,
};

// Enum Starbreeze.ESBZGameStateMachineState
// NumValues: 0x001E
enum class ESBZGameStateMachineState : uint8
{
	SM_NotLoggedIn                           = 0,
	SM_SubsystemInitialisation               = 1,
	SM_WaitFirstGameStart                    = 2,
	SM_WaitSoloGame                          = 3,
	SM_GameStart                             = 4,
	SM_Matchmaking                           = 5,
	SM_Lobby                                 = 6,
	SM_P2PHost                               = 7,
	SM_WaitingActionPhase                    = 8,
	SM_WaitingActionPhaseHost                = 9,
	SM_WaitingActionPhaseClient              = 10,
	SM_WaitingActionPhaseDropIn              = 11,
	SM_FunctionalTest                        = 12,
	SM_JobOverview                           = 13,
	SM_JobOverviewDropIn                     = 14,
	SM_JobOverviewDirectJoin                 = 15,
	SM_ActionPhase                           = 16,
	SM_HostMigration                         = 17,
	SM_WaitMainMenu                          = 18,
	SM_WaitingResult                         = 19,
	SM_Result                                = 20,
	SM_GameError                             = 21,
	SM_BackendError                          = 22,
	SM_WaitingReturnToIIS                    = 23,
	SM_WaitingReplay                         = 24,
	SM_Replay                                = 25,
	SM_Outro                                 = 26,
	SM_WaitingRestartLevel                   = 27,
	SM_Undefined                             = 28,
	SM_MAX                                   = 29,
};

// Enum Starbreeze.ESBZMaintenanceBoxState
// NumValues: 0x0005
enum class ESBZMaintenanceBoxState : uint8
{
	Off                                      = 0,
	On                                       = 1,
	Cutting                                  = 2,
	Deactivate                               = 3,
	ESBZMaintenanceBoxState_MAX              = 4,
};

// Enum Starbreeze.ESBZConsumableInteractableMode
// NumValues: 0x0004
enum class ESBZConsumableInteractableMode : uint8
{
	Pickup                                   = 0,
	Use                                      = 1,
	None                                     = 2,
	MAX                                      = 3,
};

// Enum Starbreeze.ESBZRarity
// NumValues: 0x0006
enum class ESBZRarity : uint8
{
	Common                                   = 0,
	Uncommon                                 = 1,
	Rare                                     = 2,
	Epic                                     = 3,
	Legendary                                = 4,
	ESBZRarity_MAX                           = 5,
};

// Enum Starbreeze.ESBZCoverPointScoringMode
// NumValues: 0x0005
enum class ESBZCoverPointScoringMode : uint8
{
	Min                                      = 0,
	Max                                      = 1,
	Averaged                                 = 2,
	OnlyTarget                               = 3,
	ESBZCoverPointScoringMode_MAX            = 4,
};

// Enum Starbreeze.ESBZShootingPointType
// NumValues: 0x0009
enum class ESBZShootingPointType : uint8
{
	CrouchLeft                               = 0,
	StandLeft                                = 1,
	StandFront                               = 2,
	StandFrontLow                            = 3,
	StandRight                               = 4,
	CrouchRight                              = 5,
	StandHigh                                = 6,
	Max                                      = 7,
	ESBZShootingPointType_MAX                = 8,
};

// Enum Starbreeze.ESBZCurrencyCode
// NumValues: 0x0004
enum class ESBZCurrencyCode : uint8
{
	Cash                                     = 0,
	Gold                                     = 1,
	Credit                                   = 2,
	MAX                                      = 3,
};

// Enum Starbreeze.ESBZItemCurrencyType
// NumValues: 0x0004
enum class ESBZItemCurrencyType : uint8
{
	NONE                                     = 0,
	REAL                                     = 1,
	VIRTUAL                                  = 2,
	ESBZItemCurrencyType_MAX                 = 3,
};

// Enum Starbreeze.ESBZCuttingMaterialTier
// NumValues: 0x0005
enum class ESBZCuttingMaterialTier : uint8
{
	None                                     = 0,
	Tier1                                    = 1,
	Tier2                                    = 2,
	Tier3                                    = 3,
	ESBZCuttingMaterialTier_MAX              = 4,
};

// Enum Starbreeze.ESBZCuttableState
// NumValues: 0x0004
enum class ESBZCuttableState : uint8
{
	Whole                                    = 0,
	Cut                                      = 1,
	NotCuttable                              = 2,
	ESBZCuttableState_MAX                    = 3,
};

// Enum Starbreeze.ESBZCuttableType
// NumValues: 0x0003
enum class ESBZCuttableType : uint8
{
	Circle                                   = 0,
	Line                                     = 1,
	ESBZCuttableType_MAX                     = 2,
};

// Enum Starbreeze.ESBZCuttableSplineType
// NumValues: 0x0003
enum class ESBZCuttableSplineType : uint8
{
	Circle                                   = 0,
	Line                                     = 1,
	ESBZCuttableSplineType_MAX               = 2,
};

// Enum Starbreeze.ESBZDamageWeight
// NumValues: 0x0005
enum class ESBZDamageWeight : uint8
{
	Flinch                                   = 0,
	Interrupt                                = 1,
	Stun                                     = 2,
	Incapacitate                             = 3,
	MAX                                      = 4,
};

// Enum Starbreeze.ESBZDbgDisplayOutput
// NumValues: 0x0002
enum class ESBZDbgDisplayOutput : uint8
{
	Subtitle                                 = 0,
	ESBZDbgDisplayOutput_MAX                 = 1,
};

// Enum Starbreeze.ESBZUIDebugState
// NumValues: 0x0004
enum class ESBZUIDebugState : uint8
{
	Cinematic                                = 0,
	Watermark                                = 1,
	FullScreen                               = 2,
	ESBZUIDebugState_MAX                     = 3,
};

// Enum Starbreeze.ESBZDecorativeSmokeState
// NumValues: 0x0003
enum class ESBZDecorativeSmokeState : uint8
{
	Spawned                                  = 0,
	Smoking                                  = 1,
	ESBZDecorativeSmokeState_MAX             = 2,
};

// Enum Starbreeze.ESBZDeviceProfileOverrideMode
// NumValues: 0x0003
enum class ESBZDeviceProfileOverrideMode : uint8
{
	PerformanceMode                          = 0,
	QualityMode                              = 1,
	ESBZDeviceProfileOverrideMode_MAX        = 2,
};

// Enum Starbreeze.ESBZPlayDialogResult
// NumValues: 0x0004
enum class ESBZPlayDialogResult : uint8
{
	Successful                               = 0,
	Failed                                   = 1,
	Queued                                   = 2,
	ESBZPlayDialogResult_MAX                 = 3,
};

// Enum Starbreeze.ESBZDialogPerformer
// NumValues: 0x0007
enum class ESBZDialogPerformer : uint8
{
	Narrator                                 = 0,
	Instigator                               = 1,
	Performer1                               = 2,
	Performer2                               = 3,
	Performer3                               = 4,
	Performer4                               = 5,
	ESBZDialogPerformer_MAX                  = 6,
};

// Enum Starbreeze.ESBZDialogType
// NumValues: 0x0003
enum class ESBZDialogType : uint8
{
	Mission                                  = 0,
	Thematic                                 = 1,
	ESBZDialogType_MAX                       = 2,
};

// Enum Starbreeze.ESBZDisableHandIkType
// NumValues: 0x0004
enum class ESBZDisableHandIkType : uint8
{
	Left                                     = 0,
	Right                                    = 1,
	Both                                     = 2,
	ESBZDisableHandIkType_MAX                = 3,
};

// Enum Starbreeze.ESBZDrillState
// NumValues: 0x0005
enum class ESBZDrillState : uint8
{
	None                                     = 0,
	Drilling                                 = 1,
	Jammed                                   = 2,
	Done                                     = 3,
	ESBZDrillState_MAX                       = 4,
};

// Enum Starbreeze.ESBZDsStateMachineState
// NumValues: 0x0006
enum class ESBZDsStateMachineState : uint8
{
	SM_DsActionPhase                         = 0,
	SM_DsResult                              = 1,
	SM_DsWaitingForPlayers                   = 2,
	SM_DsLoading                             = 3,
	SM_DsRestartLevel                        = 4,
	SM_DsUndefined                           = 5,
};

// Enum Starbreeze.ESBZCDPType
// NumValues: 0x0009
enum class ESBZCDPType : uint8
{
	Float                                    = 0,
	Boolean                                  = 1,
	Integer                                  = 2,
	ColorRGB                                 = 3,
	ColorRGBA                                = 4,
	SelectRBG                                = 5,
	Pattern                                  = 6,
	Digits                                   = 7,
	ESBZCDPType_MAX                          = 8,
};

// Enum Starbreeze.ESBZAgilityIKHandIKType
// NumValues: 0x0003
enum class ESBZAgilityIKHandIKType : uint8
{
	Left                                     = 0,
	Right                                    = 1,
	ESBZAgilityIKHandIKType_MAX              = 2,
};

// Enum Starbreeze.ESBZWorldRuntimeActorOptions
// NumValues: 0x0013
enum class ESBZWorldRuntimeActorOptions : uint8
{
	AllPlayerCharacters                      = 0,
	AllAlivePlayerCharacters                 = 1,
	AllAliveAICharacters                     = 2,
	AllDespawnVolumes                        = 3,
	AllDefensePoints                         = 4,
	AllRoomVolumes                           = 5,
	AllEscortPoints                          = 6,
	AllBagDropPoints                         = 7,
	AllAIObjectives                          = 8,
	AllVantagePoints                         = 9,
	AllSabotageTargets                       = 10,
	AllSecurityCameras                       = 11,
	AllProtectPoints                         = 12,
	AllArmedGrenades                         = 13,
	AllHostages                              = 14,
	AllTowerHideLifeActions                  = 15,
	AllAliveAICrewCharacters                 = 16,
	AllOverkillWeaponDropPoints              = 17,
	MAX                                      = 18,
};

// Enum Starbreeze.ESBZEnvTestPathfindingDetail
// NumValues: 0x0005
enum class ESBZEnvTestPathfindingDetail : uint8
{
	Rough                                    = 0,
	Detailed                                 = 1,
	NoNavPathfinding                         = 2,
	NoChecks                                 = 3,
	ESBZEnvTestPathfindingDetail_MAX         = 4,
};

// Enum Starbreeze.ESBZEquippableFamily
// NumValues: 0x000C
enum class ESBZEquippableFamily : uint8
{
	HandsFree                                = 0,
	HandGun1H                                = 1,
	HandGun2H                                = 2,
	RiflePistolGrip                          = 3,
	RifleStraightGrip                        = 4,
	Melee1H                                  = 5,
	Melee2H                                  = 6,
	DualWield                                = 7,
	HandheldItem                             = 8,
	Last                                     = 9,
	First                                    = 0,
	ESBZEquippableFamily_MAX                 = 10,
};

// Enum Starbreeze.ESBZEquipState
// NumValues: 0x0005
enum class ESBZEquipState : uint8
{
	Unequipped                               = 0,
	Equipping                                = 1,
	Equipped                                 = 2,
	Unequipping                              = 3,
	MAX                                      = 4,
};

// Enum Starbreeze.ESBZEventReactorState
// NumValues: 0x0006
enum class ESBZEventReactorState : uint8
{
	Inactive                                 = 0,
	Normal                                   = 1,
	Glitched                                 = 2,
	VeryGlitched                             = 3,
	Destroyed                                = 4,
	MAX                                      = 5,
};

// Enum Starbreeze.ESBZFactionAttitude
// NumValues: 0x0005
enum class ESBZFactionAttitude : uint8
{
	Invalid                                  = 0,
	Friendly                                 = 1,
	Neutral                                  = 2,
	Hostile                                  = 3,
	ESBZFactionAttitude_MAX                  = 4,
};

// Enum Starbreeze.ESBZFireType
// NumValues: 0x0006
enum class ESBZFireType : uint8
{
	Semi                                     = 0,
	Burst                                    = 1,
	Auto                                     = 2,
	Pump                                     = 3,
	Bolt                                     = 4,
	ESBZFireType_MAX                         = 5,
};

// Enum Starbreeze.ESBZFireMode
// NumValues: 0x0004
enum class ESBZFireMode : uint8
{
	Single                                   = 0,
	Burst                                    = 1,
	Auto                                     = 2,
	ESBZFireMode_MAX                         = 3,
};

// Enum Starbreeze.ESBZFireTokenType
// NumValues: 0x0005
enum class ESBZFireTokenType : uint8
{
	Miss                                     = 0,
	Normal                                   = 1,
	Grenade                                  = 2,
	Sniper                                   = 3,
	ESBZFireTokenType_MAX                    = 4,
};

// Enum Starbreeze.ESBZMainMenuState
// NumValues: 0x0009
enum class ESBZMainMenuState : uint8
{
	MainScreen                               = 0,
	PrePlanning                              = 1,
	Loadout                                  = 2,
	BlackMarket                              = 3,
	MatchMaking                              = 4,
	Options                                  = 5,
	SuitVisualization                        = 6,
	GlovesVisualization                      = 7,
	ESBZMainMenuState_MAX                    = 8,
};

// Enum Starbreeze.ESBZCheaterPolicyType
// NumValues: 0x0004
enum class ESBZCheaterPolicyType : uint8
{
	NoAction                                 = 0,
	Ban                                      = 1,
	DefaultItems                             = 2,
	ESBZCheaterPolicyType_MAX                = 3,
};

// Enum Starbreeze.ESBZNotOwningHeistPolicyType
// NumValues: 0x0004
enum class ESBZNotOwningHeistPolicyType : uint8
{
	NoAction                                 = 0,
	Ban                                      = 1,
	ReturnToMainMenu                         = 2,
	ESBZNotOwningHeistPolicyType_MAX         = 3,
};

// Enum Starbreeze.ESBZChallengeDailyCompletionTimeType
// NumValues: 0x0003
enum class ESBZChallengeDailyCompletionTimeType : uint8
{
	Medium                                   = 0,
	Long                                     = 1,
	ESBZChallengeDailyCompletionTimeType_MAX = 2,
};

// Enum Starbreeze.ESBZChallengeRecommandationsPriorityType
// NumValues: 0x0004
enum class ESBZChallengeRecommandationsPriorityType : uint8
{
	CloseToCompletion                        = 0,
	AnyProgress                              = 1,
	LowProgress                              = 2,
	ESBZChallengeRecommandationsPriorityType_MAX = 3,
};

// Enum Starbreeze.ESBZMetaEventModifierType
// NumValues: 0x0004
enum class ESBZMetaEventModifierType : uint8
{
	XP                                       = 0,
	Cash                                     = 1,
	Infamy                                   = 2,
	ESBZMetaEventModifierType_MAX            = 3,
};

// Enum Starbreeze.ESBZWeaponCustomizationSubScreen
// NumValues: 0x000A
enum class ESBZWeaponCustomizationSubScreen : uint8
{
	WeaponSlot                               = 0,
	WeaponPart                               = 1,
	CosmeticSlot                             = 2,
	CosmeticWearNTear                        = 3,
	CosmeticBaseDesign                       = 4,
	CosmeticMaterial                         = 5,
	CosmeticPattern                          = 6,
	CosmeticSticker                          = 7,
	CosmeticCharm                            = 8,
	ESBZWeaponCustomizationSubScreen_MAX     = 9,
};

// Enum Starbreeze.ESBZCurrentPlatform
// NumValues: 0x0007
enum class ESBZCurrentPlatform : uint8
{
	EP_UNKNOWN                               = 0,
	EP_LINUX                                 = 1,
	EP_PC                                    = 2,
	EP_MAC                                   = 3,
	EP_XBOX                                  = 4,
	EP_PLAYSTATION                           = 5,
	EP_MAX                                   = 6,
};

// Enum Starbreeze.EClientJoinType
// NumValues: 0x0003
enum class EClientJoinType : uint8
{
	Normal                                   = 0,
	DirectJoin                               = 1,
	EClientJoinType_MAX                      = 2,
};

// Enum Starbreeze.ESBZGameMachineStateError
// NumValues: 0x0036
enum class ESBZGameMachineStateError : uint8
{
	HostDisconnected                         = 0,
	HostFailedToStartLoading                 = 1,
	DropInIntoEndedMission                   = 2,
	WrongGameVersion                         = 3,
	NoMatchingServerVersion                  = 4,
	MatchmakingError                         = 5,
	HostBeaconDisconnected                   = 6,
	ActionBeaconTimeout                      = 7,
	TravelToHostTimeout                      = 8,
	StartTravellingHandshakeFailed           = 9,
	MissionEnded                             = 10,
	InvalidReturnToMainMenu                  = 11,
	HostMigrationFailed                      = 12,
	WrongLevel                               = 13,
	SteamNotSignedIn                         = 14,
	EOSNotSignedIn                           = 15,
	PSNNotSignedIn                           = 16,
	XboxLiveNotSignedIn                      = 17,
	PremiumAccountEligibilityCheck           = 18,
	NetworkNoConnection                      = 19,
	FailedToFetchRequiredAccelByteData       = 20,
	LostConnectionToMatchMakingService       = 21,
	NebulaLoginConnectionFailed              = 22,
	NebulaLoginConnectionFailedAlreadyLinked = 23,
	NebulaLoginFailed                        = 24,
	NebulaLoginLinking                       = 25,
	NebulaLoginLinkingOtherXbox              = 26,
	NebulaLoginWrongCreds                    = 27,
	Unknown                                  = 28,
	FailedToResumeGame                       = 29,
	PartySessionIsFull                       = 30,
	PartySessionDoesNotExist                 = 31,
	PartySessionAlreadyInSession             = 32,
	PartySessionInvalidFriendship            = 33,
	PartySessionInvalidCode                  = 34,
	PartySessionMaxActiveSessionReached      = 35,
	PartySessionInvalidJoinability           = 36,
	PartySessionInactiveTimeout              = 37,
	PartySessionMemberBlock                  = 38,
	GameSessionIsFull                        = 39,
	GameSessionDoesNotExist                  = 40,
	GameSessionAlreadyInSession              = 41,
	GameSessionInvalidFriendship             = 42,
	GameSessionInvalidCode                   = 43,
	GameSessionMaxActiveSessionReached       = 44,
	GameSessionInvalidJoinability            = 45,
	GameSessionInactiveTimeout               = 46,
	GameSessionMemberBlock                   = 47,
	ReturningFromSuspendedState              = 48,
	LobbyClosedConnection                    = 49,
	PlayerBanned                             = 50,
	JoinedCrossPlatformSession               = 51,
	MultipleSessionsLogin                    = 52,
	ESBZGameMachineStateError_MAX            = 53,
};

// Enum Starbreeze.ESBZReturnToSubsystemInitialisationReason
// NumValues: 0x0003
enum class ESBZReturnToSubsystemInitialisationReason : uint8
{
	Default                                  = 0,
	UserChange                               = 1,
	ESBZReturnToSubsystemInitialisationReason_MAX = 2,
};

// Enum Starbreeze.ESBZReturnToIISReason
// NumValues: 0x0008
enum class ESBZReturnToIISReason : uint8
{
	NoError                                  = 0,
	ReturnFromSuspension                     = 1,
	LoggedOut                                = 2,
	SwitchedUser                             = 3,
	LostConnectionToTheInternet              = 4,
	InvalidLoadout                           = 5,
	LoggedOutAmbiguously                     = 6,
	ESBZReturnToIISReason_MAX                = 7,
};

// Enum Starbreeze.ESBZReturnToLoginReason
// NumValues: 0x0003
enum class ESBZReturnToLoginReason : uint8
{
	Unknown                                  = 0,
	FailedToFetchBackendData                 = 1,
	ESBZReturnToLoginReason_MAX              = 2,
};

// Enum Starbreeze.ESBZReturnToMainMenuReason
// NumValues: 0x000F
enum class ESBZReturnToMainMenuReason : uint8
{
	Unknown                                  = 0,
	UserRequest                              = 1,
	PartyHostRequest                         = 2,
	MatchmakingTimeout                       = 3,
	MissionEnded                             = 4,
	QuickMatchLostConnectionToSession        = 5,
	MatchmakingError                         = 6,
	InviteProcessing                         = 7,
	PartyFailedToJoinLobby                   = 8,
	InvalidReplay                            = 9,
	CanPlayOnlineCheckFailed                 = 10,
	JoinProcessing                           = 11,
	CancelMatchmaking                        = 12,
	KickedByHost                             = 13,
	ESBZReturnToMainMenuReason_MAX           = 14,
};

// Enum Starbreeze.ESBZPopupType
// NumValues: 0x0018
enum class ESBZPopupType : uint8
{
	None                                     = 0,
	FirstTime                                = 1,
	PhotoSensitivity                         = 2,
	GameSense                                = 3,
	Telemetry                                = 4,
	Crossplay                                = 5,
	Tutorial                                 = 6,
	Skills                                   = 7,
	Vendors                                  = 8,
	Challenges                               = 9,
	WeaponMods                               = 10,
	WeaponCustomization                      = 11,
	OverkillWeapon                           = 12,
	HeistSelection                           = 13,
	CharacterSelection                       = 14,
	MaskInventory                            = 15,
	MaskCustomization                        = 16,
	SuitInventory                            = 17,
	GloveInventory                           = 18,
	LoadoutMenu                              = 19,
	SoloMode                                 = 20,
	SeverBrowserLongIntro                    = 21,
	Onboarding                               = 22,
	ESBZPopupType_MAX                        = 23,
};

// Enum Starbreeze.ESBZGameUserSetting
// NumValues: 0x0013
enum class ESBZGameUserSetting : uint8
{
	GamepadHorizontalSensitivity             = 0,
	GamepadVerticalSensitivity               = 1,
	IsChatDisabled                           = 2,
	IsCrossplayDisabled                      = 3,
	MouseSensitivity                         = 4,
	MouseSensitivityMultiplier               = 5,
	TargetingSensitivityMultiplier           = 6,
	UseForceFeedback                         = 7,
	UseHoldForTabMenu                        = 8,
	UseHoldToCrouch                          = 9,
	UseHoldToRun                             = 10,
	UseHoldToTarget                          = 11,
	IsHoldToSlide                            = 12,
	UseInvertedYAxis                         = 13,
	UseMouseSmoothing                        = 14,
	UseSwitchWeaponAutomatically             = 15,
	IsRememberSkipIntroSequence              = 16,
	HeadbobScale                             = 17,
	ESBZGameUserSetting_MAX                  = 18,
};

// Enum Starbreeze.ESBZGasCellGrowMode
// NumValues: 0x0003
enum class ESBZGasCellGrowMode : uint8
{
	SelfGenerateDensity                      = 0,
	GetDensityFromNeighbours                 = 1,
	ESBZGasCellGrowMode_MAX                  = 2,
};

// Enum Starbreeze.ESBZGateSoundReduction
// NumValues: 0x0006
enum class ESBZGateSoundReduction : uint8
{
	None                                     = 0,
	Low                                      = 1,
	Medium                                   = 2,
	High                                     = 3,
	Total                                    = 4,
	MAX                                      = 5,
};

// Enum Starbreeze.ESBZPlacementState
// NumValues: 0x0004
enum class ESBZPlacementState : uint8
{
	None                                     = 0,
	Invalid                                  = 1,
	Valid                                    = 2,
	ESBZPlacementState_MAX                   = 3,
};

// Enum Starbreeze.ESBZRequestPresenceResult
// NumValues: 0x0004
enum class ESBZRequestPresenceResult : uint8
{
	Success                                  = 0,
	AlreadyConnectedOnOtherPlatform          = 1,
	GetPresenceFailed                        = 2,
	ESBZRequestPresenceResult_MAX            = 3,
};

// Enum Starbreeze.ESBZGlobalLobbyRequestResult
// NumValues: 0x0003
enum class ESBZGlobalLobbyRequestResult : uint8
{
	Success                                  = 0,
	LobbyConnectionFailed                    = 1,
	ESBZGlobalLobbyRequestResult_MAX         = 2,
};

// Enum Starbreeze.ESBZHackableActorUnlockMode
// NumValues: 0x0004
enum class ESBZHackableActorUnlockMode : uint8
{
	NoSecurity                               = 0,
	HackUnlock                               = 1,
	KeyItemUnlock                            = 2,
	ESBZHackableActorUnlockMode_MAX          = 3,
};

// Enum Starbreeze.ESBZHackableActorState
// NumValues: 0x0009
enum class ESBZHackableActorState : uint8
{
	Inactive                                 = 0,
	Active                                   = 1,
	Hacking                                  = 2,
	PendingSabotage                          = 3,
	Sabotaged                                = 4,
	NeedClearance                            = 5,
	Unlocked                                 = 6,
	GainedAccess                             = 7,
	ESBZHackableActorState_MAX               = 8,
};

// Enum Starbreeze.ESBZLoudOptions
// NumValues: 0x0005
enum class ESBZLoudOptions : uint8
{
	ResetAndRestart                          = 0,
	ResetAndStop                             = 1,
	Cancel                                   = 2,
	Continue                                 = 3,
	ESBZLoudOptions_MAX                      = 4,
};

// Enum Starbreeze.ESBZVariationValue
// NumValues: 0x0008
enum class ESBZVariationValue : uint8
{
	A                                        = 6,
	B                                        = 5,
	C                                        = 4,
	D                                        = 3,
	E                                        = 2,
	F                                        = 1,
	G                                        = 0,
	ESBZVariationValue_MAX                   = 7,
};

// Enum Starbreeze.ESBZHurtReactionDirection
// NumValues: 0x0005
enum class ESBZHurtReactionDirection : uint8
{
	Forward                                  = 0,
	Right                                    = 1,
	Backward                                 = 2,
	Left                                     = 3,
	MAX                                      = 4,
};

// Enum Starbreeze.ESBZHurtReactionPose
// NumValues: 0x0005
enum class ESBZHurtReactionPose : uint8
{
	Standing                                 = 0,
	Crouching                                = 1,
	LyingOnFront                             = 2,
	LyingOnBack                              = 3,
	ESBZHurtReactionPose_MAX                 = 4,
};

// Enum Starbreeze.ESBZMeleeAttackCategory
// NumValues: 0x0003
enum class ESBZMeleeAttackCategory : uint8
{
	Heavy                                    = 0,
	Light                                    = 1,
	ESBZMeleeAttackCategory_MAX              = 2,
};

// Enum Starbreeze.ESBZMeleeImpactType
// NumValues: 0x0005
enum class ESBZMeleeImpactType : uint8
{
	Blunt                                    = 0,
	Slash                                    = 1,
	Pierce                                   = 2,
	Trauma                                   = 3,
	ESBZMeleeImpactType_MAX                  = 4,
};

// Enum Starbreeze.ESBZInstigatingPlayerStateSource
// NumValues: 0x0004
enum class ESBZInstigatingPlayerStateSource : uint8
{
	None                                     = 0,
	RangedWeapon                             = 1,
	Explosion                                = 2,
	ESBZInstigatingPlayerStateSource_MAX     = 3,
};

// Enum Starbreeze.ESBZItemProgressionSource
// NumValues: 0x0003
enum class ESBZItemProgressionSource : uint8
{
	InfamyLevel                              = 0,
	Skill                                    = 1,
	ESBZItemProgressionSource_MAX            = 2,
};

// Enum Starbreeze.ESBZItemRarity
// NumValues: 0x0008
enum class ESBZItemRarity : uint8
{
	NoRarity                                 = 0,
	Common                                   = 1,
	Uncommon                                 = 2,
	Rare                                     = 3,
	Mythic                                   = 4,
	Epic                                     = 5,
	Legendary                                = 6,
	ESBZItemRarity_MAX                       = 7,
};

// Enum Starbreeze.ESBZInventoryEquipmentType
// NumValues: 0x0009
enum class ESBZInventoryEquipmentType : uint8
{
	PrimaryWeapon                            = 0,
	SecondaryWeapon                          = 1,
	OverkillWeapon                           = 2,
	Armor                                    = 3,
	Placeable                                = 4,
	Throwable                                = 5,
	Tools                                    = 6,
	Skills                                   = 7,
	ESBZInventoryEquipmentType_MAX           = 8,
};

// Enum Starbreeze.ESBZRewardRequestType
// NumValues: 0x0005
enum class ESBZRewardRequestType : uint8
{
	HeistCompleted                           = 0,
	Renown                                   = 1,
	Infamy                                   = 2,
	Challenge                                = 3,
	ESBZRewardRequestType_MAX                = 4,
};

// Enum Starbreeze.ESBZItemInventorySlotType
// NumValues: 0x0005
enum class ESBZItemInventorySlotType : uint8
{
	PremiumPreset                            = 0,
	Preset                                   = 1,
	Configurable                             = 2,
	Preconfig                                = 3,
	ESBZItemInventorySlotType_MAX            = 4,
};

// Enum Starbreeze.ESBZItemInventorySlotAvailability
// NumValues: 0x0003
enum class ESBZItemInventorySlotAvailability : uint8
{
	Available                                = 0,
	Taken                                    = 1,
	ESBZItemInventorySlotAvailability_MAX    = 2,
};

// Enum Starbreeze.ESBZItemCategory
// NumValues: 0x002F
enum class ESBZItemCategory : uint8
{
	PrimaryWeapon                            = 0,
	SecondaryWeapon                          = 1,
	OverkillWeapon                           = 2,
	Throwable                                = 3,
	Mask                                     = 4,
	Tool                                     = 5,
	Placeable                                = 6,
	SkillLine                                = 7,
	PreplanningAsset                         = 8,
	PrimaryWeaponSlot                        = 9,
	SecondaryWeaponSlot                      = 10,
	Armor                                    = 11,
	ArmorInventorySlot                       = 12,
	PrimaryWeaponPreset                      = 13,
	SecondaryWeaponPreset                    = 14,
	LoadoutSlot                              = 15,
	PlayerCharacter                          = 16,
	MaskInventorySlot                        = 17,
	SuitInventorySlot                        = 18,
	GloveInventorySlot                       = 19,
	SprayCan                                 = 20,
	WeaponCharm                              = 21,
	WeaponPattern                            = 22,
	WeaponSticker                            = 23,
	WeaponWearAndTear                        = 24,
	SuitPreset                               = 25,
	SuitMaterial                             = 26,
	SuitPattern                              = 27,
	Watch                                    = 28,
	Glove                                    = 29,
	Suit                                     = 30,
	SuitBase                                 = 31,
	MaskMould                                = 32,
	MaskPreset                               = 33,
	MaskPreconfig                            = 34,
	MaskPattern                              = 35,
	MaskMaterial                             = 36,
	MaskVFX                                  = 37,
	Coin                                     = 38,
	ItemBundle                               = 39,
	PayDayCredits                            = 40,
	Heist                                    = 41,
	VendorPermission                         = 42,
	WeaponPartAttachment                     = 43,
	OverskillLoadout                         = 44,
	SkillCategory                            = 45,
	ESBZItemCategory_MAX                     = 46,
};

// Enum Starbreeze.ESBZLifeActionState
// NumValues: 0x0006
enum class ESBZLifeActionState : uint8
{
	Stopped                                  = 0,
	Pending                                  = 1,
	Entering                                 = 2,
	Playing                                  = 3,
	Exiting                                  = 4,
	ESBZLifeActionState_MAX                  = 5,
};

// Enum Starbreeze.ESBZLifeActionAlignmentMode
// NumValues: 0x0004
enum class ESBZLifeActionAlignmentMode : uint8
{
	Translation                              = 0,
	Rotation                                 = 1,
	Both                                     = 2,
	ESBZLifeActionAlignmentMode_MAX          = 3,
};

// Enum Starbreeze.ESBZLoadProgressionStep
// NumValues: 0x001E
enum class ESBZLoadProgressionStep : uint8
{
	AsyncLoadAssetDatabaseDone               = 0,
	LoadCharacterDone                        = 1,
	IncPlayerLoginDone                       = 2,
	SetCurrentServerTimeDone                 = 3,
	GetItemsDone                             = 4,
	GetOwningIdsForAllItemsDone              = 5,
	IncPlayerItemRewardLoginDone             = 6,
	GetPlayerStatisticsDone                  = 7,
	ProgressionSaveGameLoaded                = 8,
	QueryAchivementsDone                     = 9,
	LoadProgressionSaveChallengesDone        = 10,
	GetWalletBalanceDone                     = 11,
	SyncDLCsDone                             = 12,
	GetRealMoneyItemsDone                    = 13,
	GetWeaponPartAttachmentsDone             = 14,
	GetUserEntitlementsDone                  = 15,
	RetrieveClientConfigurationDone          = 16,
	RetrieveClientGameRecordDone             = 17,
	ClientRetrieveFeatureToggleDataDone      = 18,
	ClientRetrieveMatchmakingDataDone        = 19,
	ClientRetrieveTitleDataDone              = 20,
	ReceivingInfamyTranslationTableDone      = 21,
	ClientRetrieveMetaEventsDataDone         = 22,
	ClientRetrieveTimeBasedPlayerContentDone = 23,
	ClientRetrieveDLCRewardsDone             = 24,
	RetrieveSecurityFirmRotationDataReceivedDone = 25,
	ClientFetchChallengeRecommendationsDone  = 26,
	FetchChallengeDailiesDone                = 27,
	ClientFetchChallengesDone                = 28,
	ESBZLoadProgressionStep_MAX              = 29,
};

// Enum Starbreeze.EBSZPatternMenuMode
// NumValues: 0x0003
enum class EBSZPatternMenuMode : uint8
{
	Pattern                                  = 0,
	SprayCans                                = 1,
	EBSZPatternMenuMode_MAX                  = 2,
};

// Enum Starbreeze.ESBZMainMenuCosmeticType
// NumValues: 0x0003
enum class ESBZMainMenuCosmeticType : uint8
{
	Mask                                     = 0,
	Weapon                                   = 1,
	ESBZMainMenuCosmeticType_MAX             = 2,
};

// Enum Starbreeze.ESBZCreditsType
// NumValues: 0x0008
enum class ESBZCreditsType : uint8
{
	Title                                    = 0,
	SubTitle                                 = 1,
	Heading                                  = 2,
	Text                                     = 3,
	TextPair                                 = 4,
	Image                                    = 5,
	Linebreak                                = 6,
	MAX                                      = 7,
};

// Enum Starbreeze.ESBZCharacterPreferenceButtonSelectionAction
// NumValues: 0x0004
enum class ESBZCharacterPreferenceButtonSelectionAction : uint8
{
	None                                     = 0,
	Switch                                   = 1,
	Select                                   = 2,
	ESBZCharacterPreferenceButtonSelectionAction_MAX = 3,
};

// Enum Starbreeze.ESBZUIItemSource
// NumValues: 0x0003
enum class ESBZUIItemSource : uint8
{
	InfamyLevel                              = 0,
	Skill                                    = 1,
	ESBZUIItemSource_MAX                     = 2,
};

// Enum Starbreeze.ESBZMarkerState
// NumValues: 0x000C
enum class ESBZMarkerState : uint8
{
	Suspicious                               = 0,
	Alerted                                  = 1,
	Alarm                                    = 2,
	Escalate                                 = 3,
	Escort                                   = 4,
	PreEscort                                = 5,
	Arrest                                   = 6,
	Sabotage                                 = 7,
	Bag                                      = 8,
	Investigate                              = 9,
	None                                     = 10,
	ESBZMarkerState_MAX                      = 11,
};

// Enum Starbreeze.ESBZMaskCosmeticsSlot
// NumValues: 0x0005
enum class ESBZMaskCosmeticsSlot : uint8
{
	MouldSlot                                = 0,
	MaterialSlot                             = 1,
	PatternSlot                              = 2,
	VFXSlot                                  = 3,
	ESBZMaskCosmeticsSlot_MAX                = 4,
};

// Enum Starbreeze.ESBZMaskMaterialState
// NumValues: 0x0003
enum class ESBZMaskMaterialState : uint8
{
	New                                      = 0,
	Old                                      = 1,
	ESBZMaskMaterialState_MAX                = 2,
};

// Enum Starbreeze.ESBZMaskType
// NumValues: 0x0003
enum class ESBZMaskType : uint8
{
	Strap                                    = 0,
	FullHelm                                 = 1,
	ESBZMaskType_MAX                         = 2,
};

// Enum Starbreeze.ESBZMaskVFXSlot
// NumValues: 0x0004
enum class ESBZMaskVFXSlot : uint8
{
	Mouth                                    = 0,
	Nose                                     = 1,
	Eyes                                     = 2,
	ESBZMaskVFXSlot_MAX                      = 3,
};

// Enum Starbreeze.ESBZMeleeHitType
// NumValues: 0x0005
enum class ESBZMeleeHitType : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	Front                                    = 3,
	MAX                                      = 4,
};

// Enum Starbreeze.ESBZMenuDisableHandIkType
// NumValues: 0x0004
enum class ESBZMenuDisableHandIkType : uint8
{
	Left                                     = 0,
	Right                                    = 1,
	Both                                     = 2,
	ESBZMenuDisableHandIkType_MAX            = 3,
};

// Enum Starbreeze.ESBZBoneAnimConstraintType
// NumValues: 0x0003
enum class ESBZBoneAnimConstraintType : uint8
{
	Static                                   = 0,
	FollowsBone                              = 1,
	ESBZBoneAnimConstraintType_MAX           = 2,
};

// Enum Starbreeze.ESBZModularMeshSpawnStep
// NumValues: 0x0004
enum class ESBZModularMeshSpawnStep : uint8
{
	Default                                  = 0,
	Mount                                    = 1,
	Adapter                                  = 2,
	ESBZModularMeshSpawnStep_MAX             = 3,
};

// Enum Starbreeze.ESBZObjectiveType
// NumValues: 0x0005
enum class ESBZObjectiveType : uint8
{
	OneShot                                  = 0,
	Progress                                 = 1,
	Timed                                    = 2,
	Money                                    = 3,
	ESBZObjectiveType_MAX                    = 4,
};

// Enum Starbreeze.ESBZProgressTextDisplayOption
// NumValues: 0x0006
enum class ESBZProgressTextDisplayOption : uint8
{
	None                                     = 0,
	ShowFraction                             = 1,
	ShowPercentage                           = 2,
	ShowSpeed                                = 3,
	ShowActualTime                           = 4,
	ESBZProgressTextDisplayOption_MAX        = 5,
};

// Enum Starbreeze.ESBZSubobjectiveComplete
// NumValues: 0x0006
enum class ESBZSubobjectiveComplete : uint8
{
	None                                     = 0,
	CompleteOnAll                            = 1,
	CompleteOnAllOrFail                      = 2,
	CompleteOnAllEnded                       = 3,
	ProgressOnComplete                       = 4,
	ESBZSubobjectiveComplete_MAX             = 5,
};

// Enum Starbreeze.ESBZObjectiveGroup
// NumValues: 0x0008
enum class ESBZObjectiveGroup : uint8
{
	None                                     = 0,
	MainObjective                            = 1,
	OtherObjective0                          = 2,
	OtherObjective1                          = 3,
	OtherObjective2                          = 4,
	OtherObjective3                          = 5,
	OtherObjective4                          = 6,
	ESBZObjectiveGroup_MAX                   = 7,
};

// Enum Starbreeze.ESBZObjectiveState
// NumValues: 0x0006
enum class ESBZObjectiveState : uint8
{
	None                                     = 0,
	Active                                   = 1,
	Failed                                   = 2,
	Complete                                 = 3,
	Disabled                                 = 4,
	ESBZObjectiveState_MAX                   = 5,
};

// Enum Starbreeze.EFriendStatus
// NumValues: 0x0006
enum class EFriendStatus : uint8
{
	Offline                                  = 0,
	Available                                = 1,
	Away                                     = 2,
	Invisible                                = 3,
	Unknown                                  = 4,
	EFriendStatus_MAX                        = 5,
};

// Enum Starbreeze.ESBZMatchmakingCommand
// NumValues: 0x0004
enum class ESBZMatchmakingCommand : uint8
{
	RegularMatchmaking                       = 0,
	ForceListenServer                        = 1,
	ForceClient                              = 2,
	ESBZMatchmakingCommand_MAX               = 3,
};

// Enum Starbreeze.ESBZPresenceState
// NumValues: 0x0005
enum class ESBZPresenceState : uint8
{
	None                                     = 0,
	InMenu                                   = 1,
	InLobby                                  = 2,
	InLevel                                  = 3,
	ESBZPresenceState_MAX                    = 4,
};

// Enum Starbreeze.ESBZOnlineAnalyticsReason
// NumValues: 0x0017
enum class ESBZOnlineAnalyticsReason : uint8
{
	Undefined                                = 0,
	InitialParty                             = 1,
	Matchmaking                              = 2,
	PlayTogether                             = 3,
	DebugSession                             = 4,
	BeaconLostConnectionToHost               = 5,
	PartyHostChangedSession                  = 6,
	MatchmakingFoundNewSession               = 7,
	DebugLeaveSessionNode                    = 8,
	InviteProcessing                         = 9,
	InviteProcessingFailed                   = 10,
	AcceptMatchCooldown                      = 11,
	RestartMatchCooldown                     = 12,
	DisconnectedWaitingResult                = 13,
	UserLaunchedSoloGame                     = 14,
	UserLeftParty                            = 15,
	ReturnToMenuFromActionPhase              = 16,
	ReturnToMenuFromLobby                    = 17,
	ReturnToMenuFromMatchmaking              = 18,
	ReturnToMenuFromResult                   = 19,
	GameError                                = 20,
	IisError                                 = 21,
	ESBZOnlineAnalyticsReason_MAX            = 22,
};

// Enum Starbreeze.ESBZSessionState
// NumValues: 0x0006
enum class ESBZSessionState : uint8
{
	Ready                                    = 0,
	HostingInProgress                        = 1,
	SearchInProgress                         = 2,
	JoinInProgress                           = 3,
	LeaveInProgress                          = 4,
	ESBZSessionState_MAX                     = 5,
};

// Enum Starbreeze.EOnlineSessionInfo
// NumValues: 0x0013
enum class EOnlineSessionInfo : uint8
{
	Initial                                  = 0,
	Terminating                              = 1,
	Terminated                               = 2,
	Interrupt                                = 3,
	Searching                                = 4,
	SearchCompleted                          = 5,
	ReservedSlot                             = 6,
	NoSlots                                  = 7,
	Joining                                  = 8,
	Joined                                   = 9,
	Hosting                                  = 10,
	Host                                     = 11,
	Updating                                 = 12,
	CheckingPrivileges                       = 13,
	CannotPlayOnline                         = 14,
	SmartMatching                            = 15,
	TimedOut                                 = 16,
	Error                                    = 17,
	EOnlineSessionInfo_MAX                   = 18,
};

// Enum Starbreeze.ESBZOnlineDropInType
// NumValues: 0x0004
enum class ESBZOnlineDropInType : uint8
{
	Yes                                      = 0,
	No                                       = 1,
	Default                                  = 0,
	ESBZOnlineDropInType_MAX                 = 2,
};

// Enum Starbreeze.ESBZOnlineSessionRequestType
// NumValues: 0x000C
enum class ESBZOnlineSessionRequestType : uint8
{
	PartyUpdate                              = 0,
	LobbyUpdate                              = 1,
	Join                                     = 2,
	Host                                     = 3,
	DestroyLobby                             = 4,
	HostParty                                = 5,
	DestroyParty                             = 6,
	Search                                   = 7,
	RestoreLobbyBeacon                       = 8,
	RestorePartyBeacon                       = 9,
	None                                     = 10,
	ESBZOnlineSessionRequestType_MAX         = 11,
};

// Enum Starbreeze.ESBZSessionType
// NumValues: 0x0004
enum class ESBZSessionType : uint8
{
	Unknown                                  = 0,
	GameSession                              = 1,
	PartySession                             = 2,
	ESBZSessionType_MAX                      = 3,
};

// Enum Starbreeze.ESBZHostingProvider
// NumValues: 0x0004
enum class ESBZHostingProvider : uint8
{
	Accelbyte                                = 0,
	AmazonGameLift                           = 1,
	EdgeGap                                  = 2,
	MAX                                      = 3,
};

// Enum Starbreeze.ESBZMatchmakingProvider
// NumValues: 0x0004
enum class ESBZMatchmakingProvider : uint8
{
	Accelbyte                                = 0,
	AmazonGameLift                           = 1,
	EdgeGap                                  = 2,
	MAX                                      = 3,
};

// Enum Starbreeze.ESBZSlotReservationStatus
// NumValues: 0x0008
enum class ESBZSlotReservationStatus : uint8
{
	Failure                                  = 0,
	Success                                  = 1,
	SlotAlreadyReserved                      = 2,
	NoFreeSlots                              = 3,
	InvalidPlayerIdReceived                  = 4,
	ServerInWrongState                       = 5,
	SlotsNumberMismatch                      = 6,
	ESBZSlotReservationStatus_MAX            = 7,
};

// Enum Starbreeze.ESBZSelectedCharacterSource
// NumValues: 0x0003
enum class ESBZSelectedCharacterSource : uint8
{
	PreferredCharacters                      = 0,
	InventoryCharacters                      = 1,
	ESBZSelectedCharacterSource_MAX          = 2,
};

// Enum Starbreeze.ESBZPreMatchLobbyStatus
// NumValues: 0x0006
enum class ESBZPreMatchLobbyStatus : uint8
{
	WaitingForReady                          = 0,
	WaitingForLoading                        = 1,
	ReadyToTravel                            = 2,
	MatchInProgress                          = 3,
	Default                                  = 0,
	ESBZPreMatchLobbyStatus_MAX              = 4,
};

// Enum Starbreeze.ESBZVoiceSessionDomain
// NumValues: 0x0005
enum class ESBZVoiceSessionDomain : uint8
{
	Unknown                                  = 0,
	Lobby                                    = 1,
	Match                                    = 2,
	Default                                  = 0,
	ESBZVoiceSessionDomain_MAX               = 3,
};

// Enum Starbreeze.ETLMVoiceSessionState
// NumValues: 0x0006
enum class ETLMVoiceSessionState : uint8
{
	ToCreate                                 = 0,
	Creating                                 = 1,
	Created                                  = 2,
	Failed                                   = 3,
	NONE                                     = 4,
	ETLMVoiceSessionState_MAX                = 5,
};

// Enum Starbreeze.ESBZPartyInvitationSystem
// NumValues: 0x0003
enum class ESBZPartyInvitationSystem : uint8
{
	Accelbyte                                = 0,
	Native                                   = 1,
	ESBZPartyInvitationSystem_MAX            = 2,
};

// Enum Starbreeze.ESBZPartyInviteStatus
// NumValues: 0x0004
enum class ESBZPartyInviteStatus : uint8
{
	Pending                                  = 0,
	Active                                   = 1,
	Processed                                = 2,
	ESBZPartyInviteStatus_MAX                = 3,
};

// Enum Starbreeze.ESBZPartyInvitationType
// NumValues: 0x0003
enum class ESBZPartyInvitationType : uint8
{
	Incoming                                 = 0,
	Outgoing                                 = 1,
	ESBZPartyInvitationType_MAX              = 2,
};

// Enum Starbreeze.ESBZPartyRequestFeedbackType
// NumValues: 0x0002
enum class ESBZPartyRequestFeedbackType : uint8
{
	PartyInviteRequest                       = 0,
	ESBZPartyRequestFeedbackType_MAX         = 1,
};

// Enum Starbreeze.ESBZPartyError
// NumValues: 0x0010
enum class ESBZPartyError : uint8
{
	DifferentGameClientsVersion              = 0,
	FriendNotFound                           = 1,
	PartyLeaderLeft                          = 2,
	DifferentHostingProvider                 = 3,
	JoinedCrossPlatformSession               = 4,
	SessionIsFull                            = 5,
	SessionDoesNotExist                      = 6,
	AlreadyInSession                         = 7,
	InvalidFriendship                        = 8,
	InvalidCode                              = 9,
	MaxActiveSessionReached                  = 10,
	InvalidJoinability                       = 11,
	InactiveTimeout                          = 12,
	MemberBlock                              = 13,
	UnknownError                             = 14,
	ESBZPartyError_MAX                       = 15,
};

// Enum Starbreeze.ESBZSpawnRotationMethod
// NumValues: 0x0003
enum class ESBZSpawnRotationMethod : uint8
{
	SpawnRotation                            = 0,
	SpecificHeadingAngle                     = 1,
	ESBZSpawnRotationMethod_MAX              = 2,
};

// Enum Starbreeze.ESBZPhoneScreenState
// NumValues: 0x0005
enum class ESBZPhoneScreenState : uint8
{
	Activate                                 = 0,
	Waiting                                  = 1,
	Complete                                 = 2,
	Fail                                     = 3,
	ESBZPhoneScreenState_MAX                 = 4,
};

// Enum Starbreeze.EPingQuality
// NumValues: 0x0005
enum class EPingQuality : uint8
{
	EPQ_Default                              = 0,
	EPQ_Fair                                 = 1,
	EPQ_High                                 = 2,
	EPQ_Critical                             = 3,
	EPQ_MAX                                  = 4,
};

// Enum Starbreeze.ESBZPlaceableChargeType
// NumValues: 0x0006
enum class ESBZPlaceableChargeType : uint8
{
	None                                     = 0,
	Ammo                                     = 1,
	Armor                                    = 2,
	Health                                   = 3,
	Sentry                                   = 4,
	MAX                                      = 5,
};

// Enum Starbreeze.ESBZPlaceableChargeState
// NumValues: 0x0006
enum class ESBZPlaceableChargeState : uint8
{
	None                                     = 0,
	Activating                               = 1,
	Thrown                                   = 2,
	Placed                                   = 3,
	Canceled                                 = 4,
	ESBZPlaceableChargeState_MAX             = 5,
};

// Enum Starbreeze.ESBZPlaceableToolType
// NumValues: 0x0007
enum class ESBZPlaceableToolType : uint8
{
	None                                     = 0,
	ECMJammer                                = 1,
	MicroCamera                              = 2,
	SensorTool                               = 3,
	TripMine                                 = 4,
	Tripper                                  = 5,
	ESBZPlaceableToolType_MAX                = 6,
};

// Enum Starbreeze.ESBZPlayerAbilityBuffType
// NumValues: 0x0004
enum class ESBZPlayerAbilityBuffType : uint8
{
	Speed                                    = 0,
	Mitigation                               = 1,
	Damage                                   = 2,
	MAX                                      = 3,
};

// Enum Starbreeze.ESBZSocialPlayerCardType
// NumValues: 0x000B
enum class ESBZSocialPlayerCardType : uint8
{
	AccelByteFriend                          = 0,
	PlatformFriend                           = 1,
	IncomingFriendRequest                    = 2,
	OutgoingFriendRequest                    = 3,
	UserSearchResult                         = 4,
	BlockedPlayers                           = 5,
	OfflineFriends                           = 6,
	RecentlyPlayed                           = 7,
	PartyMember                              = 8,
	Matchmaking                              = 9,
	ESBZSocialPlayerCardType_MAX             = 10,
};

// Enum Starbreeze.ESBZPlayerCardContainerType
// NumValues: 0x0007
enum class ESBZPlayerCardContainerType : uint8
{
	PCCT_Friends                             = 0,
	PCCT_Requests                            = 1,
	PCCT_RecentlyPlayed                      = 2,
	PCCT_Blocked                             = 3,
	PCCT_Crew                                = 4,
	PCCT_SearchUsers                         = 5,
	PCCT_MAX                                 = 6,
};

// Enum Starbreeze.EPlayerCharacterSizeCategory
// NumValues: 0x0006
enum class EPlayerCharacterSizeCategory : uint8
{
	MaleAverage                              = 0,
	MaleHeavy                                = 1,
	MaleMuscular                             = 2,
	Female                                   = 3,
	Count                                    = 4,
	EPlayerCharacterSizeCategory_MAX         = 5,
};

// Enum Starbreeze.ESBZReactionType
// NumValues: 0x001E
enum class ESBZReactionType : uint8
{
	PlaceMedicBag                            = 0,
	PlaceAmmoBag                             = 1,
	PlaceArmorBag                            = 2,
	PlaceSentryTurret                        = 3,
	PlaceMicroCamera                         = 4,
	PlaceECMJammer                           = 5,
	PlaceSensorTool                          = 6,
	PlaceTripMine                            = 7,
	PlayerDowned                             = 8,
	PlayerRevived                            = 9,
	PlayerFlashed                            = 10,
	PlayerGassed                             = 11,
	PlayerTased                              = 12,
	PlayerTasedMine                          = 13,
	PlayerTasedBattery                       = 14,
	SWATSurrenders                           = 15,
	HostageTraded                            = 16,
	HumanShield                              = 17,
	PlayerCuffedByCloaker                    = 18,
	PlayerUsingOverkillWeapon                = 19,
	ECMJammerActive                          = 20,
	HeisterChainsIdle                        = 21,
	HeisterDallasIdle                        = 22,
	HeisterHoxtonIdle                        = 23,
	HeisterJoyIdle                           = 24,
	HeisterPearlIdle                         = 25,
	HeisterWolfIdle                          = 26,
	HeisterUnkownIdle                        = 27,
	PlaceTripper                             = 28,
	MAX                                      = 29,
};

// Enum Starbreeze.ESBZPlayerGestureType
// NumValues: 0x0003
enum class ESBZPlayerGestureType : uint8
{
	None                                     = 0,
	Pointing                                 = 1,
	MAX                                      = 2,
};

// Enum Starbreeze.ESBZPlayerInteractableMode
// NumValues: 0x0004
enum class ESBZPlayerInteractableMode : uint8
{
	Revive                                   = 0,
	Uncuff                                   = 1,
	Disengage                                = 2,
	MAX                                      = 3,
};

// Enum Starbreeze.ESBZItemType
// NumValues: 0x0004
enum class ESBZItemType : uint8
{
	None                                     = 0,
	Consumable                               = 1,
	Durable                                  = 2,
	ESBZItemType_MAX                         = 3,
};

// Enum Starbreeze.ESBZKeyPropertyMode
// NumValues: 0x0002
enum class ESBZKeyPropertyMode : uint8
{
	Default                                  = 0,
	MAX                                      = 1,
};

// Enum Starbreeze.ESBZStoreItemUIIdSource
// NumValues: 0x0003
enum class ESBZStoreItemUIIdSource : uint8
{
	AccelByte                                = 0,
	ExternalSystem                           = 1,
	ESBZStoreItemUIIdSource_MAX              = 2,
};

// Enum Starbreeze.ESBZStoreItemUICategoryType
// NumValues: 0x0003
enum class ESBZStoreItemUICategoryType : uint8
{
	Default                                  = 0,
	Custom                                   = 1,
	ESBZStoreItemUICategoryType_MAX          = 2,
};

// Enum Starbreeze.ESBZStoreItemDefaultUICategory
// NumValues: 0x0021
enum class ESBZStoreItemDefaultUICategory : uint8
{
	None                                     = 0,
	Armor                                    = 1,
	PayDayCredits                            = 2,
	Bundle                                   = 3,
	PremiumPresetWeapon                      = 4,
	PremiumMask                              = 5,
	PremiumSuit                              = 6,
	Weapon                                   = 7,
	PresetWeapon                             = 8,
	WeaponCharm                              = 9,
	WeaponPattern                            = 10,
	WeaponMaterial                           = 11,
	WeaponSticker                            = 12,
	WeaponSlot                               = 13,
	SprayPaintCans                           = 14,
	PreplanningAsset                         = 15,
	GloveInventorySlot                       = 16,
	Glove                                    = 17,
	Watch                                    = 18,
	Suit                                     = 19,
	SuitInventorySlot                        = 20,
	SuitBase                                 = 21,
	SuitMaterial                             = 22,
	SuitPattern                              = 23,
	MaskPreset                               = 24,
	MaskPreconfig                            = 25,
	MaskInventorySlot                        = 26,
	MaskMould                                = 27,
	MaskPattern                              = 28,
	MaskVFX                                  = 29,
	LoadoutSlot                              = 30,
	Coin                                     = 31,
	ESBZStoreItemDefaultUICategory_MAX       = 32,
};

// Enum Starbreeze.ESBZStoreItemPlatform
// NumValues: 0x0006
enum class ESBZStoreItemPlatform : uint8
{
	All                                      = 0,
	Steam                                    = 1,
	XBox                                     = 2,
	PlayStation                              = 3,
	Epic                                     = 4,
	ESBZStoreItemPlatform_MAX                = 5,
};

// Enum Starbreeze.ESBZItemNotLockedReason
// NumValues: 0x0003
enum class ESBZItemNotLockedReason : uint8
{
	OwningItem                               = 0,
	FreeDLCEventItem                         = 1,
	ESBZItemNotLockedReason_MAX              = 2,
};

// Enum Starbreeze.ESBZItemLockReason
// NumValues: 0x0005
enum class ESBZItemLockReason : uint8
{
	NotLocked                                = 0,
	InfamyLevel                              = 1,
	AlreadyPurchased                         = 2,
	NotOwningDLC                             = 3,
	ESBZItemLockReason_MAX                   = 4,
};

// Enum Starbreeze.ESBZNotificationType
// NumValues: 0x0005
enum class ESBZNotificationType : uint8
{
	NotificationError                        = 0,
	NotificationWarning                      = 1,
	NotificationNormal                       = 2,
	NotificationEmpty                        = 3,
	ESBZNotificationType_MAX                 = 4,
};

// Enum Starbreeze.ESBZLoadoutPlatforms
// NumValues: 0x0005
enum class ESBZLoadoutPlatforms : uint8
{
	Steam                                    = 0,
	PlayStation                              = 1,
	XBox                                     = 2,
	Epic                                     = 3,
	MAX                                      = 4,
};

// Enum Starbreeze.ESBZProjectileImpactType
// NumValues: 0x0004
enum class ESBZProjectileImpactType : uint8
{
	Light                                    = 0,
	Medium                                   = 1,
	Heavy                                    = 2,
	ESBZProjectileImpactType_MAX             = 3,
};

// Enum Starbreeze.ESBZReloadState
// NumValues: 0x000D
enum class ESBZReloadState : uint8
{
	None                                     = 0,
	StartCycle                               = 1,
	RemoveMagazine                           = 2,
	RemoveMagazineCycle                      = 3,
	InsertMagazine                           = 4,
	InsertMagazineCycle                      = 5,
	InsertAmmo                               = 6,
	InsertAmmoLast                           = 7,
	InsertAmmoEnd                            = 8,
	InsertAmmoCycle1                         = 9,
	InsertAmmoCycle2                         = 10,
	EndCycle                                 = 11,
	MAX                                      = 12,
};

// Enum Starbreeze.ESBZReplayEvent
// NumValues: 0x0002
enum class ESBZReplayEvent : uint8
{
	PointOfInterest                          = 0,
	ESBZReplayEvent_MAX                      = 1,
};

// Enum Starbreeze.ESBZReplaySpectatorView
// NumValues: 0x0004
enum class ESBZReplaySpectatorView : uint8
{
	FirstPersonView                          = 0,
	ThirdPersonView                          = 1,
	FreeCameraView                           = 2,
	ESBZReplaySpectatorView_MAX              = 3,
};

// Enum Starbreeze.ERepNodeRoutingStrategy
// NumValues: 0x0009
enum class ERepNodeRoutingStrategy : uint32
{
	NotRouted                                = 0,
	DependentActor                           = 1,
	RelevantAllConnections                   = 2,
	Spatialize_Static                        = 3,
	Spatialize_Dynamic                       = 4,
	Spatialize_Dormancy                      = 5,
	Spatialize_Dynamic_Frequency             = 6,
	PrototypingOnly                          = 7,
	ERepNodeRoutingStrategy_MAX              = 8,
};

// Enum Starbreeze.ESBZRequestFeedbackType
// NumValues: 0x0009
enum class ESBZRequestFeedbackType : uint8
{
	FriendRequest                            = 0,
	RemoveFriendRequest                      = 1,
	CancelFriendRequest                      = 2,
	AcceptFriendRequest                      = 3,
	RejectFriendRequest                      = 4,
	BlockPlayerRequest                       = 5,
	UnblockPlayerRequest                     = 6,
	ReportPlayerRequest                      = 7,
	ESBZRequestFeedbackType_MAX              = 8,
};

// Enum Starbreeze.ESBZConnectorDrawingState
// NumValues: 0x0006
enum class ESBZConnectorDrawingState : uint8
{
	Volumes                                  = 0,
	Doors                                    = 1,
	Components                               = 2,
	Navlinks                                 = 3,
	Other                                    = 4,
	ESBZConnectorDrawingState_MAX            = 5,
};

// Enum Starbreeze.ESBZRoomLabel
// NumValues: 0x0010
enum class ESBZRoomLabel : uint32
{
	OutsideHeistArea                         = 0,
	Lobby                                    = 1,
	Garage                                   = 2,
	Roof                                     = 3,
	Vault                                    = 4,
	RoomArea1                                = 5,
	RoomArea2                                = 6,
	RoomArea3                                = 7,
	RoomArea4                                = 8,
	RoomArea5                                = 9,
	RoomArea6                                = 10,
	RoomArea7                                = 11,
	RoomArea8                                = 12,
	RoomArea9                                = 13,
	RoomArea10                               = 14,
	MAX                                      = 15,
};

// Enum Starbreeze.ESBZRoomType
// NumValues: 0x0005
enum class ESBZRoomType : uint8
{
	None                                     = 0,
	Public                                   = 1,
	Private                                  = 2,
	Secure                                   = 3,
	MAX                                      = 4,
};

// Enum Starbreeze.ESBZRuntimeState
// NumValues: 0x0006
enum class ESBZRuntimeState : uint8
{
	None                                     = 0,
	HackerAced                               = 1,
	SecureLoop                               = 2,
	RoutedPing                               = 3,
	ScramblerBase                            = 4,
	ESBZRuntimeState_MAX                     = 5,
};

// Enum Starbreeze.ESBZSabotagePointState
// NumValues: 0x0004
enum class ESBZSabotagePointState : uint8
{
	Disabled                                 = 0,
	Enabled                                  = 1,
	Sabotaged                                = 2,
	ESBZSabotagePointState_MAX               = 3,
};

// Enum Starbreeze.ESBZSeasonalEventEffectType
// NumValues: 0x0007
enum class ESBZSeasonalEventEffectType : uint8
{
	None                                     = 0,
	GainAllBuffs                             = 1,
	FirstAid                                 = 2,
	ArmorBag                                 = 3,
	AmmoBag                                  = 4,
	Punishment                               = 5,
	ESBZSeasonalEventEffectType_MAX          = 6,
};

// Enum Starbreeze.ESBZCameraDetectionLevel
// NumValues: 0x0005
enum class ESBZCameraDetectionLevel : uint8
{
	None                                     = 0,
	Investigate                              = 1,
	Criminal                                 = 2,
	Alarm                                    = 3,
	ESBZCameraDetectionLevel_MAX             = 4,
};

// Enum Starbreeze.ESBZCameraSoundState
// NumValues: 0x0004
enum class ESBZCameraSoundState : uint8
{
	None                                     = 0,
	Suspiscious                              = 1,
	Alert                                    = 2,
	ESBZCameraSoundState_MAX                 = 3,
};

// Enum Starbreeze.ESBZCameraOptions
// NumValues: 0x0003
enum class ESBZCameraOptions : uint8
{
	Still                                    = 0,
	PingPong                                 = 1,
	ESBZCameraOptions_MAX                    = 2,
};

// Enum Starbreeze.ESBZCameraColorState
// NumValues: 0x0005
enum class ESBZCameraColorState : uint8
{
	None                                     = 0,
	AIControlled                             = 1,
	Hacked                                   = 2,
	Friendly                                 = 3,
	ESBZCameraColorState_MAX                 = 4,
};

// Enum Starbreeze.ESBZHeistType
// NumValues: 0x0003
enum class ESBZHeistType : uint8
{
	Hostable                                 = 0,
	Joinable                                 = 1,
	ESBZHeistType_MAX                        = 2,
};

// Enum Starbreeze.ESBZServerBrowserSessionsType
// NumValues: 0x0004
enum class ESBZServerBrowserSessionsType : uint8
{
	Mixed                                    = 0,
	APIOnly                                  = 1,
	FriendsOnly                              = 2,
	ESBZServerBrowserSessionsType_MAX        = 3,
};

// Enum Starbreeze.ESBZUpscalingMode
// NumValues: 0x0009
enum class ESBZUpscalingMode : uint8
{
	None                                     = 0,
	Auto                                     = 1,
	UltraQualityPlus                         = 2,
	UltraQuality                             = 3,
	Quality                                  = 4,
	Balanced                                 = 5,
	Performance                              = 6,
	UltraPerformance                         = 7,
	MAX                                      = 8,
};

// Enum Starbreeze.ESBZFrameInterpolator
// NumValues: 0x0005
enum class ESBZFrameInterpolator : uint8
{
	None                                     = 0,
	DLSSG                                    = 1,
	FFXFI                                    = 2,
	XeFG                                     = 3,
	MAX                                      = 4,
};

// Enum Starbreeze.ESBZLagReduction
// NumValues: 0x0004
enum class ESBZLagReduction : uint8
{
	None                                     = 0,
	Reflex                                   = 1,
	XeLL                                     = 2,
	MAX                                      = 3,
};

// Enum Starbreeze.ESBZLagReductionMode
// NumValues: 0x0004
enum class ESBZLagReductionMode : uint8
{
	Off                                      = 0,
	On                                       = 1,
	OnPlusBoost                              = 2,
	MAX                                      = 3,
};

// Enum Starbreeze.ESBZUpscaler
// NumValues: 0x0007
enum class ESBZUpscaler : uint8
{
	None                                     = 0,
	Unreal                                   = 1,
	NIS                                      = 2,
	DLSSSR                                   = 3,
	FSR3                                     = 4,
	XeSS                                     = 5,
	MAX                                      = 6,
};

// Enum Starbreeze.ESBZAntiAliasingMode
// NumValues: 0x0008
enum class ESBZAntiAliasingMode : uint8
{
	Off                                      = 0,
	FXAA                                     = 1,
	Performance                              = 2,
	Quality                                  = 3,
	DLAA                                     = 4,
	FSR3                                     = 5,
	XeSS                                     = 6,
	MAX                                      = 7,
};

// Enum Starbreeze.ESBZColorBlindMode
// NumValues: 0x0006
enum class ESBZColorBlindMode : uint64
{
	Off                                      = 0,
	Deuteranope                              = 1,
	Protanope                                = 2,
	Tritanope                                = 3,
	Invalid                                  = 18446744073709551615,
	ESBZColorBlindMode_MAX                   = 4,
};

// Enum Starbreeze.ESBZFramerateMode
// NumValues: 0x0004
enum class ESBZFramerateMode : uint32
{
	Performance                              = 0,
	Quality                                  = 1,
	Invalid                                  = 18446744073709551615,
	ESBZFramerateMode_MAX                    = 2,
};

// Enum Starbreeze.ESBZFramerateLimit
// NumValues: 0x000D
enum class ESBZFramerateLimit : uint64
{
	_30                                      = 30,
	_60                                      = 60,
	_120                                     = 120,
	_144                                     = 144,
	_160                                     = 160,
	_165                                     = 165,
	_180                                     = 180,
	_200                                     = 200,
	_240                                     = 240,
	_360                                     = 360,
	Unlimited                                = 0,
	Invalid                                  = 18446744073709551615,
	ESBZFramerateLimit_MAX                   = 361,
};

// Enum Starbreeze.ESBZWindowMode
// NumValues: 0x0005
enum class ESBZWindowMode : uint64
{
	FullScreen                               = 0,
	Borderless                               = 1,
	Windowed                                 = 2,
	Invalid                                  = 18446744073709551615,
	ESBZWindowMode_MAX                       = 3,
};

// Enum Starbreeze.ESBZMultipleChoiceState
// NumValues: 0x0006
enum class ESBZMultipleChoiceState : uint64
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	Ultra                                    = 3,
	Invalid                                  = 18446744073709551615,
	ESBZMultipleChoiceState_MAX              = 4,
};

// Enum Starbreeze.ESBZToggleState
// NumValues: 0x0004
enum class ESBZToggleState : uint64
{
	Off                                      = 0,
	On                                       = 1,
	Invalid                                  = 18446744073709551615,
	ESBZToggleState_MAX                      = 2,
};

// Enum Starbreeze.ESBZInputBindingType
// NumValues: 0x0003
enum class ESBZInputBindingType : uint8
{
	AxisBinding                              = 0,
	ActionBinding                            = 1,
	ESBZInputBindingType_MAX                 = 2,
};

// Enum Starbreeze.ESBZControlType
// NumValues: 0x0012
enum class ESBZControlType : uint8
{
	ActionClick                              = 0,
	Toggle                                   = 1,
	MultipleChoice                           = 2,
	FramerateChoice                          = 3,
	GamepadPresetChoice                      = 4,
	ResolutionChoice                         = 5,
	AntiAliasingModeChoice                   = 6,
	UpscalerChoice                           = 7,
	UpscalingModeChoice                      = 8,
	LagReductionChoice                       = 9,
	LagReductionModeChoice                   = 10,
	FrameInterpolatorChoice                  = 11,
	Slider                                   = 12,
	KeyboardInputBinding                     = 13,
	GamepadInputBinding                      = 14,
	StringControl                            = 15,
	ColorControl                             = 16,
	ESBZControlType_MAX                      = 17,
};

// Enum Starbreeze.ESBZShoutActionType
// NumValues: 0x0009
enum class ESBZShoutActionType : uint8
{
	None                                     = 0,
	Mark                                     = 1,
	HelpMe                                   = 2,
	HelpOther                                = 3,
	Callout                                  = 4,
	Comment                                  = 5,
	GetDown                                  = 6,
	CopSurrender                             = 7,
	ESBZShoutActionType_MAX                  = 8,
};

// Enum Starbreeze.ESBZAbilityBuffTypeAction
// NumValues: 0x0005
enum class ESBZAbilityBuffTypeAction : uint8
{
	Gain                                     = 0,
	GainRefresh                              = 1,
	Refresh                                  = 2,
	Consume                                  = 3,
	ESBZAbilityBuffTypeAction_MAX            = 4,
};

// Enum Starbreeze.ESBZSkillValueFormat
// NumValues: 0x0005
enum class ESBZSkillValueFormat : uint8
{
	None                                     = 0,
	Number                                   = 1,
	Percent                                  = 2,
	Meter                                    = 3,
	ESBZSkillValueFormat_MAX                 = 4,
};

// Enum Starbreeze.ESBZSkill
// NumValues: 0x0005
enum class ESBZSkill : uint8
{
	Base                                     = 0,
	AcedBase                                 = 1,
	Upgrade                                  = 2,
	Mastery                                  = 3,
	ESBZSkill_MAX                            = 4,
};

// Enum Starbreeze.ESBZSkillType
// NumValues: 0x0005
enum class ESBZSkillType : uint8
{
	None                                     = 0,
	BaseSkill                                = 1,
	Mastery                                  = 2,
	Upgrade                                  = 3,
	ESBZSkillType_MAX                        = 4,
};

// Enum Starbreeze.ESBZSkillState
// NumValues: 0x0006
enum class ESBZSkillState : uint8
{
	Unresearched                             = 0,
	Locked                                   = 1,
	Unequipped                               = 2,
	Equipped                                 = 3,
	Aced                                     = 4,
	ESBZSkillState_MAX                       = 5,
};

// Enum Starbreeze.ESocialFriendButtonType
// NumValues: 0x0008
enum class ESocialFriendButtonType : uint8
{
	AccelByteFriend                          = 0,
	PlatformFriend                           = 1,
	IncomingFriendRequest                    = 2,
	OutgoingFriendRequest                    = 3,
	UserSearchResult                         = 4,
	BlockedPlayers                           = 5,
	OfflineFriends                           = 6,
	ESocialFriendButtonType_MAX              = 7,
};

// Enum Starbreeze.ESBZPartyMemberButtonType
// NumValues: 0x0004
enum class ESBZPartyMemberButtonType : uint8
{
	PartyMember                              = 0,
	InviteIncoming                           = 1,
	InviteOutgoing                           = 2,
	ESBZPartyMemberButtonType_MAX            = 3,
};

// Enum Starbreeze.ESBZSpawnSignificance
// NumValues: 0x0004
enum class ESBZSpawnSignificance : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	ESBZSpawnSignificance_MAX                = 3,
};

// Enum Starbreeze.ESBZSplineType
// NumValues: 0x0005
enum class ESBZSplineType : uint8
{
	Ascending                                = 0,
	Descending                               = 1,
	Forward                                  = 2,
	Reverse                                  = 3,
	ESBZSplineType_MAX                       = 4,
};

// Enum Starbreeze.ESBZGameDataState
// NumValues: 0x0005
enum class ESBZGameDataState : uint8
{
	NotLoggedIn                              = 0,
	NotLoaded                                = 1,
	Loaded                                   = 2,
	ProgressNotLoaded                        = 3,
	ESBZGameDataState_MAX                    = 4,
};

// Enum Starbreeze.ESBZSuitBaseCPDBits
// NumValues: 0x000A
enum class ESBZSuitBaseCPDBits : uint8
{
	NONE                                     = 0,
	BIT0                                     = 1,
	BIT1                                     = 2,
	BIT2                                     = 4,
	BIT3                                     = 8,
	BIT4                                     = 16,
	BIT5                                     = 32,
	BIT6                                     = 64,
	BIT7                                     = 128,
	ESBZSuitBaseCPDBits_MAX                  = 129,
};

// Enum Starbreeze.ESBZSuitPart
// NumValues: 0x0004
enum class ESBZSuitPart : uint8
{
	SUIT_PART_LOWER                          = 0,
	SUIT_PART_UPPER                          = 1,
	SUIT_PART_OUTER                          = 2,
	MAX                                      = 3,
};

// Enum Starbreeze.ESBZImpactConfigType
// NumValues: 0x0014
enum class ESBZImpactConfigType : uint8
{
	Default                                  = 0,
	Projectile                               = 1,
	ThrowableProjectile                      = 2,
	ThrowableProjectileBounce                = 3,
	Throwable                                = 4,
	Melee                                    = 5,
	Explosion                                = 6,
	FootStep                                 = 7,
	Sliding                                  = 8,
	Mantling                                 = 9,
	StepUp                                   = 10,
	ObjectImpact                             = 11,
	ObjectRolling                            = 12,
	DebrisImpact                             = 13,
	DebrisRolling                            = 14,
	BagItem                                  = 15,
	ThePunch                                 = 16,
	Last                                     = 17,
	First                                    = 0,
	ESBZImpactConfigType_MAX                 = 18,
};

// Enum Starbreeze.ESBZAISoundSurfaceTypes
// NumValues: 0x0005
enum class ESBZAISoundSurfaceTypes : uint8
{
	Dampened                                 = 0,
	Hard                                     = 1,
	Loud                                     = 2,
	Trap                                     = 3,
	ESBZAISoundSurfaceTypes_MAX              = 4,
};

// Enum Starbreeze.ESBZThermiteBurnState
// NumValues: 0x0007
enum class ESBZThermiteBurnState : uint8
{
	Inactive                                 = 0,
	Unlit                                    = 1,
	Completed                                = 2,
	Burning                                  = 3,
	CriticalBurning                          = 4,
	FlashOver                                = 5,
	ESBZThermiteBurnState_MAX                = 6,
};

// Enum Starbreeze.ESBZThrowableState
// NumValues: 0x000A
enum class ESBZThrowableState : uint8
{
	None                                     = 0,
	Spawned                                  = 1,
	Ready                                    = 2,
	AttachedForThrow                         = 3,
	ThrownStillAttached                      = 4,
	DetachedForThrow                         = 5,
	Thrown                                   = 6,
	Canceled                                 = 7,
	Dropped                                  = 8,
	ESBZThrowableState_MAX                   = 9,
};

// Enum Starbreeze.ESBZThrowableType
// NumValues: 0x0007
enum class ESBZThrowableType : uint8
{
	None                                     = 0,
	Flash                                    = 1,
	Gas                                      = 2,
	Frag                                     = 3,
	Knife                                    = 4,
	Shock                                    = 5,
	MAX                                      = 6,
};

// Enum Starbreeze.ESBZToolState
// NumValues: 0x0007
enum class ESBZToolState : uint8
{
	Ready                                    = 0,
	Activated                                = 1,
	ActivatedUsing                           = 2,
	ActivatedIdle                            = 3,
	Canceled                                 = 4,
	Destroyed                                = 5,
	ESBZToolState_MAX                        = 6,
};

// Enum Starbreeze.ESBZToolSnapType
// NumValues: 0x0002
enum class ESBZToolSnapType : uint8
{
	Door                                     = 0,
	ESBZToolSnapType_MAX                     = 1,
};

// Enum Starbreeze.ESBZTrafficNodeExec
// NumValues: 0x0004
enum class ESBZTrafficNodeExec : uint8
{
	Completed                                = 0,
	Failed                                   = 1,
	Waiting                                  = 2,
	ESBZTrafficNodeExec_MAX                  = 3,
};

// Enum Starbreeze.ESBZWave
// NumValues: 0x0004
enum class ESBZWave : uint8
{
	Wave2                                    = 0,
	Wave3                                    = 1,
	Wave4                                    = 2,
	MAX                                      = 3,
};

// Enum Starbreeze.ESBZTrafficVehicleControlType
// NumValues: 0x0008
enum class ESBZTrafficVehicleControlType : uint8
{
	StopAtDistance                           = 0,
	Start                                    = 1,
	SetCruisingSpeed                         = 2,
	SetDeceleration                          = 3,
	SetAcceleration                          = 4,
	SoundHorn                                = 5,
	None                                     = 6,
	ESBZTrafficVehicleControlType_MAX        = 7,
};

// Enum Starbreeze.ESBZTrafficLightStatus
// NumValues: 0x0007
enum class ESBZTrafficLightStatus : uint8
{
	FullOff                                  = 0,
	Red                                      = 1,
	Orange                                   = 2,
	Yellow                                   = 3,
	Green                                    = 4,
	FullLights                               = 5,
	MAX                                      = 6,
};

// Enum Starbreeze.ESBZTrafficVehicleType
// NumValues: 0x0007
enum class ESBZTrafficVehicleType : uint8
{
	FirstResponder                           = 0,
	SwatVan                                  = 1,
	EscapeVan                                = 2,
	Civilian                                 = 3,
	Aerial                                   = 4,
	FBIVan                                   = 5,
	ESBZTrafficVehicleType_MAX               = 6,
};

// Enum Starbreeze.ESBZTrafficSplineType
// NumValues: 0x0004
enum class ESBZTrafficSplineType : uint8
{
	VehicleSpawner                           = 0,
	ParkingSpot                              = 1,
	EndPoint                                 = 2,
	ESBZTrafficSplineType_MAX                = 3,
};

// Enum Starbreeze.ESBZTrafficNodeType
// NumValues: 0x0003
enum class ESBZTrafficNodeType : uint8
{
	Spawner                                  = 0,
	Destination                              = 1,
	ESBZTrafficNodeType_MAX                  = 2,
};

// Enum Starbreeze.ESBZInputState
// NumValues: 0x0004
enum class ESBZInputState : uint8
{
	Game                                     = 0,
	UI                                       = 1,
	GameAndUI                                = 2,
	ESBZInputState_MAX                       = 3,
};

// Enum Starbreeze.ESBZAppearanceType
// NumValues: 0x0007
enum class ESBZAppearanceType : uint8
{
	NoType                                   = 0,
	Character                                = 1,
	Mask                                     = 2,
	Suit                                     = 3,
	Gloves                                   = 4,
	Watches                                  = 5,
	ESBZAppearanceType_MAX                   = 6,
};

// Enum Starbreeze.ESBZWidgetZOrdering
// NumValues: 0x0007
enum class ESBZWidgetZOrdering : uint8
{
	DefaultBackground                        = 0,
	Default                                  = 1,
	DefaultForeGround                        = 2,
	OverlayBackground                        = 3,
	Overlay                                  = 4,
	OverlayForeGround                        = 5,
	ESBZWidgetZOrdering_MAX                  = 6,
};

// Enum Starbreeze.ESBZUIWeaponStat
// NumValues: 0x0007
enum class ESBZUIWeaponStat : uint8
{
	Damage                                   = 0,
	Recoil                                   = 1,
	Stability                                = 2,
	Accuracy                                 = 3,
	Handling                                 = 4,
	FireRate                                 = 5,
	MAX                                      = 6,
};

// Enum Starbreeze.ESBZUserStatus
// NumValues: 0x0007
enum class ESBZUserStatus : uint8
{
	InCrew                                   = 0,
	InHeist                                  = 1,
	InLobby                                  = 2,
	Matchmaking                              = 3,
	Offline                                  = 4,
	Online                                   = 5,
	ESBZUserStatus_MAX                       = 6,
};

// Enum Starbreeze.ESBZOnlinePresenceState
// NumValues: 0x0008
enum class ESBZOnlinePresenceState : uint8
{
	Unknown                                  = 0,
	Online                                   = 1,
	Offline                                  = 2,
	Away                                     = 3,
	ExtendedAway                             = 4,
	DoNotDisturb                             = 5,
	Chat                                     = 6,
	ESBZOnlinePresenceState_MAX              = 7,
};

// Enum Starbreeze.ESBZTrackedVariableType
// NumValues: 0x0003
enum class ESBZTrackedVariableType : uint8
{
	Property                                 = 0,
	Transform                                = 1,
	ESBZTrackedVariableType_MAX              = 2,
};

// Enum Starbreeze.ESBZStageMiscDebugDataType
// NumValues: 0x000B
enum class ESBZStageMiscDebugDataType : uint16
{
	Name                                     = 0,
	String                                   = 1,
	Bool                                     = 2,
	Int32                                    = 3,
	Float                                    = 4,
	Transform                                = 5,
	Line                                     = 6,
	Vector                                   = 7,
	Sphere                                   = 8,
	Capsule                                  = 9,
	ESBZStageMiscDebugDataType_MAX           = 10,
};

// Enum Starbreeze.ESBZVehicleLightCPD
// NumValues: 0x0008
enum class ESBZVehicleLightCPD : uint8
{
	A                                        = 6,
	B                                        = 5,
	C                                        = 4,
	D                                        = 3,
	E                                        = 2,
	F                                        = 1,
	G                                        = 0,
	ESBZVehicleLightCPD_MAX                  = 7,
};

// Enum Starbreeze.ESBZVehicleLightType
// NumValues: 0x0008
enum class ESBZVehicleLightType : uint8
{
	Headlights                               = 0,
	TailLights                               = 1,
	FogLights                                = 2,
	BrakeLights                              = 3,
	ReverseLights                            = 4,
	TurnLeft                                 = 5,
	TurnRight                                = 6,
	ESBZVehicleLightType_MAX                 = 7,
};

// Enum Starbreeze.ESBZVehicleDoorType
// NumValues: 0x000A
enum class ESBZVehicleDoorType : uint8
{
	Invalid                                  = 0,
	SideFrontLeft                            = 1,
	SideFrontRight                           = 2,
	SideBackLeft                             = 3,
	SideBackRight                            = 4,
	TopFront                                 = 5,
	TopBack                                  = 6,
	BackLeft                                 = 7,
	BackRight                                = 8,
	ESBZVehicleDoorType_MAX                  = 9,
};

// Enum Starbreeze.ESBZVehicleDoorState
// NumValues: 0x0003
enum class ESBZVehicleDoorState : uint8
{
	Opened                                   = 0,
	Closed                                   = 1,
	ESBZVehicleDoorState_MAX                 = 2,
};

// Enum Starbreeze.ESBZVolumeType
// NumValues: 0x000A
enum class ESBZVolumeType : uint8
{
	Master                                   = 0,
	Music                                    = 1,
	VO                                       = 2,
	OperatorVO                               = 3,
	SFX                                      = 4,
	HUD                                      = 5,
	VOIP                                     = 6,
	VOIPMic                                  = 7,
	Cinematic                                = 8,
	ESBZVolumeType_MAX                       = 9,
};

// Enum Starbreeze.ESBZVotingAnswer
// NumValues: 0x0003
enum class ESBZVotingAnswer : uint8
{
	Negative                                 = 0,
	Positive                                 = 1,
	ESBZVotingAnswer_MAX                     = 2,
};

// Enum Starbreeze.ESBZVotingType
// NumValues: 0x0004
enum class ESBZVotingType : uint8
{
	RestartLevel                             = 0,
	KickPlayer                               = 1,
	Debug                                    = 2,
	ESBZVotingType_MAX                       = 3,
};

// Enum Starbreeze.ESBZVotingError
// NumValues: 0x0003
enum class ESBZVotingError : uint8
{
	NotEnoughPlayers                         = 0,
	VotingInProgress                         = 1,
	ESBZVotingError_MAX                      = 2,
};

// Enum Starbreeze.ESBZWeaponAmmoVisibilityType
// NumValues: 0x0004
enum class ESBZWeaponAmmoVisibilityType : uint8
{
	Never                                    = 0,
	Reload                                   = 1,
	Always                                   = 2,
	ESBZWeaponAmmoVisibilityType_MAX         = 3,
};

// Enum Starbreeze.ESBZWeaponAttribute
// NumValues: 0x0028
enum class ESBZWeaponAttribute : uint8
{
	NONE                                     = 0,
	VerticalRecoil                           = 1,
	HorizontalRecoil                         = 2,
	InitialRecoil                            = 3,
	OverallReloadPlayRate                    = 4,
	EquipPlayRate                            = 5,
	UnequipPlayRate                          = 6,
	SprintExitPlayRate                       = 7,
	DamageDistance                           = 8,
	CriticalDamageMultiplierDistance         = 9,
	TargetingTransitionTime                  = 10,
	ArmorPenetration                         = 11,
	HipfireSpread                            = 12,
	TargetingSpread                          = 13,
	SpreadIncrement                          = 14,
	VerticalSpreadRadius                     = 15,
	HorizontalSpreadRadius                   = 16,
	VerticalGunkick                          = 17,
	HorizontalGunkick                        = 18,
	ScreenShakeAmplitude                     = 19,
	OverallPelletDeviation                   = 20,
	ViewKickRecoverySpeed                    = 21,
	ViewKickRecoveryDelay                    = 22,
	GunKickBackDistance                      = 23,
	HurtBuildup                              = 24,
	CriticalHurtBuildup                      = 25,
	HurtBuildupMultiplier                    = 26,
	EndCycleReloadPlayRate                   = 27,
	OverallDamage                            = 28,
	CriticalDamage                           = 29,
	LoadoutWeight                            = 30,
	OverallRecoil                            = 31,
	OverallSpread                            = 32,
	OverallGunkick                           = 33,
	OverallSwapSpeed                         = 34,
	OverallSpreadRadius                      = 35,
	OverallHurtBuildup                       = 36,
	MAX                                      = 37,
	ATTRIBUTE_START                          = 1,
	PARENT_START                             = 31,
};

// Enum Starbreeze.ESBZMuzzleSuppressor
// NumValues: 0x0006
enum class ESBZMuzzleSuppressor : uint8
{
	None                                     = 0,
	Small                                    = 1,
	Medium                                   = 2,
	Large                                    = 3,
	MAX                                      = 4,
	Last                                     = 3,
};

// Enum Starbreeze.ESBZWeaponPartLockReason
// NumValues: 0x0003
enum class ESBZWeaponPartLockReason : uint8
{
	None                                     = 0,
	LockedByDLC                              = 1,
	ESBZWeaponPartLockReason_MAX             = 2,
};

// Enum Starbreeze.ESBZWeaponPartApplyStatus
// NumValues: 0x0005
enum class ESBZWeaponPartApplyStatus : uint8
{
	NotAllowed                               = 0,
	CanBeAppliedForCost                      = 1,
	FeeAlreadyPayed                          = 2,
	CanAlwaysBeAppliedAtNoCost               = 3,
	ESBZWeaponPartApplyStatus_MAX            = 4,
};

// Enum Starbreeze.ESBZWeaponSpreadRecoveryMode
// NumValues: 0x0003
enum class ESBZWeaponSpreadRecoveryMode : uint8
{
	ResetTime                                = 0,
	DecayRate                                = 1,
	ESBZWeaponSpreadRecoveryMode_MAX         = 2,
};

// Enum Starbreeze.ESBZWinchState
// NumValues: 0x0005
enum class ESBZWinchState : uint8
{
	None                                     = 0,
	HookAvailable                            = 1,
	HookGrabbed                              = 2,
	HookAttached                             = 3,
	ESBZWinchState_MAX                       = 4,
};

// Enum Starbreeze.ESBZWindVolumeType
// NumValues: 0x0003
enum class ESBZWindVolumeType : uint8
{
	Box                                      = 0,
	Sphere                                   = 1,
	ESBZWindVolumeType_MAX                   = 2,
};

// Enum Starbreeze.ESBZWindEmitterType
// NumValues: 0x0003
enum class ESBZWindEmitterType : uint8
{
	Directionnal                             = 0,
	Point                                    = 1,
	ESBZWindEmitterType_MAX                  = 2,
};

// Enum Starbreeze.ESBZZiplineType
// NumValues: 0x0003
enum class ESBZZiplineType : uint8
{
	Horizontal                               = 0,
	Vertical                                 = 1,
	ESBZZiplineType_MAX                      = 2,
};

// ScriptStruct Starbreeze.SBZCDPTableRow
// 0x0058 (0x0060 - 0x0008)
struct FSBZCDPTableRow final : public FTableRowBase
{
public:
	int32                                         CDP_id;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Tooltip;                                           // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	ESBZCDPType                                   Variable_type;                                     // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FloatValue;                                        // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntValue;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SelectValue;                                       // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorValue;                                        // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BoolValue;                                         // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BitPosition;                                       // 0x0049(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         CollisionNames;                                    // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZCDPTableRow) == 0x000008, "Wrong alignment on FSBZCDPTableRow");
static_assert(sizeof(FSBZCDPTableRow) == 0x000060, "Wrong size on FSBZCDPTableRow");
static_assert(offsetof(FSBZCDPTableRow, CDP_id) == 0x000008, "Member 'FSBZCDPTableRow::CDP_id' has a wrong offset!");
static_assert(offsetof(FSBZCDPTableRow, Tooltip) == 0x000010, "Member 'FSBZCDPTableRow::Tooltip' has a wrong offset!");
static_assert(offsetof(FSBZCDPTableRow, Variable_type) == 0x000028, "Member 'FSBZCDPTableRow::Variable_type' has a wrong offset!");
static_assert(offsetof(FSBZCDPTableRow, FloatValue) == 0x00002C, "Member 'FSBZCDPTableRow::FloatValue' has a wrong offset!");
static_assert(offsetof(FSBZCDPTableRow, IntValue) == 0x000030, "Member 'FSBZCDPTableRow::IntValue' has a wrong offset!");
static_assert(offsetof(FSBZCDPTableRow, SelectValue) == 0x000034, "Member 'FSBZCDPTableRow::SelectValue' has a wrong offset!");
static_assert(offsetof(FSBZCDPTableRow, ColorValue) == 0x000038, "Member 'FSBZCDPTableRow::ColorValue' has a wrong offset!");
static_assert(offsetof(FSBZCDPTableRow, BoolValue) == 0x000048, "Member 'FSBZCDPTableRow::BoolValue' has a wrong offset!");
static_assert(offsetof(FSBZCDPTableRow, BitPosition) == 0x000049, "Member 'FSBZCDPTableRow::BitPosition' has a wrong offset!");
static_assert(offsetof(FSBZCDPTableRow, CollisionNames) == 0x000050, "Member 'FSBZCDPTableRow::CollisionNames' has a wrong offset!");

// ScriptStruct Starbreeze.SBZEquippablePartConfigGroup
// 0x0010 (0x0010 - 0x0000)
struct FSBZEquippablePartConfigGroup final
{
public:
	class USBZEquippablePartDataAsset*            Part;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZEquippablePartConfig*               Config;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZEquippablePartConfigGroup) == 0x000008, "Wrong alignment on FSBZEquippablePartConfigGroup");
static_assert(sizeof(FSBZEquippablePartConfigGroup) == 0x000010, "Wrong size on FSBZEquippablePartConfigGroup");
static_assert(offsetof(FSBZEquippablePartConfigGroup, Part) == 0x000000, "Member 'FSBZEquippablePartConfigGroup::Part' has a wrong offset!");
static_assert(offsetof(FSBZEquippablePartConfigGroup, Config) == 0x000008, "Member 'FSBZEquippablePartConfigGroup::Config' has a wrong offset!");

// ScriptStruct Starbreeze.SBZEquippableConfig
// 0x0070 (0x0070 - 0x0000)
struct FSBZEquippableConfig final
{
public:
	class USBZEquippableData*                     EquippableData;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZEquippableData*                     OriginalEquippableData;                            // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USBZEquippablePartDataAsset*>    ModDataArray;                                      // 0x0010(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	TMap<class USBZModularPartSlotBase*, struct FSBZEquippablePartConfigGroup> ModDataMap;           // 0x0020(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZEquippableConfig) == 0x000008, "Wrong alignment on FSBZEquippableConfig");
static_assert(sizeof(FSBZEquippableConfig) == 0x000070, "Wrong size on FSBZEquippableConfig");
static_assert(offsetof(FSBZEquippableConfig, EquippableData) == 0x000000, "Member 'FSBZEquippableConfig::EquippableData' has a wrong offset!");
static_assert(offsetof(FSBZEquippableConfig, OriginalEquippableData) == 0x000008, "Member 'FSBZEquippableConfig::OriginalEquippableData' has a wrong offset!");
static_assert(offsetof(FSBZEquippableConfig, ModDataArray) == 0x000010, "Member 'FSBZEquippableConfig::ModDataArray' has a wrong offset!");
static_assert(offsetof(FSBZEquippableConfig, ModDataMap) == 0x000020, "Member 'FSBZEquippableConfig::ModDataMap' has a wrong offset!");

// ScriptStruct Starbreeze.SBZOverskillLoadoutConfig
// 0x0010 (0x0010 - 0x0000)
struct FSBZOverskillLoadoutConfig final
{
public:
	class USBZOverskillLoadoutData*               Data;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZOverskillLoadoutData*               OriginalData;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZOverskillLoadoutConfig) == 0x000008, "Wrong alignment on FSBZOverskillLoadoutConfig");
static_assert(sizeof(FSBZOverskillLoadoutConfig) == 0x000010, "Wrong size on FSBZOverskillLoadoutConfig");
static_assert(offsetof(FSBZOverskillLoadoutConfig, Data) == 0x000000, "Member 'FSBZOverskillLoadoutConfig::Data' has a wrong offset!");
static_assert(offsetof(FSBZOverskillLoadoutConfig, OriginalData) == 0x000008, "Member 'FSBZOverskillLoadoutConfig::OriginalData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZArmorConfig
// 0x0020 (0x0020 - 0x0000)
struct FSBZArmorConfig final
{
public:
	class USBZArmorData*                          Data;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZArmorData*                          OriginalData;                                      // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<ESBZArmorChunkType>                    ChunkTypeArray;                                    // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZArmorConfig) == 0x000008, "Wrong alignment on FSBZArmorConfig");
static_assert(sizeof(FSBZArmorConfig) == 0x000020, "Wrong size on FSBZArmorConfig");
static_assert(offsetof(FSBZArmorConfig, Data) == 0x000000, "Member 'FSBZArmorConfig::Data' has a wrong offset!");
static_assert(offsetof(FSBZArmorConfig, OriginalData) == 0x000008, "Member 'FSBZArmorConfig::OriginalData' has a wrong offset!");
static_assert(offsetof(FSBZArmorConfig, ChunkTypeArray) == 0x000010, "Member 'FSBZArmorConfig::ChunkTypeArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZThrowableConfig
// 0x0010 (0x0010 - 0x0000)
struct FSBZThrowableConfig final
{
public:
	class USBZThrowableData*                      Data;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZThrowableData*                      OriginalData;                                      // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZThrowableConfig) == 0x000008, "Wrong alignment on FSBZThrowableConfig");
static_assert(sizeof(FSBZThrowableConfig) == 0x000010, "Wrong size on FSBZThrowableConfig");
static_assert(offsetof(FSBZThrowableConfig, Data) == 0x000000, "Member 'FSBZThrowableConfig::Data' has a wrong offset!");
static_assert(offsetof(FSBZThrowableConfig, OriginalData) == 0x000008, "Member 'FSBZThrowableConfig::OriginalData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZOverskillProgressData
// 0x0010 (0x0010 - 0x0000)
struct FSBZOverskillProgressData final
{
public:
	class FName                                   Name;                                              // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZOverskillProgressData) == 0x000004, "Wrong alignment on FSBZOverskillProgressData");
static_assert(sizeof(FSBZOverskillProgressData) == 0x000010, "Wrong size on FSBZOverskillProgressData");
static_assert(offsetof(FSBZOverskillProgressData, Name) == 0x000000, "Member 'FSBZOverskillProgressData::Name' has a wrong offset!");
static_assert(offsetof(FSBZOverskillProgressData, Value) == 0x00000C, "Member 'FSBZOverskillProgressData::Value' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMaskPartConfigGroup
// 0x0010 (0x0010 - 0x0000)
struct FSBZMaskPartConfigGroup final
{
public:
	class USBZModularPartDataAsset*               Part;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZMaskPartConfig*                     Config;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZMaskPartConfigGroup) == 0x000008, "Wrong alignment on FSBZMaskPartConfigGroup");
static_assert(sizeof(FSBZMaskPartConfigGroup) == 0x000010, "Wrong size on FSBZMaskPartConfigGroup");
static_assert(offsetof(FSBZMaskPartConfigGroup, Part) == 0x000000, "Member 'FSBZMaskPartConfigGroup::Part' has a wrong offset!");
static_assert(offsetof(FSBZMaskPartConfigGroup, Config) == 0x000008, "Member 'FSBZMaskPartConfigGroup::Config' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMaskConfig
// 0x0070 (0x0070 - 0x0000)
struct FSBZMaskConfig final
{
public:
	class USBZMaskData*                           MaskData;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZMaskData*                           OriginalMaskData;                                  // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USBZModularPartDataAsset*>       ModDataArray;                                      // 0x0010(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	TMap<class USBZModularPartSlotBase*, struct FSBZMaskPartConfigGroup> ModDataMap;                 // 0x0020(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZMaskConfig) == 0x000008, "Wrong alignment on FSBZMaskConfig");
static_assert(sizeof(FSBZMaskConfig) == 0x000070, "Wrong size on FSBZMaskConfig");
static_assert(offsetof(FSBZMaskConfig, MaskData) == 0x000000, "Member 'FSBZMaskConfig::MaskData' has a wrong offset!");
static_assert(offsetof(FSBZMaskConfig, OriginalMaskData) == 0x000008, "Member 'FSBZMaskConfig::OriginalMaskData' has a wrong offset!");
static_assert(offsetof(FSBZMaskConfig, ModDataArray) == 0x000010, "Member 'FSBZMaskConfig::ModDataArray' has a wrong offset!");
static_assert(offsetof(FSBZMaskConfig, ModDataMap) == 0x000020, "Member 'FSBZMaskConfig::ModDataMap' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSuitPartConfigGroup
// 0x0010 (0x0010 - 0x0000)
struct FSBZSuitPartConfigGroup final
{
public:
	class USBZModularPartDataAsset*               Part;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZSuitPartConfig*                     Config;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSuitPartConfigGroup) == 0x000008, "Wrong alignment on FSBZSuitPartConfigGroup");
static_assert(sizeof(FSBZSuitPartConfigGroup) == 0x000010, "Wrong size on FSBZSuitPartConfigGroup");
static_assert(offsetof(FSBZSuitPartConfigGroup, Part) == 0x000000, "Member 'FSBZSuitPartConfigGroup::Part' has a wrong offset!");
static_assert(offsetof(FSBZSuitPartConfigGroup, Config) == 0x000008, "Member 'FSBZSuitPartConfigGroup::Config' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSuitConfigModDataMap
// 0x0050 (0x0050 - 0x0000)
struct FSBZSuitConfigModDataMap final
{
public:
	TMap<class USBZModularPartSlotBase*, struct FSBZSuitPartConfigGroup> ModDataMap;                 // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSuitConfigModDataMap) == 0x000008, "Wrong alignment on FSBZSuitConfigModDataMap");
static_assert(sizeof(FSBZSuitConfigModDataMap) == 0x000050, "Wrong size on FSBZSuitConfigModDataMap");
static_assert(offsetof(FSBZSuitConfigModDataMap, ModDataMap) == 0x000000, "Member 'FSBZSuitConfigModDataMap::ModDataMap' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSuitConfig
// 0x0028 (0x0028 - 0x0000)
struct FSBZSuitConfig final
{
public:
	class USBZSuitData*                           SuitData;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZSuitData*                           OriginalSuitData;                                  // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZSuitBaseData*                       SuitBaseData;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSBZSuitConfigModDataMap>       ModDataMapArray;                                   // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSuitConfig) == 0x000008, "Wrong alignment on FSBZSuitConfig");
static_assert(sizeof(FSBZSuitConfig) == 0x000028, "Wrong size on FSBZSuitConfig");
static_assert(offsetof(FSBZSuitConfig, SuitData) == 0x000000, "Member 'FSBZSuitConfig::SuitData' has a wrong offset!");
static_assert(offsetof(FSBZSuitConfig, OriginalSuitData) == 0x000008, "Member 'FSBZSuitConfig::OriginalSuitData' has a wrong offset!");
static_assert(offsetof(FSBZSuitConfig, SuitBaseData) == 0x000010, "Member 'FSBZSuitConfig::SuitBaseData' has a wrong offset!");
static_assert(offsetof(FSBZSuitConfig, ModDataMapArray) == 0x000018, "Member 'FSBZSuitConfig::ModDataMapArray' has a wrong offset!");

// ScriptStruct Starbreeze.PD3ModifiableLoadoutData
// 0x0010 (0x0010 - 0x0000)
struct FPD3ModifiableLoadoutData final
{
public:
	class USBZToolData*                           ToolData;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZToolData*                           ModifiedToolData;                                  // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPD3ModifiableLoadoutData) == 0x000008, "Wrong alignment on FPD3ModifiableLoadoutData");
static_assert(sizeof(FPD3ModifiableLoadoutData) == 0x000010, "Wrong size on FPD3ModifiableLoadoutData");
static_assert(offsetof(FPD3ModifiableLoadoutData, ToolData) == 0x000000, "Member 'FPD3ModifiableLoadoutData::ToolData' has a wrong offset!");
static_assert(offsetof(FPD3ModifiableLoadoutData, ModifiedToolData) == 0x000008, "Member 'FPD3ModifiableLoadoutData::ModifiedToolData' has a wrong offset!");

// ScriptStruct Starbreeze.PD3PlayerLoadout
// 0x01C0 (0x01C0 - 0x0000)
struct FPD3PlayerLoadout final
{
public:
	TArray<class USBZPlayerCharacterData*>        PreferredCharacterDataArray;                       // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSBZEquippableConfig>           EquippableConfigArray;                             // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FSBZEquippableConfig                   OverkillWeaponConfig;                              // 0x0020(0x0070)(Edit, NativeAccessSpecifierPrivate)
	struct FSBZOverskillLoadoutConfig             OverskillLoadoutConfig;                            // 0x0090(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	TArray<struct FSBZThrowableConfig>            ThrowableConfigArray;                              // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class USBZGloveData*                          GloveData;                                         // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSBZMaskConfig                         MaskConfig;                                        // 0x00B8(0x0070)(Edit, NativeAccessSpecifierPrivate)
	struct FSBZSuitConfig                         SuitConfig;                                        // 0x0128(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FSBZArmorConfig                        ArmorConfig;                                       // 0x0150(0x0020)(Edit, NativeAccessSpecifierPrivate)
	TArray<class USBZSkillData*>                  SkillArray;                                        // 0x0170(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class USBZSkillData*>                  RemovedOverskillSkillArray;                        // 0x0180(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSBZOverskillProgressData>      OverskillProgressDataArray;                        // 0x0190(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FPD3ModifiableLoadoutData>      ModifiableLoadoutDataArray;                        // 0x01A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	int8                                          PendingValidationCount;                            // 0x01B0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsSkillArrayValidated;                            // 0x01B1(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsOverskillArrayValidated;                        // 0x01B2(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B3[0x5];                                      // 0x01B3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class USBZPlayerAbilityData*                  AbilityData;                                       // 0x01B8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FPD3PlayerLoadout) == 0x000008, "Wrong alignment on FPD3PlayerLoadout");
static_assert(sizeof(FPD3PlayerLoadout) == 0x0001C0, "Wrong size on FPD3PlayerLoadout");
static_assert(offsetof(FPD3PlayerLoadout, PreferredCharacterDataArray) == 0x000000, "Member 'FPD3PlayerLoadout::PreferredCharacterDataArray' has a wrong offset!");
static_assert(offsetof(FPD3PlayerLoadout, EquippableConfigArray) == 0x000010, "Member 'FPD3PlayerLoadout::EquippableConfigArray' has a wrong offset!");
static_assert(offsetof(FPD3PlayerLoadout, OverkillWeaponConfig) == 0x000020, "Member 'FPD3PlayerLoadout::OverkillWeaponConfig' has a wrong offset!");
static_assert(offsetof(FPD3PlayerLoadout, OverskillLoadoutConfig) == 0x000090, "Member 'FPD3PlayerLoadout::OverskillLoadoutConfig' has a wrong offset!");
static_assert(offsetof(FPD3PlayerLoadout, ThrowableConfigArray) == 0x0000A0, "Member 'FPD3PlayerLoadout::ThrowableConfigArray' has a wrong offset!");
static_assert(offsetof(FPD3PlayerLoadout, GloveData) == 0x0000B0, "Member 'FPD3PlayerLoadout::GloveData' has a wrong offset!");
static_assert(offsetof(FPD3PlayerLoadout, MaskConfig) == 0x0000B8, "Member 'FPD3PlayerLoadout::MaskConfig' has a wrong offset!");
static_assert(offsetof(FPD3PlayerLoadout, SuitConfig) == 0x000128, "Member 'FPD3PlayerLoadout::SuitConfig' has a wrong offset!");
static_assert(offsetof(FPD3PlayerLoadout, ArmorConfig) == 0x000150, "Member 'FPD3PlayerLoadout::ArmorConfig' has a wrong offset!");
static_assert(offsetof(FPD3PlayerLoadout, SkillArray) == 0x000170, "Member 'FPD3PlayerLoadout::SkillArray' has a wrong offset!");
static_assert(offsetof(FPD3PlayerLoadout, RemovedOverskillSkillArray) == 0x000180, "Member 'FPD3PlayerLoadout::RemovedOverskillSkillArray' has a wrong offset!");
static_assert(offsetof(FPD3PlayerLoadout, OverskillProgressDataArray) == 0x000190, "Member 'FPD3PlayerLoadout::OverskillProgressDataArray' has a wrong offset!");
static_assert(offsetof(FPD3PlayerLoadout, ModifiableLoadoutDataArray) == 0x0001A0, "Member 'FPD3PlayerLoadout::ModifiableLoadoutDataArray' has a wrong offset!");
static_assert(offsetof(FPD3PlayerLoadout, PendingValidationCount) == 0x0001B0, "Member 'FPD3PlayerLoadout::PendingValidationCount' has a wrong offset!");
static_assert(offsetof(FPD3PlayerLoadout, bIsSkillArrayValidated) == 0x0001B1, "Member 'FPD3PlayerLoadout::bIsSkillArrayValidated' has a wrong offset!");
static_assert(offsetof(FPD3PlayerLoadout, bIsOverskillArrayValidated) == 0x0001B2, "Member 'FPD3PlayerLoadout::bIsOverskillArrayValidated' has a wrong offset!");
static_assert(offsetof(FPD3PlayerLoadout, AbilityData) == 0x0001B8, "Member 'FPD3PlayerLoadout::AbilityData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInteractReqData
// 0x0040 (0x0040 - 0x0000)
struct FSBZInteractReqData final
{
public:
	TArray<class FText>                           FailTextArray;                                     // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           SuccessTextOverrideArray;                          // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  IsHiddenFailArray;                                 // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZInteractReqData) == 0x000008, "Wrong alignment on FSBZInteractReqData");
static_assert(sizeof(FSBZInteractReqData) == 0x000040, "Wrong size on FSBZInteractReqData");
static_assert(offsetof(FSBZInteractReqData, FailTextArray) == 0x000000, "Member 'FSBZInteractReqData::FailTextArray' has a wrong offset!");
static_assert(offsetof(FSBZInteractReqData, SuccessTextOverrideArray) == 0x000010, "Member 'FSBZInteractReqData::SuccessTextOverrideArray' has a wrong offset!");
static_assert(offsetof(FSBZInteractReqData, IsHiddenFailArray) == 0x000020, "Member 'FSBZInteractReqData::IsHiddenFailArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZEquippableEndMissionResultData
// 0x0028 (0x0028 - 0x0000)
struct FSBZEquippableEndMissionResultData
{
public:
	int32                                         UseCount;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SecondaryUseCount;                                 // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UseSuccessCount;                                   // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KillCount;                                         // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageDealt;                                       // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Ammo;                                              // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAmmoLoaded;                                     // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReloadCount;                                       // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalReloadAmmoLeft;                               // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalReloadAmmoGone;                               // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZEquippableEndMissionResultData) == 0x000004, "Wrong alignment on FSBZEquippableEndMissionResultData");
static_assert(sizeof(FSBZEquippableEndMissionResultData) == 0x000028, "Wrong size on FSBZEquippableEndMissionResultData");
static_assert(offsetof(FSBZEquippableEndMissionResultData, UseCount) == 0x000000, "Member 'FSBZEquippableEndMissionResultData::UseCount' has a wrong offset!");
static_assert(offsetof(FSBZEquippableEndMissionResultData, SecondaryUseCount) == 0x000004, "Member 'FSBZEquippableEndMissionResultData::SecondaryUseCount' has a wrong offset!");
static_assert(offsetof(FSBZEquippableEndMissionResultData, UseSuccessCount) == 0x000008, "Member 'FSBZEquippableEndMissionResultData::UseSuccessCount' has a wrong offset!");
static_assert(offsetof(FSBZEquippableEndMissionResultData, KillCount) == 0x00000C, "Member 'FSBZEquippableEndMissionResultData::KillCount' has a wrong offset!");
static_assert(offsetof(FSBZEquippableEndMissionResultData, DamageDealt) == 0x000010, "Member 'FSBZEquippableEndMissionResultData::DamageDealt' has a wrong offset!");
static_assert(offsetof(FSBZEquippableEndMissionResultData, Ammo) == 0x000014, "Member 'FSBZEquippableEndMissionResultData::Ammo' has a wrong offset!");
static_assert(offsetof(FSBZEquippableEndMissionResultData, MinAmmoLoaded) == 0x000018, "Member 'FSBZEquippableEndMissionResultData::MinAmmoLoaded' has a wrong offset!");
static_assert(offsetof(FSBZEquippableEndMissionResultData, ReloadCount) == 0x00001C, "Member 'FSBZEquippableEndMissionResultData::ReloadCount' has a wrong offset!");
static_assert(offsetof(FSBZEquippableEndMissionResultData, TotalReloadAmmoLeft) == 0x000020, "Member 'FSBZEquippableEndMissionResultData::TotalReloadAmmoLeft' has a wrong offset!");
static_assert(offsetof(FSBZEquippableEndMissionResultData, TotalReloadAmmoGone) == 0x000024, "Member 'FSBZEquippableEndMissionResultData::TotalReloadAmmoGone' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMinimalAgilityTraversalTrajectory
// 0x0038 (0x0038 - 0x0000)
struct FSBZMinimalAgilityTraversalTrajectory final
{
public:
	struct FVector                                JumpPointLocation;                                 // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EdgePointFrontLocation;                            // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EdgePointBackLocation;                             // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LandPointLocation;                                 // 0x0024(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         EntrySpeed;                                        // 0x0030(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZAgilityTraversalType                      AgilityType;                                       // 0x0032(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEndsInCrouchState;                                // 0x0033(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEndsFalling;                                      // 0x0034(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZMinimalAgilityTraversalTrajectory) == 0x000004, "Wrong alignment on FSBZMinimalAgilityTraversalTrajectory");
static_assert(sizeof(FSBZMinimalAgilityTraversalTrajectory) == 0x000038, "Wrong size on FSBZMinimalAgilityTraversalTrajectory");
static_assert(offsetof(FSBZMinimalAgilityTraversalTrajectory, JumpPointLocation) == 0x000000, "Member 'FSBZMinimalAgilityTraversalTrajectory::JumpPointLocation' has a wrong offset!");
static_assert(offsetof(FSBZMinimalAgilityTraversalTrajectory, EdgePointFrontLocation) == 0x00000C, "Member 'FSBZMinimalAgilityTraversalTrajectory::EdgePointFrontLocation' has a wrong offset!");
static_assert(offsetof(FSBZMinimalAgilityTraversalTrajectory, EdgePointBackLocation) == 0x000018, "Member 'FSBZMinimalAgilityTraversalTrajectory::EdgePointBackLocation' has a wrong offset!");
static_assert(offsetof(FSBZMinimalAgilityTraversalTrajectory, LandPointLocation) == 0x000024, "Member 'FSBZMinimalAgilityTraversalTrajectory::LandPointLocation' has a wrong offset!");
static_assert(offsetof(FSBZMinimalAgilityTraversalTrajectory, EntrySpeed) == 0x000030, "Member 'FSBZMinimalAgilityTraversalTrajectory::EntrySpeed' has a wrong offset!");
static_assert(offsetof(FSBZMinimalAgilityTraversalTrajectory, AgilityType) == 0x000032, "Member 'FSBZMinimalAgilityTraversalTrajectory::AgilityType' has a wrong offset!");
static_assert(offsetof(FSBZMinimalAgilityTraversalTrajectory, bEndsInCrouchState) == 0x000033, "Member 'FSBZMinimalAgilityTraversalTrajectory::bEndsInCrouchState' has a wrong offset!");
static_assert(offsetof(FSBZMinimalAgilityTraversalTrajectory, bEndsFalling) == 0x000034, "Member 'FSBZMinimalAgilityTraversalTrajectory::bEndsFalling' has a wrong offset!");

// ScriptStruct Starbreeze.SBZChallengeProgressStat
// 0x0014 (0x0014 - 0x0000)
struct FSBZChallengeProgressStat final
{
public:
	class FName                                   StatId;                                            // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentProgress;                                   // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetProgress;                                    // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZChallengeProgressStat) == 0x000004, "Wrong alignment on FSBZChallengeProgressStat");
static_assert(sizeof(FSBZChallengeProgressStat) == 0x000014, "Wrong size on FSBZChallengeProgressStat");
static_assert(offsetof(FSBZChallengeProgressStat, StatId) == 0x000000, "Member 'FSBZChallengeProgressStat::StatId' has a wrong offset!");
static_assert(offsetof(FSBZChallengeProgressStat, CurrentProgress) == 0x00000C, "Member 'FSBZChallengeProgressStat::CurrentProgress' has a wrong offset!");
static_assert(offsetof(FSBZChallengeProgressStat, TargetProgress) == 0x000010, "Member 'FSBZChallengeProgressStat::TargetProgress' has a wrong offset!");

// ScriptStruct Starbreeze.SBZChallengeProgressItem
// 0x0020 (0x0020 - 0x0000)
struct FSBZChallengeProgressItem final
{
public:
	class FString                                 AccelbyteItemSku;                                  // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentQuantity;                                   // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetQuantity;                                    // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZInventoryBaseData*                  Item;                                              // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZChallengeProgressItem) == 0x000008, "Wrong alignment on FSBZChallengeProgressItem");
static_assert(sizeof(FSBZChallengeProgressItem) == 0x000020, "Wrong size on FSBZChallengeProgressItem");
static_assert(offsetof(FSBZChallengeProgressItem, AccelbyteItemSku) == 0x000000, "Member 'FSBZChallengeProgressItem::AccelbyteItemSku' has a wrong offset!");
static_assert(offsetof(FSBZChallengeProgressItem, CurrentQuantity) == 0x000010, "Member 'FSBZChallengeProgressItem::CurrentQuantity' has a wrong offset!");
static_assert(offsetof(FSBZChallengeProgressItem, TargetQuantity) == 0x000014, "Member 'FSBZChallengeProgressItem::TargetQuantity' has a wrong offset!");
static_assert(offsetof(FSBZChallengeProgressItem, Item) == 0x000018, "Member 'FSBZChallengeProgressItem::Item' has a wrong offset!");

// ScriptStruct Starbreeze.SBZChallengeRewardItem
// 0x0030 (0x0030 - 0x0000)
struct FSBZChallengeRewardItem final
{
public:
	class FString                                 AccelByteSku;                                      // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  AccelbyteItemId;                                   // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USBZInventoryBaseData*                  Item;                                              // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZChallengeRewardItem) == 0x000008, "Wrong alignment on FSBZChallengeRewardItem");
static_assert(sizeof(FSBZChallengeRewardItem) == 0x000030, "Wrong size on FSBZChallengeRewardItem");
static_assert(offsetof(FSBZChallengeRewardItem, AccelByteSku) == 0x000000, "Member 'FSBZChallengeRewardItem::AccelByteSku' has a wrong offset!");
static_assert(offsetof(FSBZChallengeRewardItem, AccelbyteItemId) == 0x000010, "Member 'FSBZChallengeRewardItem::AccelbyteItemId' has a wrong offset!");
static_assert(offsetof(FSBZChallengeRewardItem, Quantity) == 0x000020, "Member 'FSBZChallengeRewardItem::Quantity' has a wrong offset!");
static_assert(offsetof(FSBZChallengeRewardItem, Item) == 0x000028, "Member 'FSBZChallengeRewardItem::Item' has a wrong offset!");

// ScriptStruct Starbreeze.SBZChallengeData
// 0x00A8 (0x00A8 - 0x0000)
struct FSBZChallengeData final
{
public:
	class FName                                   ChallengeId;                                       // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ChallengeName;                                     // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  AccelbyteChallengeId;                              // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         PrerequisiteChallengeIds;                          // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSBZChallengeProgressStat>      PrerequisiteStatData;                              // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSBZChallengeProgressItem>      PrerequisiteItemData;                              // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSBZChallengeProgressStat>      ObjectiveStatData;                                 // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSBZChallengeRewardItem>        RewardItemsData;                                   // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         Tags;                                              // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EChallengeStatusEnum                          ChallengeStatus;                                   // 0x0090(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InfamyPointReward;                                 // 0x0094(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DailyCreationObjectiveStartStatValue;              // 0x0098(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalProgress;                                     // 0x009C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalTarget;                                       // 0x00A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZChallengeConversion                       ChallengeConversion;                               // 0x00A4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsActive;                                          // 0x00A5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A6[0x2];                                       // 0x00A6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZChallengeData) == 0x000008, "Wrong alignment on FSBZChallengeData");
static_assert(sizeof(FSBZChallengeData) == 0x0000A8, "Wrong size on FSBZChallengeData");
static_assert(offsetof(FSBZChallengeData, ChallengeId) == 0x000000, "Member 'FSBZChallengeData::ChallengeId' has a wrong offset!");
static_assert(offsetof(FSBZChallengeData, ChallengeName) == 0x000010, "Member 'FSBZChallengeData::ChallengeName' has a wrong offset!");
static_assert(offsetof(FSBZChallengeData, AccelbyteChallengeId) == 0x000020, "Member 'FSBZChallengeData::AccelbyteChallengeId' has a wrong offset!");
static_assert(offsetof(FSBZChallengeData, PrerequisiteChallengeIds) == 0x000030, "Member 'FSBZChallengeData::PrerequisiteChallengeIds' has a wrong offset!");
static_assert(offsetof(FSBZChallengeData, PrerequisiteStatData) == 0x000040, "Member 'FSBZChallengeData::PrerequisiteStatData' has a wrong offset!");
static_assert(offsetof(FSBZChallengeData, PrerequisiteItemData) == 0x000050, "Member 'FSBZChallengeData::PrerequisiteItemData' has a wrong offset!");
static_assert(offsetof(FSBZChallengeData, ObjectiveStatData) == 0x000060, "Member 'FSBZChallengeData::ObjectiveStatData' has a wrong offset!");
static_assert(offsetof(FSBZChallengeData, RewardItemsData) == 0x000070, "Member 'FSBZChallengeData::RewardItemsData' has a wrong offset!");
static_assert(offsetof(FSBZChallengeData, Tags) == 0x000080, "Member 'FSBZChallengeData::Tags' has a wrong offset!");
static_assert(offsetof(FSBZChallengeData, ChallengeStatus) == 0x000090, "Member 'FSBZChallengeData::ChallengeStatus' has a wrong offset!");
static_assert(offsetof(FSBZChallengeData, InfamyPointReward) == 0x000094, "Member 'FSBZChallengeData::InfamyPointReward' has a wrong offset!");
static_assert(offsetof(FSBZChallengeData, DailyCreationObjectiveStartStatValue) == 0x000098, "Member 'FSBZChallengeData::DailyCreationObjectiveStartStatValue' has a wrong offset!");
static_assert(offsetof(FSBZChallengeData, TotalProgress) == 0x00009C, "Member 'FSBZChallengeData::TotalProgress' has a wrong offset!");
static_assert(offsetof(FSBZChallengeData, TotalTarget) == 0x0000A0, "Member 'FSBZChallengeData::TotalTarget' has a wrong offset!");
static_assert(offsetof(FSBZChallengeData, ChallengeConversion) == 0x0000A4, "Member 'FSBZChallengeData::ChallengeConversion' has a wrong offset!");
static_assert(offsetof(FSBZChallengeData, IsActive) == 0x0000A5, "Member 'FSBZChallengeData::IsActive' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPlayerSlotInfo
// 0x0060 (0x0060 - 0x0000)
struct FSBZPlayerSlotInfo final
{
public:
	struct FUniqueNetIdRepl                       PlayerId;                                          // 0x0000(0x0028)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BackendPlayerId;                                   // 0x0028(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EOSProductUserId;                                  // 0x0038(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PartyCode;                                         // 0x0048(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVoiceSessionEnabled;                              // 0x0058(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPartyLeader;                                    // 0x0059(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZPlayerSlotInfo) == 0x000008, "Wrong alignment on FSBZPlayerSlotInfo");
static_assert(sizeof(FSBZPlayerSlotInfo) == 0x000060, "Wrong size on FSBZPlayerSlotInfo");
static_assert(offsetof(FSBZPlayerSlotInfo, PlayerId) == 0x000000, "Member 'FSBZPlayerSlotInfo::PlayerId' has a wrong offset!");
static_assert(offsetof(FSBZPlayerSlotInfo, BackendPlayerId) == 0x000028, "Member 'FSBZPlayerSlotInfo::BackendPlayerId' has a wrong offset!");
static_assert(offsetof(FSBZPlayerSlotInfo, EOSProductUserId) == 0x000038, "Member 'FSBZPlayerSlotInfo::EOSProductUserId' has a wrong offset!");
static_assert(offsetof(FSBZPlayerSlotInfo, PartyCode) == 0x000048, "Member 'FSBZPlayerSlotInfo::PartyCode' has a wrong offset!");
static_assert(offsetof(FSBZPlayerSlotInfo, bVoiceSessionEnabled) == 0x000058, "Member 'FSBZPlayerSlotInfo::bVoiceSessionEnabled' has a wrong offset!");
static_assert(offsetof(FSBZPlayerSlotInfo, bIsPartyLeader) == 0x000059, "Member 'FSBZPlayerSlotInfo::bIsPartyLeader' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPlayerStatisticsValue
// 0x0008 (0x0008 - 0x0000)
struct FSBZPlayerStatisticsValue final
{
public:
	float                                         CurrentValue;                                      // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreviousValue;                                     // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPlayerStatisticsValue) == 0x000004, "Wrong alignment on FSBZPlayerStatisticsValue");
static_assert(sizeof(FSBZPlayerStatisticsValue) == 0x000008, "Wrong size on FSBZPlayerStatisticsValue");
static_assert(offsetof(FSBZPlayerStatisticsValue, CurrentValue) == 0x000000, "Member 'FSBZPlayerStatisticsValue::CurrentValue' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStatisticsValue, PreviousValue) == 0x000004, "Member 'FSBZPlayerStatisticsValue::PreviousValue' has a wrong offset!");

// ScriptStruct Starbreeze.SBZBoneDamageMultiplier
// 0x000C (0x000C - 0x0000)
struct FSBZBoneDamageMultiplier final
{
public:
	bool                                          bIsCritical;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Multiplier;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalMultiplierReduction;                       // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZBoneDamageMultiplier) == 0x000004, "Wrong alignment on FSBZBoneDamageMultiplier");
static_assert(sizeof(FSBZBoneDamageMultiplier) == 0x00000C, "Wrong size on FSBZBoneDamageMultiplier");
static_assert(offsetof(FSBZBoneDamageMultiplier, bIsCritical) == 0x000000, "Member 'FSBZBoneDamageMultiplier::bIsCritical' has a wrong offset!");
static_assert(offsetof(FSBZBoneDamageMultiplier, Multiplier) == 0x000004, "Member 'FSBZBoneDamageMultiplier::Multiplier' has a wrong offset!");
static_assert(offsetof(FSBZBoneDamageMultiplier, CriticalMultiplierReduction) == 0x000008, "Member 'FSBZBoneDamageMultiplier::CriticalMultiplierReduction' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAccelerationBasedAngle
// 0x001C (0x001C - 0x0000)
struct FSBZAccelerationBasedAngle final
{
public:
	float                                         Speed;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Acceleration;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Deceleration;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x10];                                       // 0x000C(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAccelerationBasedAngle) == 0x000004, "Wrong alignment on FSBZAccelerationBasedAngle");
static_assert(sizeof(FSBZAccelerationBasedAngle) == 0x00001C, "Wrong size on FSBZAccelerationBasedAngle");
static_assert(offsetof(FSBZAccelerationBasedAngle, Speed) == 0x000000, "Member 'FSBZAccelerationBasedAngle::Speed' has a wrong offset!");
static_assert(offsetof(FSBZAccelerationBasedAngle, Acceleration) == 0x000004, "Member 'FSBZAccelerationBasedAngle::Acceleration' has a wrong offset!");
static_assert(offsetof(FSBZAccelerationBasedAngle, Deceleration) == 0x000008, "Member 'FSBZAccelerationBasedAngle::Deceleration' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCharacterMovementSetting
// 0x00D8 (0x00D8 - 0x0000)
struct FSBZCharacterMovementSetting final
{
public:
	int32                                         Stances;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseEyeHeight;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWalkSpeedCrouched;                              // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRunSpeed;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSprintSpeed;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTargetingSpeed;                                 // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAcceleration;                                   // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAccelerationRunning;                            // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakingDecelerationWalking;                        // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         FrictionSpeedBased;                                // 0x0024(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         FrictionSpeedBasedSpeedRange;                      // 0x002C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationRate;                                      // 0x0034(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bSlowDownOnCurvedPath;                             // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinRunSpeedOnCurvedPath;                           // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PathAngleForMinSpeed;                              // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvoidanceConsiderationRadius;                      // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvoidanceDefaultTimeToLive;                        // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvoidanceLockTimeAfterAvoid;                       // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvoidanceLockTimeAfterClean;                       // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvoidanceDeltaTimeToPredict;                       // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvoidanceArtificialRadiusExpansion;                // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAvoidanceCanSlowDownMovement;                     // 0x0064(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinAvoidanceSpeed;                                 // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NeighbourCollisionInnerRadius;                     // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NeighbourCollisionOuterRadius;                     // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NeighbourCollisionHardCollisionFactor;             // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NeighbourCollisionSoftCollisionFactor;             // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NeighbourCollisionMaxDuration;                     // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSBZAccelerationBasedAngle             ControlRotationYaw;                                // 0x0080(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FSBZAccelerationBasedAngle             ControlRotationPitch;                              // 0x009C(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         PathFocalDistance;                                 // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PathViewFocalDistance;                             // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZCharacterAnimationDataTP*           AnimationData;                                     // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 MaxWalkSpeeds;                                     // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FSBZCharacterMovementSetting) == 0x000008, "Wrong alignment on FSBZCharacterMovementSetting");
static_assert(sizeof(FSBZCharacterMovementSetting) == 0x0000D8, "Wrong size on FSBZCharacterMovementSetting");
static_assert(offsetof(FSBZCharacterMovementSetting, Stances) == 0x000000, "Member 'FSBZCharacterMovementSetting::Stances' has a wrong offset!");
static_assert(offsetof(FSBZCharacterMovementSetting, BaseEyeHeight) == 0x000004, "Member 'FSBZCharacterMovementSetting::BaseEyeHeight' has a wrong offset!");
static_assert(offsetof(FSBZCharacterMovementSetting, MaxWalkSpeedCrouched) == 0x000008, "Member 'FSBZCharacterMovementSetting::MaxWalkSpeedCrouched' has a wrong offset!");
static_assert(offsetof(FSBZCharacterMovementSetting, MaxRunSpeed) == 0x00000C, "Member 'FSBZCharacterMovementSetting::MaxRunSpeed' has a wrong offset!");
static_assert(offsetof(FSBZCharacterMovementSetting, MaxSprintSpeed) == 0x000010, "Member 'FSBZCharacterMovementSetting::MaxSprintSpeed' has a wrong offset!");
static_assert(offsetof(FSBZCharacterMovementSetting, MaxTargetingSpeed) == 0x000014, "Member 'FSBZCharacterMovementSetting::MaxTargetingSpeed' has a wrong offset!");
static_assert(offsetof(FSBZCharacterMovementSetting, MaxAcceleration) == 0x000018, "Member 'FSBZCharacterMovementSetting::MaxAcceleration' has a wrong offset!");
static_assert(offsetof(FSBZCharacterMovementSetting, MaxAccelerationRunning) == 0x00001C, "Member 'FSBZCharacterMovementSetting::MaxAccelerationRunning' has a wrong offset!");
static_assert(offsetof(FSBZCharacterMovementSetting, BrakingDecelerationWalking) == 0x000020, "Member 'FSBZCharacterMovementSetting::BrakingDecelerationWalking' has a wrong offset!");
static_assert(offsetof(FSBZCharacterMovementSetting, FrictionSpeedBased) == 0x000024, "Member 'FSBZCharacterMovementSetting::FrictionSpeedBased' has a wrong offset!");
static_assert(offsetof(FSBZCharacterMovementSetting, FrictionSpeedBasedSpeedRange) == 0x00002C, "Member 'FSBZCharacterMovementSetting::FrictionSpeedBasedSpeedRange' has a wrong offset!");
static_assert(offsetof(FSBZCharacterMovementSetting, RotationRate) == 0x000034, "Member 'FSBZCharacterMovementSetting::RotationRate' has a wrong offset!");
static_assert(offsetof(FSBZCharacterMovementSetting, bSlowDownOnCurvedPath) == 0x000040, "Member 'FSBZCharacterMovementSetting::bSlowDownOnCurvedPath' has a wrong offset!");
static_assert(offsetof(FSBZCharacterMovementSetting, MinRunSpeedOnCurvedPath) == 0x000044, "Member 'FSBZCharacterMovementSetting::MinRunSpeedOnCurvedPath' has a wrong offset!");
static_assert(offsetof(FSBZCharacterMovementSetting, PathAngleForMinSpeed) == 0x000048, "Member 'FSBZCharacterMovementSetting::PathAngleForMinSpeed' has a wrong offset!");
static_assert(offsetof(FSBZCharacterMovementSetting, AvoidanceConsiderationRadius) == 0x00004C, "Member 'FSBZCharacterMovementSetting::AvoidanceConsiderationRadius' has a wrong offset!");
static_assert(offsetof(FSBZCharacterMovementSetting, AvoidanceDefaultTimeToLive) == 0x000050, "Member 'FSBZCharacterMovementSetting::AvoidanceDefaultTimeToLive' has a wrong offset!");
static_assert(offsetof(FSBZCharacterMovementSetting, AvoidanceLockTimeAfterAvoid) == 0x000054, "Member 'FSBZCharacterMovementSetting::AvoidanceLockTimeAfterAvoid' has a wrong offset!");
static_assert(offsetof(FSBZCharacterMovementSetting, AvoidanceLockTimeAfterClean) == 0x000058, "Member 'FSBZCharacterMovementSetting::AvoidanceLockTimeAfterClean' has a wrong offset!");
static_assert(offsetof(FSBZCharacterMovementSetting, AvoidanceDeltaTimeToPredict) == 0x00005C, "Member 'FSBZCharacterMovementSetting::AvoidanceDeltaTimeToPredict' has a wrong offset!");
static_assert(offsetof(FSBZCharacterMovementSetting, AvoidanceArtificialRadiusExpansion) == 0x000060, "Member 'FSBZCharacterMovementSetting::AvoidanceArtificialRadiusExpansion' has a wrong offset!");
static_assert(offsetof(FSBZCharacterMovementSetting, bAvoidanceCanSlowDownMovement) == 0x000064, "Member 'FSBZCharacterMovementSetting::bAvoidanceCanSlowDownMovement' has a wrong offset!");
static_assert(offsetof(FSBZCharacterMovementSetting, MinAvoidanceSpeed) == 0x000068, "Member 'FSBZCharacterMovementSetting::MinAvoidanceSpeed' has a wrong offset!");
static_assert(offsetof(FSBZCharacterMovementSetting, NeighbourCollisionInnerRadius) == 0x00006C, "Member 'FSBZCharacterMovementSetting::NeighbourCollisionInnerRadius' has a wrong offset!");
static_assert(offsetof(FSBZCharacterMovementSetting, NeighbourCollisionOuterRadius) == 0x000070, "Member 'FSBZCharacterMovementSetting::NeighbourCollisionOuterRadius' has a wrong offset!");
static_assert(offsetof(FSBZCharacterMovementSetting, NeighbourCollisionHardCollisionFactor) == 0x000074, "Member 'FSBZCharacterMovementSetting::NeighbourCollisionHardCollisionFactor' has a wrong offset!");
static_assert(offsetof(FSBZCharacterMovementSetting, NeighbourCollisionSoftCollisionFactor) == 0x000078, "Member 'FSBZCharacterMovementSetting::NeighbourCollisionSoftCollisionFactor' has a wrong offset!");
static_assert(offsetof(FSBZCharacterMovementSetting, NeighbourCollisionMaxDuration) == 0x00007C, "Member 'FSBZCharacterMovementSetting::NeighbourCollisionMaxDuration' has a wrong offset!");
static_assert(offsetof(FSBZCharacterMovementSetting, ControlRotationYaw) == 0x000080, "Member 'FSBZCharacterMovementSetting::ControlRotationYaw' has a wrong offset!");
static_assert(offsetof(FSBZCharacterMovementSetting, ControlRotationPitch) == 0x00009C, "Member 'FSBZCharacterMovementSetting::ControlRotationPitch' has a wrong offset!");
static_assert(offsetof(FSBZCharacterMovementSetting, PathFocalDistance) == 0x0000B8, "Member 'FSBZCharacterMovementSetting::PathFocalDistance' has a wrong offset!");
static_assert(offsetof(FSBZCharacterMovementSetting, PathViewFocalDistance) == 0x0000BC, "Member 'FSBZCharacterMovementSetting::PathViewFocalDistance' has a wrong offset!");
static_assert(offsetof(FSBZCharacterMovementSetting, AnimationData) == 0x0000C0, "Member 'FSBZCharacterMovementSetting::AnimationData' has a wrong offset!");
static_assert(offsetof(FSBZCharacterMovementSetting, MaxWalkSpeeds) == 0x0000C8, "Member 'FSBZCharacterMovementSetting::MaxWalkSpeeds' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInfamyPointPayoutRewardData
// 0x0024 (0x0024 - 0x0000)
struct FSBZInfamyPointPayoutRewardData final
{
public:
	int32                                         Completion;                                        // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StealthBonus;                                      // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AllBagsBonus;                                      // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Total;                                             // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalFromBags;                                     // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalOnFailedHeist;                                // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalFromSurvivingAssults;                         // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InfamyPointsFromTickingLoot;                       // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxInfamyPointsFromTickingLoot;                    // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZInfamyPointPayoutRewardData) == 0x000004, "Wrong alignment on FSBZInfamyPointPayoutRewardData");
static_assert(sizeof(FSBZInfamyPointPayoutRewardData) == 0x000024, "Wrong size on FSBZInfamyPointPayoutRewardData");
static_assert(offsetof(FSBZInfamyPointPayoutRewardData, Completion) == 0x000000, "Member 'FSBZInfamyPointPayoutRewardData::Completion' has a wrong offset!");
static_assert(offsetof(FSBZInfamyPointPayoutRewardData, StealthBonus) == 0x000004, "Member 'FSBZInfamyPointPayoutRewardData::StealthBonus' has a wrong offset!");
static_assert(offsetof(FSBZInfamyPointPayoutRewardData, AllBagsBonus) == 0x000008, "Member 'FSBZInfamyPointPayoutRewardData::AllBagsBonus' has a wrong offset!");
static_assert(offsetof(FSBZInfamyPointPayoutRewardData, Total) == 0x00000C, "Member 'FSBZInfamyPointPayoutRewardData::Total' has a wrong offset!");
static_assert(offsetof(FSBZInfamyPointPayoutRewardData, TotalFromBags) == 0x000010, "Member 'FSBZInfamyPointPayoutRewardData::TotalFromBags' has a wrong offset!");
static_assert(offsetof(FSBZInfamyPointPayoutRewardData, TotalOnFailedHeist) == 0x000014, "Member 'FSBZInfamyPointPayoutRewardData::TotalOnFailedHeist' has a wrong offset!");
static_assert(offsetof(FSBZInfamyPointPayoutRewardData, TotalFromSurvivingAssults) == 0x000018, "Member 'FSBZInfamyPointPayoutRewardData::TotalFromSurvivingAssults' has a wrong offset!");
static_assert(offsetof(FSBZInfamyPointPayoutRewardData, InfamyPointsFromTickingLoot) == 0x00001C, "Member 'FSBZInfamyPointPayoutRewardData::InfamyPointsFromTickingLoot' has a wrong offset!");
static_assert(offsetof(FSBZInfamyPointPayoutRewardData, MaxInfamyPointsFromTickingLoot) == 0x000020, "Member 'FSBZInfamyPointPayoutRewardData::MaxInfamyPointsFromTickingLoot' has a wrong offset!");

// ScriptStruct Starbreeze.SBZBoneRef
// 0x0014 (0x0014 - 0x0000)
struct FSBZBoneRef final
{
public:
	struct FBoneReference                         Bone;                                              // 0x0000(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZBoneRef) == 0x000004, "Wrong alignment on FSBZBoneRef");
static_assert(sizeof(FSBZBoneRef) == 0x000014, "Wrong size on FSBZBoneRef");
static_assert(offsetof(FSBZBoneRef, Bone) == 0x000000, "Member 'FSBZBoneRef::Bone' has a wrong offset!");

// ScriptStruct Starbreeze.SBZLockCameraData
// 0x003C (0x003C - 0x0000)
struct FSBZLockCameraData final
{
public:
	struct FFloatInterval                         PitchLimit;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         YawLimit;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDampeningScale;                                 // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDampeningScale;                                 // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         StartScaleDampeningPitch;                          // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         StartScaleDampeningYaw;                            // 0x0020(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         EndScaleDampeningPitch;                            // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         EndScaleDampeningYaw;                              // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsClampRelativeToCurrent : 1;                     // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsDampeningUsed : 1;                              // 0x0038(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsDampeningOnlyTowardLimit : 1;                   // 0x0038(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsControlRotationAffected : 1;                    // 0x0038(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsControlRotationChangeAllowed : 1;               // 0x0038(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsOnlyControlRotationAffected : 1;                // 0x0038(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	int8                                          Priority;                                          // 0x0039(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZLockCameraData) == 0x000004, "Wrong alignment on FSBZLockCameraData");
static_assert(sizeof(FSBZLockCameraData) == 0x00003C, "Wrong size on FSBZLockCameraData");
static_assert(offsetof(FSBZLockCameraData, PitchLimit) == 0x000000, "Member 'FSBZLockCameraData::PitchLimit' has a wrong offset!");
static_assert(offsetof(FSBZLockCameraData, YawLimit) == 0x000008, "Member 'FSBZLockCameraData::YawLimit' has a wrong offset!");
static_assert(offsetof(FSBZLockCameraData, MinDampeningScale) == 0x000010, "Member 'FSBZLockCameraData::MinDampeningScale' has a wrong offset!");
static_assert(offsetof(FSBZLockCameraData, MaxDampeningScale) == 0x000014, "Member 'FSBZLockCameraData::MaxDampeningScale' has a wrong offset!");
static_assert(offsetof(FSBZLockCameraData, StartScaleDampeningPitch) == 0x000018, "Member 'FSBZLockCameraData::StartScaleDampeningPitch' has a wrong offset!");
static_assert(offsetof(FSBZLockCameraData, StartScaleDampeningYaw) == 0x000020, "Member 'FSBZLockCameraData::StartScaleDampeningYaw' has a wrong offset!");
static_assert(offsetof(FSBZLockCameraData, EndScaleDampeningPitch) == 0x000028, "Member 'FSBZLockCameraData::EndScaleDampeningPitch' has a wrong offset!");
static_assert(offsetof(FSBZLockCameraData, EndScaleDampeningYaw) == 0x000030, "Member 'FSBZLockCameraData::EndScaleDampeningYaw' has a wrong offset!");
static_assert(offsetof(FSBZLockCameraData, Priority) == 0x000039, "Member 'FSBZLockCameraData::Priority' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSkillRewardData
// 0x0030 (0x0030 - 0x0000)
struct FSBZSkillRewardData final
{
public:
	float                                         ExperiencePoints;                                  // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ResearchedSkillLine;                               // 0x0004(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           ProgressedSkillLines;                              // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class FName>                           ProgressedOverskillArray;                          // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSkillRewardData) == 0x000008, "Wrong alignment on FSBZSkillRewardData");
static_assert(sizeof(FSBZSkillRewardData) == 0x000030, "Wrong size on FSBZSkillRewardData");
static_assert(offsetof(FSBZSkillRewardData, ExperiencePoints) == 0x000000, "Member 'FSBZSkillRewardData::ExperiencePoints' has a wrong offset!");
static_assert(offsetof(FSBZSkillRewardData, ResearchedSkillLine) == 0x000004, "Member 'FSBZSkillRewardData::ResearchedSkillLine' has a wrong offset!");
static_assert(offsetof(FSBZSkillRewardData, ProgressedSkillLines) == 0x000010, "Member 'FSBZSkillRewardData::ProgressedSkillLines' has a wrong offset!");
static_assert(offsetof(FSBZSkillRewardData, ProgressedOverskillArray) == 0x000020, "Member 'FSBZSkillRewardData::ProgressedOverskillArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAudioRaycastingData
// 0x0090 (0x0090 - 0x0000)
struct alignas(0x08) FSBZAudioRaycastingData final
{
public:
	uint8                                         Pad_0[0x90];                                       // 0x0000(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAudioRaycastingData) == 0x000008, "Wrong alignment on FSBZAudioRaycastingData");
static_assert(sizeof(FSBZAudioRaycastingData) == 0x000090, "Wrong size on FSBZAudioRaycastingData");

// ScriptStruct Starbreeze.SBZCosmeticDestructionContext
// 0x0030 (0x0030 - 0x0000)
struct FSBZCosmeticDestructionContext final
{
public:
	struct FVector                                HitLocation;                                       // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FromDirection;                                     // 0x000C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0018(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactNormal;                                      // 0x0024(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZCosmeticDestructionContext) == 0x000004, "Wrong alignment on FSBZCosmeticDestructionContext");
static_assert(sizeof(FSBZCosmeticDestructionContext) == 0x000030, "Wrong size on FSBZCosmeticDestructionContext");
static_assert(offsetof(FSBZCosmeticDestructionContext, HitLocation) == 0x000000, "Member 'FSBZCosmeticDestructionContext::HitLocation' has a wrong offset!");
static_assert(offsetof(FSBZCosmeticDestructionContext, FromDirection) == 0x00000C, "Member 'FSBZCosmeticDestructionContext::FromDirection' has a wrong offset!");
static_assert(offsetof(FSBZCosmeticDestructionContext, Origin) == 0x000018, "Member 'FSBZCosmeticDestructionContext::Origin' has a wrong offset!");
static_assert(offsetof(FSBZCosmeticDestructionContext, ImpactNormal) == 0x000024, "Member 'FSBZCosmeticDestructionContext::ImpactNormal' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInfamyRewardData
// 0x0018 (0x0018 - 0x0000)
struct FSBZInfamyRewardData final
{
public:
	class FString                                 ContentGivenType;                                  // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ContentGivenValue;                                 // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZInfamyRewardData) == 0x000008, "Wrong alignment on FSBZInfamyRewardData");
static_assert(sizeof(FSBZInfamyRewardData) == 0x000018, "Wrong size on FSBZInfamyRewardData");
static_assert(offsetof(FSBZInfamyRewardData, ContentGivenType) == 0x000000, "Member 'FSBZInfamyRewardData::ContentGivenType' has a wrong offset!");
static_assert(offsetof(FSBZInfamyRewardData, ContentGivenValue) == 0x000010, "Member 'FSBZInfamyRewardData::ContentGivenValue' has a wrong offset!");

// ScriptStruct Starbreeze.SkelMeshMergeUVTransform
// 0x0010 (0x0010 - 0x0000)
struct FSkelMeshMergeUVTransform final
{
public:
	TArray<struct FTransform>                     UVTransforms;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkelMeshMergeUVTransform) == 0x000008, "Wrong alignment on FSkelMeshMergeUVTransform");
static_assert(sizeof(FSkelMeshMergeUVTransform) == 0x000010, "Wrong size on FSkelMeshMergeUVTransform");
static_assert(offsetof(FSkelMeshMergeUVTransform, UVTransforms) == 0x000000, "Member 'FSkelMeshMergeUVTransform::UVTransforms' has a wrong offset!");

// ScriptStruct Starbreeze.SkelMeshMergeUVTransformMapping
// 0x0010 (0x0010 - 0x0000)
struct FSkelMeshMergeUVTransformMapping final
{
public:
	TArray<struct FSkelMeshMergeUVTransform>      UVTransformsPerMesh;                               // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkelMeshMergeUVTransformMapping) == 0x000008, "Wrong alignment on FSkelMeshMergeUVTransformMapping");
static_assert(sizeof(FSkelMeshMergeUVTransformMapping) == 0x000010, "Wrong size on FSkelMeshMergeUVTransformMapping");
static_assert(offsetof(FSkelMeshMergeUVTransformMapping, UVTransformsPerMesh) == 0x000000, "Member 'FSkelMeshMergeUVTransformMapping::UVTransformsPerMesh' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCashRewardReductionData
// 0x0010 (0x0010 - 0x0000)
struct FSBZCashRewardReductionData final
{
public:
	int32                                         Count;                                             // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReductionPercentage;                               // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReductionCash;                                     // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZRewardReductionType                       ReductionType;                                     // 0x000C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZCashRewardReductionData) == 0x000004, "Wrong alignment on FSBZCashRewardReductionData");
static_assert(sizeof(FSBZCashRewardReductionData) == 0x000010, "Wrong size on FSBZCashRewardReductionData");
static_assert(offsetof(FSBZCashRewardReductionData, Count) == 0x000000, "Member 'FSBZCashRewardReductionData::Count' has a wrong offset!");
static_assert(offsetof(FSBZCashRewardReductionData, ReductionPercentage) == 0x000004, "Member 'FSBZCashRewardReductionData::ReductionPercentage' has a wrong offset!");
static_assert(offsetof(FSBZCashRewardReductionData, ReductionCash) == 0x000008, "Member 'FSBZCashRewardReductionData::ReductionCash' has a wrong offset!");
static_assert(offsetof(FSBZCashRewardReductionData, ReductionType) == 0x00000C, "Member 'FSBZCashRewardReductionData::ReductionType' has a wrong offset!");

// ScriptStruct Starbreeze.SBZLobbyCharacterInfoUi
// 0x02D8 (0x02D8 - 0x0000)
struct FSBZLobbyCharacterInfoUi final
{
public:
	TSubclassOf<class APawn>                      PawnClass;                                         // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PawnSoftClass;                                     // 0x0008(0x0030)(BlueprintVisible, BlueprintReadOnly, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAsyncLoadInProgress;                              // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPlayerReady;                                    // 0x0049(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerAcceptedMatch;                              // 0x004A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B[0x1];                                       // 0x004B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LevelIdx;                                          // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PowerLevel;                                        // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Nickname;                                          // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UserId;                                            // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AccelBytePlayerName;                               // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerUidString;                                   // 0x0088(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EOSProdUId;                                        // 0x0098(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUniqueNetIdRepl                       PlayerUId;                                         // 0x00A8(0x0028)(BlueprintVisible, BlueprintReadOnly, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZSlotStatus                                SlotStatus;                                        // 0x00D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PreplanningAssetSku;                               // 0x00D8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZPlatform                                  Platform;                                          // 0x00E8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZFirstPartyPlatform                        FirstPartyPlatform;                                // 0x00E9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EA[0x2];                                       // 0x00EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InfamyLevel;                                       // 0x00EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RenownLevel;                                       // 0x00F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPD3PlayerLoadout                      Loadout;                                           // 0x00F8(0x01C0)(Transient, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SelectedCharacter;                                 // 0x02B8(0x0020)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZLobbyCharacterInfoUi) == 0x000008, "Wrong alignment on FSBZLobbyCharacterInfoUi");
static_assert(sizeof(FSBZLobbyCharacterInfoUi) == 0x0002D8, "Wrong size on FSBZLobbyCharacterInfoUi");
static_assert(offsetof(FSBZLobbyCharacterInfoUi, PawnClass) == 0x000000, "Member 'FSBZLobbyCharacterInfoUi::PawnClass' has a wrong offset!");
static_assert(offsetof(FSBZLobbyCharacterInfoUi, PawnSoftClass) == 0x000008, "Member 'FSBZLobbyCharacterInfoUi::PawnSoftClass' has a wrong offset!");
static_assert(offsetof(FSBZLobbyCharacterInfoUi, bAsyncLoadInProgress) == 0x000048, "Member 'FSBZLobbyCharacterInfoUi::bAsyncLoadInProgress' has a wrong offset!");
static_assert(offsetof(FSBZLobbyCharacterInfoUi, bIsPlayerReady) == 0x000049, "Member 'FSBZLobbyCharacterInfoUi::bIsPlayerReady' has a wrong offset!");
static_assert(offsetof(FSBZLobbyCharacterInfoUi, bPlayerAcceptedMatch) == 0x00004A, "Member 'FSBZLobbyCharacterInfoUi::bPlayerAcceptedMatch' has a wrong offset!");
static_assert(offsetof(FSBZLobbyCharacterInfoUi, LevelIdx) == 0x00004C, "Member 'FSBZLobbyCharacterInfoUi::LevelIdx' has a wrong offset!");
static_assert(offsetof(FSBZLobbyCharacterInfoUi, PowerLevel) == 0x000050, "Member 'FSBZLobbyCharacterInfoUi::PowerLevel' has a wrong offset!");
static_assert(offsetof(FSBZLobbyCharacterInfoUi, Nickname) == 0x000058, "Member 'FSBZLobbyCharacterInfoUi::Nickname' has a wrong offset!");
static_assert(offsetof(FSBZLobbyCharacterInfoUi, UserId) == 0x000068, "Member 'FSBZLobbyCharacterInfoUi::UserId' has a wrong offset!");
static_assert(offsetof(FSBZLobbyCharacterInfoUi, AccelBytePlayerName) == 0x000078, "Member 'FSBZLobbyCharacterInfoUi::AccelBytePlayerName' has a wrong offset!");
static_assert(offsetof(FSBZLobbyCharacterInfoUi, PlayerUidString) == 0x000088, "Member 'FSBZLobbyCharacterInfoUi::PlayerUidString' has a wrong offset!");
static_assert(offsetof(FSBZLobbyCharacterInfoUi, EOSProdUId) == 0x000098, "Member 'FSBZLobbyCharacterInfoUi::EOSProdUId' has a wrong offset!");
static_assert(offsetof(FSBZLobbyCharacterInfoUi, PlayerUId) == 0x0000A8, "Member 'FSBZLobbyCharacterInfoUi::PlayerUId' has a wrong offset!");
static_assert(offsetof(FSBZLobbyCharacterInfoUi, SlotStatus) == 0x0000D0, "Member 'FSBZLobbyCharacterInfoUi::SlotStatus' has a wrong offset!");
static_assert(offsetof(FSBZLobbyCharacterInfoUi, PreplanningAssetSku) == 0x0000D8, "Member 'FSBZLobbyCharacterInfoUi::PreplanningAssetSku' has a wrong offset!");
static_assert(offsetof(FSBZLobbyCharacterInfoUi, Platform) == 0x0000E8, "Member 'FSBZLobbyCharacterInfoUi::Platform' has a wrong offset!");
static_assert(offsetof(FSBZLobbyCharacterInfoUi, FirstPartyPlatform) == 0x0000E9, "Member 'FSBZLobbyCharacterInfoUi::FirstPartyPlatform' has a wrong offset!");
static_assert(offsetof(FSBZLobbyCharacterInfoUi, InfamyLevel) == 0x0000EC, "Member 'FSBZLobbyCharacterInfoUi::InfamyLevel' has a wrong offset!");
static_assert(offsetof(FSBZLobbyCharacterInfoUi, RenownLevel) == 0x0000F0, "Member 'FSBZLobbyCharacterInfoUi::RenownLevel' has a wrong offset!");
static_assert(offsetof(FSBZLobbyCharacterInfoUi, Loadout) == 0x0000F8, "Member 'FSBZLobbyCharacterInfoUi::Loadout' has a wrong offset!");
static_assert(offsetof(FSBZLobbyCharacterInfoUi, SelectedCharacter) == 0x0002B8, "Member 'FSBZLobbyCharacterInfoUi::SelectedCharacter' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCheckInteractableScreenOutputData
// 0x00E0 (0x00E0 - 0x0000)
struct FSBZCheckInteractableScreenOutputData final
{
public:
	class USBZBaseInteractableComponent*          Interactable;                                      // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0008(0x0090)(Transient, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FSBZInteractReqData                    ReqData;                                           // 0x0098(0x0040)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZCheckInteractableScreenOutputData) == 0x000008, "Wrong alignment on FSBZCheckInteractableScreenOutputData");
static_assert(sizeof(FSBZCheckInteractableScreenOutputData) == 0x0000E0, "Wrong size on FSBZCheckInteractableScreenOutputData");
static_assert(offsetof(FSBZCheckInteractableScreenOutputData, Interactable) == 0x000000, "Member 'FSBZCheckInteractableScreenOutputData::Interactable' has a wrong offset!");
static_assert(offsetof(FSBZCheckInteractableScreenOutputData, HitResult) == 0x000008, "Member 'FSBZCheckInteractableScreenOutputData::HitResult' has a wrong offset!");
static_assert(offsetof(FSBZCheckInteractableScreenOutputData, ReqData) == 0x000098, "Member 'FSBZCheckInteractableScreenOutputData::ReqData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInventorySlot
// 0x0028 (0x0028 - 0x0000)
struct FSBZInventorySlot
{
public:
	ESBZItemInventorySlotAvailability             ItemInventorySlotAvailability;                     // 0x0000(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  ConfigSlotEntitlementId;                           // 0x0004(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ConfigSlotItemSku;                                 // 0x0018(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZInventorySlot) == 0x000008, "Wrong alignment on FSBZInventorySlot");
static_assert(sizeof(FSBZInventorySlot) == 0x000028, "Wrong size on FSBZInventorySlot");
static_assert(offsetof(FSBZInventorySlot, ItemInventorySlotAvailability) == 0x000000, "Member 'FSBZInventorySlot::ItemInventorySlotAvailability' has a wrong offset!");
static_assert(offsetof(FSBZInventorySlot, ConfigSlotEntitlementId) == 0x000004, "Member 'FSBZInventorySlot::ConfigSlotEntitlementId' has a wrong offset!");
static_assert(offsetof(FSBZInventorySlot, ConfigSlotItemSku) == 0x000018, "Member 'FSBZInventorySlot::ConfigSlotItemSku' has a wrong offset!");

// ScriptStruct Starbreeze.SBZGloveInventorySlot
// 0x0028 (0x0050 - 0x0028)
struct FSBZGloveInventorySlot final : public FSBZInventorySlot
{
public:
	struct FGuid                                  GloveInSlotEntitlementId;                          // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GloveInSlotAccelByteItemSku;                       // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZGloveData*                          GloveData;                                         // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZGloveInventorySlot) == 0x000008, "Wrong alignment on FSBZGloveInventorySlot");
static_assert(sizeof(FSBZGloveInventorySlot) == 0x000050, "Wrong size on FSBZGloveInventorySlot");
static_assert(offsetof(FSBZGloveInventorySlot, GloveInSlotEntitlementId) == 0x000028, "Member 'FSBZGloveInventorySlot::GloveInSlotEntitlementId' has a wrong offset!");
static_assert(offsetof(FSBZGloveInventorySlot, GloveInSlotAccelByteItemSku) == 0x000038, "Member 'FSBZGloveInventorySlot::GloveInSlotAccelByteItemSku' has a wrong offset!");
static_assert(offsetof(FSBZGloveInventorySlot, GloveData) == 0x000048, "Member 'FSBZGloveInventorySlot::GloveData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZGloveConfigInventorySaveData
// 0x0020 (0x0020 - 0x0000)
struct FSBZGloveConfigInventorySaveData final
{
public:
	TArray<struct FSBZGloveInventorySlot>         GloveConfigSlots;                                  // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FSBZGloveInventorySlot>         CheckedGloveConfigSlots;                           // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZGloveConfigInventorySaveData) == 0x000008, "Wrong alignment on FSBZGloveConfigInventorySaveData");
static_assert(sizeof(FSBZGloveConfigInventorySaveData) == 0x000020, "Wrong size on FSBZGloveConfigInventorySaveData");
static_assert(offsetof(FSBZGloveConfigInventorySaveData, GloveConfigSlots) == 0x000000, "Member 'FSBZGloveConfigInventorySaveData::GloveConfigSlots' has a wrong offset!");
static_assert(offsetof(FSBZGloveConfigInventorySaveData, CheckedGloveConfigSlots) == 0x000010, "Member 'FSBZGloveConfigInventorySaveData::CheckedGloveConfigSlots' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMilestoneRewardData
// 0x0018 (0x0018 - 0x0000)
struct FSBZMilestoneRewardData final
{
public:
	class FString                                 MilestoneName;                                     // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MilestoneRewardRatio;                              // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZMilestoneRewardData) == 0x000008, "Wrong alignment on FSBZMilestoneRewardData");
static_assert(sizeof(FSBZMilestoneRewardData) == 0x000018, "Wrong size on FSBZMilestoneRewardData");
static_assert(offsetof(FSBZMilestoneRewardData, MilestoneName) == 0x000000, "Member 'FSBZMilestoneRewardData::MilestoneName' has a wrong offset!");
static_assert(offsetof(FSBZMilestoneRewardData, MilestoneRewardRatio) == 0x000010, "Member 'FSBZMilestoneRewardData::MilestoneRewardRatio' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCharacterEndMissionExpBonusData
// 0x0030 (0x0030 - 0x0000)
struct FSBZCharacterEndMissionExpBonusData final
{
public:
	int32                                         TotalExp;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoudMilestoneRatio;                                // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoudBaseExp;                                       // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StealthMilestoneRatio;                             // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StealthBaseExp;                                    // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DifficultyModifier;                                // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerformanceModifier;                               // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExperiencePointsFromObjectivesModifier;            // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSBZMilestoneRewardData>        MilestoneRewardDataArray;                          // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZCharacterEndMissionExpBonusData) == 0x000008, "Wrong alignment on FSBZCharacterEndMissionExpBonusData");
static_assert(sizeof(FSBZCharacterEndMissionExpBonusData) == 0x000030, "Wrong size on FSBZCharacterEndMissionExpBonusData");
static_assert(offsetof(FSBZCharacterEndMissionExpBonusData, TotalExp) == 0x000000, "Member 'FSBZCharacterEndMissionExpBonusData::TotalExp' has a wrong offset!");
static_assert(offsetof(FSBZCharacterEndMissionExpBonusData, LoudMilestoneRatio) == 0x000004, "Member 'FSBZCharacterEndMissionExpBonusData::LoudMilestoneRatio' has a wrong offset!");
static_assert(offsetof(FSBZCharacterEndMissionExpBonusData, LoudBaseExp) == 0x000008, "Member 'FSBZCharacterEndMissionExpBonusData::LoudBaseExp' has a wrong offset!");
static_assert(offsetof(FSBZCharacterEndMissionExpBonusData, StealthMilestoneRatio) == 0x00000C, "Member 'FSBZCharacterEndMissionExpBonusData::StealthMilestoneRatio' has a wrong offset!");
static_assert(offsetof(FSBZCharacterEndMissionExpBonusData, StealthBaseExp) == 0x000010, "Member 'FSBZCharacterEndMissionExpBonusData::StealthBaseExp' has a wrong offset!");
static_assert(offsetof(FSBZCharacterEndMissionExpBonusData, DifficultyModifier) == 0x000014, "Member 'FSBZCharacterEndMissionExpBonusData::DifficultyModifier' has a wrong offset!");
static_assert(offsetof(FSBZCharacterEndMissionExpBonusData, PerformanceModifier) == 0x000018, "Member 'FSBZCharacterEndMissionExpBonusData::PerformanceModifier' has a wrong offset!");
static_assert(offsetof(FSBZCharacterEndMissionExpBonusData, ExperiencePointsFromObjectivesModifier) == 0x00001C, "Member 'FSBZCharacterEndMissionExpBonusData::ExperiencePointsFromObjectivesModifier' has a wrong offset!");
static_assert(offsetof(FSBZCharacterEndMissionExpBonusData, MilestoneRewardDataArray) == 0x000020, "Member 'FSBZCharacterEndMissionExpBonusData::MilestoneRewardDataArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWrinklePackedFloatData
// 0x0010 (0x0010 - 0x0000)
struct FSBZWrinklePackedFloatData final
{
public:
	int32                                         PackedFloatIndex;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CurveName;                                         // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWrinklePackedFloatData) == 0x000004, "Wrong alignment on FSBZWrinklePackedFloatData");
static_assert(sizeof(FSBZWrinklePackedFloatData) == 0x000010, "Wrong size on FSBZWrinklePackedFloatData");
static_assert(offsetof(FSBZWrinklePackedFloatData, PackedFloatIndex) == 0x000000, "Member 'FSBZWrinklePackedFloatData::PackedFloatIndex' has a wrong offset!");
static_assert(offsetof(FSBZWrinklePackedFloatData, CurveName) == 0x000004, "Member 'FSBZWrinklePackedFloatData::CurveName' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCameraViewRestriction
// 0x0020 (0x0020 - 0x0000)
struct FSBZCameraViewRestriction final
{
public:
	float                                         YawMin;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawMax;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMin;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMax;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollMin;                                           // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollMax;                                           // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZCameraViewRestriction) == 0x000004, "Wrong alignment on FSBZCameraViewRestriction");
static_assert(sizeof(FSBZCameraViewRestriction) == 0x000020, "Wrong size on FSBZCameraViewRestriction");
static_assert(offsetof(FSBZCameraViewRestriction, YawMin) == 0x000000, "Member 'FSBZCameraViewRestriction::YawMin' has a wrong offset!");
static_assert(offsetof(FSBZCameraViewRestriction, YawMax) == 0x000004, "Member 'FSBZCameraViewRestriction::YawMax' has a wrong offset!");
static_assert(offsetof(FSBZCameraViewRestriction, PitchMin) == 0x000008, "Member 'FSBZCameraViewRestriction::PitchMin' has a wrong offset!");
static_assert(offsetof(FSBZCameraViewRestriction, PitchMax) == 0x00000C, "Member 'FSBZCameraViewRestriction::PitchMax' has a wrong offset!");
static_assert(offsetof(FSBZCameraViewRestriction, RollMin) == 0x000010, "Member 'FSBZCameraViewRestriction::RollMin' has a wrong offset!");
static_assert(offsetof(FSBZCameraViewRestriction, RollMax) == 0x000014, "Member 'FSBZCameraViewRestriction::RollMax' has a wrong offset!");
static_assert(offsetof(FSBZCameraViewRestriction, Priority) == 0x000018, "Member 'FSBZCameraViewRestriction::Priority' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSpectateCameraSettings
// 0x0028 (0x0028 - 0x0000)
struct FSBZSpectateCameraSettings final
{
public:
	struct FSBZCameraViewRestriction              CameraViewRestriction;                             // 0x0000(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TargetSpringArmLength;                             // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetSpringArmLengthInterpSpeed;                  // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSpectateCameraSettings) == 0x000004, "Wrong alignment on FSBZSpectateCameraSettings");
static_assert(sizeof(FSBZSpectateCameraSettings) == 0x000028, "Wrong size on FSBZSpectateCameraSettings");
static_assert(offsetof(FSBZSpectateCameraSettings, CameraViewRestriction) == 0x000000, "Member 'FSBZSpectateCameraSettings::CameraViewRestriction' has a wrong offset!");
static_assert(offsetof(FSBZSpectateCameraSettings, TargetSpringArmLength) == 0x000020, "Member 'FSBZSpectateCameraSettings::TargetSpringArmLength' has a wrong offset!");
static_assert(offsetof(FSBZSpectateCameraSettings, TargetSpringArmLengthInterpSpeed) == 0x000024, "Member 'FSBZSpectateCameraSettings::TargetSpringArmLengthInterpSpeed' has a wrong offset!");

// ScriptStruct Starbreeze.SBZTargetCandidate
// 0x0018 (0x0018 - 0x0000)
struct FSBZTargetCandidate final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZTargetCandidate) == 0x000008, "Wrong alignment on FSBZTargetCandidate");
static_assert(sizeof(FSBZTargetCandidate) == 0x000018, "Wrong size on FSBZTargetCandidate");
static_assert(offsetof(FSBZTargetCandidate, Target) == 0x000000, "Member 'FSBZTargetCandidate::Target' has a wrong offset!");

// ScriptStruct Starbreeze.SBZBuiltInAnimMontageInstance
// 0x0018 (0x0018 - 0x0000)
struct FSBZBuiltInAnimMontageInstance final
{
public:
	class USBZBuiltInAnimMontage*                 AnimMontage;                                       // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZBuiltInAnimMontageInstance) == 0x000008, "Wrong alignment on FSBZBuiltInAnimMontageInstance");
static_assert(sizeof(FSBZBuiltInAnimMontageInstance) == 0x000018, "Wrong size on FSBZBuiltInAnimMontageInstance");
static_assert(offsetof(FSBZBuiltInAnimMontageInstance, AnimMontage) == 0x000000, "Member 'FSBZBuiltInAnimMontageInstance::AnimMontage' has a wrong offset!");

// ScriptStruct Starbreeze.ColliderDataContainer
// 0x0010 (0x0010 - 0x0000)
struct FColliderDataContainer final
{
public:
	class UPrimitiveComponent*                    Collider;                                          // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AssociatedInteractable;                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FColliderDataContainer) == 0x000008, "Wrong alignment on FColliderDataContainer");
static_assert(sizeof(FColliderDataContainer) == 0x000010, "Wrong size on FColliderDataContainer");
static_assert(offsetof(FColliderDataContainer, Collider) == 0x000000, "Member 'FColliderDataContainer::Collider' has a wrong offset!");
static_assert(offsetof(FColliderDataContainer, AssociatedInteractable) == 0x000008, "Member 'FColliderDataContainer::AssociatedInteractable' has a wrong offset!");

// ScriptStruct Starbreeze.SBZGameEventStructBase
// 0x0000 (0x0000 - 0x0000)
#pragma pack(push, 0x1)
struct alignas(0x01) FSBZGameEventStructBase
{
};
#pragma pack(pop)
static_assert(alignof(FSBZGameEventStructBase) == 0x000001, "Wrong alignment on FSBZGameEventStructBase");
static_assert(sizeof(FSBZGameEventStructBase) == 0x000001, "Wrong size on FSBZGameEventStructBase");

// ScriptStruct Starbreeze.SBZPlayerStateRemovedEvent
// 0x0040 (0x0040 - 0x0000)
struct FSBZPlayerStateRemovedEvent final : public FSBZGameEventStructBase
{
public:
	class APlayerState*                           PlayerState;                                       // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUniqueNetIdRepl                       PlayerId;                                          // 0x0018(0x0028)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPlayerStateRemovedEvent) == 0x000008, "Wrong alignment on FSBZPlayerStateRemovedEvent");
static_assert(sizeof(FSBZPlayerStateRemovedEvent) == 0x000040, "Wrong size on FSBZPlayerStateRemovedEvent");
static_assert(offsetof(FSBZPlayerStateRemovedEvent, PlayerState) == 0x000000, "Member 'FSBZPlayerStateRemovedEvent::PlayerState' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStateRemovedEvent, Name) == 0x000008, "Member 'FSBZPlayerStateRemovedEvent::Name' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStateRemovedEvent, PlayerId) == 0x000018, "Member 'FSBZPlayerStateRemovedEvent::PlayerId' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMenuACSlots
// 0x0018 (0x0018 - 0x0000)
struct FSBZMenuACSlots final
{
public:
	bool                                          bOverride;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UAnimationAsset>> Animations;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZMenuACSlots) == 0x000008, "Wrong alignment on FSBZMenuACSlots");
static_assert(sizeof(FSBZMenuACSlots) == 0x000018, "Wrong size on FSBZMenuACSlots");
static_assert(offsetof(FSBZMenuACSlots, bOverride) == 0x000000, "Member 'FSBZMenuACSlots::bOverride' has a wrong offset!");
static_assert(offsetof(FSBZMenuACSlots, Animations) == 0x000008, "Member 'FSBZMenuACSlots::Animations' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMenuACCharacterEquippableSlots
// 0x0030 (0x0030 - 0x0000)
struct FSBZMenuACCharacterEquippableSlots final
{
public:
	struct FSBZMenuACSlots                        CharacterSlots;                                    // 0x0000(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSBZMenuACSlots                        EquippableSlots;                                   // 0x0018(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZMenuACCharacterEquippableSlots) == 0x000008, "Wrong alignment on FSBZMenuACCharacterEquippableSlots");
static_assert(sizeof(FSBZMenuACCharacterEquippableSlots) == 0x000030, "Wrong size on FSBZMenuACCharacterEquippableSlots");
static_assert(offsetof(FSBZMenuACCharacterEquippableSlots, CharacterSlots) == 0x000000, "Member 'FSBZMenuACCharacterEquippableSlots::CharacterSlots' has a wrong offset!");
static_assert(offsetof(FSBZMenuACCharacterEquippableSlots, EquippableSlots) == 0x000018, "Member 'FSBZMenuACCharacterEquippableSlots::EquippableSlots' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMenuACEquippablePerCharacterSlot
// 0x0050 (0x0050 - 0x0000)
struct FSBZMenuACEquippablePerCharacterSlot final
{
public:
	TMap<class FName, struct FSBZMenuACCharacterEquippableSlots> SlotsMap;                           // 0x0000(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZMenuACEquippablePerCharacterSlot) == 0x000008, "Wrong alignment on FSBZMenuACEquippablePerCharacterSlot");
static_assert(sizeof(FSBZMenuACEquippablePerCharacterSlot) == 0x000050, "Wrong size on FSBZMenuACEquippablePerCharacterSlot");
static_assert(offsetof(FSBZMenuACEquippablePerCharacterSlot, SlotsMap) == 0x000000, "Member 'FSBZMenuACEquippablePerCharacterSlot::SlotsMap' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAcousticPortalConnectedActors
// 0x0010 (0x0010 - 0x0000)
struct FSBZAcousticPortalConnectedActors final
{
public:
	TArray<TSoftObjectPtr<class AActor>>          Array;                                             // 0x0000(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAcousticPortalConnectedActors) == 0x000008, "Wrong alignment on FSBZAcousticPortalConnectedActors");
static_assert(sizeof(FSBZAcousticPortalConnectedActors) == 0x000010, "Wrong size on FSBZAcousticPortalConnectedActors");
static_assert(offsetof(FSBZAcousticPortalConnectedActors, Array) == 0x000000, "Member 'FSBZAcousticPortalConnectedActors::Array' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMilestoneData
// 0x0018 (0x0018 - 0x0000)
struct FSBZMilestoneData final
{
public:
	class FString                                 MilestoneId;                                       // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCompleted;                                        // 0x0010(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZMilestoneData) == 0x000008, "Wrong alignment on FSBZMilestoneData");
static_assert(sizeof(FSBZMilestoneData) == 0x000018, "Wrong size on FSBZMilestoneData");
static_assert(offsetof(FSBZMilestoneData, MilestoneId) == 0x000000, "Member 'FSBZMilestoneData::MilestoneId' has a wrong offset!");
static_assert(offsetof(FSBZMilestoneData, bCompleted) == 0x000010, "Member 'FSBZMilestoneData::bCompleted' has a wrong offset!");

// ScriptStruct Starbreeze.SBZFootBoneModifier
// 0x0010 (0x0010 - 0x0000)
struct FSBZFootBoneModifier final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Offset;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZFootBoneModifier) == 0x000004, "Wrong alignment on FSBZFootBoneModifier");
static_assert(sizeof(FSBZFootBoneModifier) == 0x000010, "Wrong size on FSBZFootBoneModifier");
static_assert(offsetof(FSBZFootBoneModifier, BoneName) == 0x000000, "Member 'FSBZFootBoneModifier::BoneName' has a wrong offset!");
static_assert(offsetof(FSBZFootBoneModifier, Offset) == 0x00000C, "Member 'FSBZFootBoneModifier::Offset' has a wrong offset!");

// ScriptStruct Starbreeze.InteractableDataContainer
// 0x0028 (0x0028 - 0x0000)
struct FInteractableDataContainer final
{
public:
	class USBZInteractableComponent*              Interactable;                                      // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InteractableOwner;                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InteractionLocation;                               // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MoveToLocation;                                    // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInteractableDataContainer) == 0x000008, "Wrong alignment on FInteractableDataContainer");
static_assert(sizeof(FInteractableDataContainer) == 0x000028, "Wrong size on FInteractableDataContainer");
static_assert(offsetof(FInteractableDataContainer, Interactable) == 0x000000, "Member 'FInteractableDataContainer::Interactable' has a wrong offset!");
static_assert(offsetof(FInteractableDataContainer, InteractableOwner) == 0x000008, "Member 'FInteractableDataContainer::InteractableOwner' has a wrong offset!");
static_assert(offsetof(FInteractableDataContainer, InteractionLocation) == 0x00000C, "Member 'FInteractableDataContainer::InteractionLocation' has a wrong offset!");
static_assert(offsetof(FInteractableDataContainer, MoveToLocation) == 0x000018, "Member 'FInteractableDataContainer::MoveToLocation' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMaskPresetConfig
// 0x0010 (0x0010 - 0x0000)
struct FSBZMaskPresetConfig final
{
public:
	class USBZMaskPresetData*                     MaskPresetData;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZMaskPresetData*                     OriginalMaskPresetData;                            // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZMaskPresetConfig) == 0x000008, "Wrong alignment on FSBZMaskPresetConfig");
static_assert(sizeof(FSBZMaskPresetConfig) == 0x000010, "Wrong size on FSBZMaskPresetConfig");
static_assert(offsetof(FSBZMaskPresetConfig, MaskPresetData) == 0x000000, "Member 'FSBZMaskPresetConfig::MaskPresetData' has a wrong offset!");
static_assert(offsetof(FSBZMaskPresetConfig, OriginalMaskPresetData) == 0x000008, "Member 'FSBZMaskPresetConfig::OriginalMaskPresetData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMaskInventorySlot
// 0x00A8 (0x00D0 - 0x0028)
struct FSBZMaskInventorySlot final : public FSBZInventorySlot
{
public:
	struct FGuid                                  MaskInSlotEntitlementId;                           // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MaskInSlotAccelByteItemSku;                        // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZItemInventorySlotType                     MaskInventorySlotType;                             // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSBZMaskConfig                         MaskConfig;                                        // 0x0050(0x0070)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FSBZMaskPresetConfig                   MaskPresetConfig;                                  // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZMaskInventorySlot) == 0x000008, "Wrong alignment on FSBZMaskInventorySlot");
static_assert(sizeof(FSBZMaskInventorySlot) == 0x0000D0, "Wrong size on FSBZMaskInventorySlot");
static_assert(offsetof(FSBZMaskInventorySlot, MaskInSlotEntitlementId) == 0x000028, "Member 'FSBZMaskInventorySlot::MaskInSlotEntitlementId' has a wrong offset!");
static_assert(offsetof(FSBZMaskInventorySlot, MaskInSlotAccelByteItemSku) == 0x000038, "Member 'FSBZMaskInventorySlot::MaskInSlotAccelByteItemSku' has a wrong offset!");
static_assert(offsetof(FSBZMaskInventorySlot, MaskInventorySlotType) == 0x000048, "Member 'FSBZMaskInventorySlot::MaskInventorySlotType' has a wrong offset!");
static_assert(offsetof(FSBZMaskInventorySlot, MaskConfig) == 0x000050, "Member 'FSBZMaskInventorySlot::MaskConfig' has a wrong offset!");
static_assert(offsetof(FSBZMaskInventorySlot, MaskPresetConfig) == 0x0000C0, "Member 'FSBZMaskInventorySlot::MaskPresetConfig' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMaskConfigInventorySaveData
// 0x0020 (0x0020 - 0x0000)
struct FSBZMaskConfigInventorySaveData final
{
public:
	TArray<struct FSBZMaskInventorySlot>          MaskConfigSlots;                                   // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FSBZMaskInventorySlot>          CheckedMaskConfigSlots;                            // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZMaskConfigInventorySaveData) == 0x000008, "Wrong alignment on FSBZMaskConfigInventorySaveData");
static_assert(sizeof(FSBZMaskConfigInventorySaveData) == 0x000020, "Wrong size on FSBZMaskConfigInventorySaveData");
static_assert(offsetof(FSBZMaskConfigInventorySaveData, MaskConfigSlots) == 0x000000, "Member 'FSBZMaskConfigInventorySaveData::MaskConfigSlots' has a wrong offset!");
static_assert(offsetof(FSBZMaskConfigInventorySaveData, CheckedMaskConfigSlots) == 0x000010, "Member 'FSBZMaskConfigInventorySaveData::CheckedMaskConfigSlots' has a wrong offset!");

// ScriptStruct Starbreeze.SBZVehicleLights
// 0x0008 (0x0008 - 0x0000)
struct FSBZVehicleLights final
{
public:
	uint8                                         Headlights;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TailLights;                                        // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         FogLights;                                         // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BrakeLights;                                       // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReverseLights;                                     // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TurnLeft;                                          // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TurnRight;                                         // 0x0006(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Broken;                                            // 0x0007(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZVehicleLights) == 0x000001, "Wrong alignment on FSBZVehicleLights");
static_assert(sizeof(FSBZVehicleLights) == 0x000008, "Wrong size on FSBZVehicleLights");
static_assert(offsetof(FSBZVehicleLights, Headlights) == 0x000000, "Member 'FSBZVehicleLights::Headlights' has a wrong offset!");
static_assert(offsetof(FSBZVehicleLights, TailLights) == 0x000001, "Member 'FSBZVehicleLights::TailLights' has a wrong offset!");
static_assert(offsetof(FSBZVehicleLights, FogLights) == 0x000002, "Member 'FSBZVehicleLights::FogLights' has a wrong offset!");
static_assert(offsetof(FSBZVehicleLights, BrakeLights) == 0x000003, "Member 'FSBZVehicleLights::BrakeLights' has a wrong offset!");
static_assert(offsetof(FSBZVehicleLights, ReverseLights) == 0x000004, "Member 'FSBZVehicleLights::ReverseLights' has a wrong offset!");
static_assert(offsetof(FSBZVehicleLights, TurnLeft) == 0x000005, "Member 'FSBZVehicleLights::TurnLeft' has a wrong offset!");
static_assert(offsetof(FSBZVehicleLights, TurnRight) == 0x000006, "Member 'FSBZVehicleLights::TurnRight' has a wrong offset!");
static_assert(offsetof(FSBZVehicleLights, Broken) == 0x000007, "Member 'FSBZVehicleLights::Broken' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAdditiveMoveData
// 0x0198 (0x0198 - 0x0000)
struct FSBZAdditiveMoveData final
{
public:
	struct FRuntimeFloatCurve                     AdditiveMoveAlpha;                                 // 0x0000(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     AdditiveCameraAlpha;                               // 0x0088(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     AdditiveMovePlayRate;                              // 0x0110(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAdditiveMoveData) == 0x000008, "Wrong alignment on FSBZAdditiveMoveData");
static_assert(sizeof(FSBZAdditiveMoveData) == 0x000198, "Wrong size on FSBZAdditiveMoveData");
static_assert(offsetof(FSBZAdditiveMoveData, AdditiveMoveAlpha) == 0x000000, "Member 'FSBZAdditiveMoveData::AdditiveMoveAlpha' has a wrong offset!");
static_assert(offsetof(FSBZAdditiveMoveData, AdditiveCameraAlpha) == 0x000088, "Member 'FSBZAdditiveMoveData::AdditiveCameraAlpha' has a wrong offset!");
static_assert(offsetof(FSBZAdditiveMoveData, AdditiveMovePlayRate) == 0x000110, "Member 'FSBZAdditiveMoveData::AdditiveMovePlayRate' has a wrong offset!");

// ScriptStruct Starbreeze.SBZFootPlacementCachedData
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FSBZFootPlacementCachedData final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZFootPlacementCachedData) == 0x000004, "Wrong alignment on FSBZFootPlacementCachedData");
static_assert(sizeof(FSBZFootPlacementCachedData) == 0x000014, "Wrong size on FSBZFootPlacementCachedData");

// ScriptStruct Starbreeze.SBZTurnAnimationContainer
// 0x0020 (0x0020 - 0x0000)
struct FSBZTurnAnimationContainer final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      TurnAnimationStand;                                // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      TurnAnimationCrouch;                               // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZTurnAnimationContainer) == 0x000008, "Wrong alignment on FSBZTurnAnimationContainer");
static_assert(sizeof(FSBZTurnAnimationContainer) == 0x000020, "Wrong size on FSBZTurnAnimationContainer");
static_assert(offsetof(FSBZTurnAnimationContainer, TurnAnimationStand) == 0x000008, "Member 'FSBZTurnAnimationContainer::TurnAnimationStand' has a wrong offset!");
static_assert(offsetof(FSBZTurnAnimationContainer, TurnAnimationCrouch) == 0x000010, "Member 'FSBZTurnAnimationContainer::TurnAnimationCrouch' has a wrong offset!");

// ScriptStruct Starbreeze.SBZBoneAnimContraint
// 0x001C (0x001C - 0x0000)
struct FSBZBoneAnimContraint final
{
public:
	class FName                                   BoneToConstrain;                                   // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZBoneAnimConstraintType                    ConstraintType;                                    // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneToFollow;                                      // 0x0010(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZBoneAnimContraint) == 0x000004, "Wrong alignment on FSBZBoneAnimContraint");
static_assert(sizeof(FSBZBoneAnimContraint) == 0x00001C, "Wrong size on FSBZBoneAnimContraint");
static_assert(offsetof(FSBZBoneAnimContraint, BoneToConstrain) == 0x000000, "Member 'FSBZBoneAnimContraint::BoneToConstrain' has a wrong offset!");
static_assert(offsetof(FSBZBoneAnimContraint, ConstraintType) == 0x00000C, "Member 'FSBZBoneAnimContraint::ConstraintType' has a wrong offset!");
static_assert(offsetof(FSBZBoneAnimContraint, BoneToFollow) == 0x000010, "Member 'FSBZBoneAnimContraint::BoneToFollow' has a wrong offset!");

// ScriptStruct Starbreeze.SBZLocalGasLocation
// 0x0008 (0x0014 - 0x000C)
struct FSBZLocalGasLocation final : public FFastArraySerializerItem
{
public:
	int16                                         X;                                                 // 0x000C(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         Y;                                                 // 0x000E(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         Z;                                                 // 0x0010(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZLocalGasLocation) == 0x000004, "Wrong alignment on FSBZLocalGasLocation");
static_assert(sizeof(FSBZLocalGasLocation) == 0x000014, "Wrong size on FSBZLocalGasLocation");
static_assert(offsetof(FSBZLocalGasLocation, X) == 0x00000C, "Member 'FSBZLocalGasLocation::X' has a wrong offset!");
static_assert(offsetof(FSBZLocalGasLocation, Y) == 0x00000E, "Member 'FSBZLocalGasLocation::Y' has a wrong offset!");
static_assert(offsetof(FSBZLocalGasLocation, Z) == 0x000010, "Member 'FSBZLocalGasLocation::Z' has a wrong offset!");

// ScriptStruct Starbreeze.SBZLocalGasLocations
// 0x0010 (0x0118 - 0x0108)
struct FSBZLocalGasLocations final : public FFastArraySerializer
{
public:
	TArray<struct FSBZLocalGasLocation>           Locations;                                         // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZLocalGasLocations) == 0x000008, "Wrong alignment on FSBZLocalGasLocations");
static_assert(sizeof(FSBZLocalGasLocations) == 0x000118, "Wrong size on FSBZLocalGasLocations");
static_assert(offsetof(FSBZLocalGasLocations, Locations) == 0x000108, "Member 'FSBZLocalGasLocations::Locations' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPlayerInEscapeChangedEvent
// 0x0008 (0x0008 - 0x0000)
struct FSBZPlayerInEscapeChangedEvent final : public FSBZGameEventStructBase
{
public:
	int32                                         Inside;                                            // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Total;                                             // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPlayerInEscapeChangedEvent) == 0x000004, "Wrong alignment on FSBZPlayerInEscapeChangedEvent");
static_assert(sizeof(FSBZPlayerInEscapeChangedEvent) == 0x000008, "Wrong size on FSBZPlayerInEscapeChangedEvent");
static_assert(offsetof(FSBZPlayerInEscapeChangedEvent, Inside) == 0x000000, "Member 'FSBZPlayerInEscapeChangedEvent::Inside' has a wrong offset!");
static_assert(offsetof(FSBZPlayerInEscapeChangedEvent, Total) == 0x000004, "Member 'FSBZPlayerInEscapeChangedEvent::Total' has a wrong offset!");

// ScriptStruct Starbreeze.SBZEquippableRuntime
// 0x0048 (0x0048 - 0x0000)
struct FSBZEquippableRuntime final
{
public:
	TArray<class USBZEquippableGadgetData*>       GadgetDataArray;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
	TArray<class ASBZGadget*>                     GadgetActorArray;                                  // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USBZWeaponSightData*>            SightArray;                                        // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
	int32                                         CurrentSightIndex;                                 // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USBZWeaponSightData*                    CurrentSightData;                                  // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZEquippableRuntime) == 0x000008, "Wrong alignment on FSBZEquippableRuntime");
static_assert(sizeof(FSBZEquippableRuntime) == 0x000048, "Wrong size on FSBZEquippableRuntime");
static_assert(offsetof(FSBZEquippableRuntime, GadgetDataArray) == 0x000000, "Member 'FSBZEquippableRuntime::GadgetDataArray' has a wrong offset!");
static_assert(offsetof(FSBZEquippableRuntime, GadgetActorArray) == 0x000010, "Member 'FSBZEquippableRuntime::GadgetActorArray' has a wrong offset!");
static_assert(offsetof(FSBZEquippableRuntime, SightArray) == 0x000028, "Member 'FSBZEquippableRuntime::SightArray' has a wrong offset!");
static_assert(offsetof(FSBZEquippableRuntime, CurrentSightIndex) == 0x000038, "Member 'FSBZEquippableRuntime::CurrentSightIndex' has a wrong offset!");
static_assert(offsetof(FSBZEquippableRuntime, CurrentSightData) == 0x000040, "Member 'FSBZEquippableRuntime::CurrentSightData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSurfaceSoundEvents
// 0x00B0 (0x00B0 - 0x0000)
struct FSBZSurfaceSoundEvents final
{
public:
	class UAkAudioEvent*                          Footstep;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          Sliding;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          SlidingCancel;                                     // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          Mantling;                                          // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          StepUp;                                            // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          ProjectileHit;                                     // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          ThrowableProjectileHit;                            // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          ThrowableProjectileBounceHit;                      // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          MeleeHit;                                          // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          ExplosionHit;                                      // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          ObjectImpact;                                      // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          ObjectRolling;                                     // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          DebrisImpact;                                      // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          DebrisRolling;                                     // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          ThrowableImpact;                                   // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          BagItemImpact;                                     // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkRtpc*                                ObjectImpactRtpc;                                  // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkRtpc*                                ObjectRollingRtpc;                                 // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkRtpc*                                MeleeHitRtpc;                                      // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkRtpc*                                DebrisImpactRtpc;                                  // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkRtpc*                                DebrisRollingRtpc;                                 // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkRtpc*                                ThrowableImpactRtpc;                               // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSurfaceSoundEvents) == 0x000008, "Wrong alignment on FSBZSurfaceSoundEvents");
static_assert(sizeof(FSBZSurfaceSoundEvents) == 0x0000B0, "Wrong size on FSBZSurfaceSoundEvents");
static_assert(offsetof(FSBZSurfaceSoundEvents, Footstep) == 0x000000, "Member 'FSBZSurfaceSoundEvents::Footstep' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceSoundEvents, Sliding) == 0x000008, "Member 'FSBZSurfaceSoundEvents::Sliding' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceSoundEvents, SlidingCancel) == 0x000010, "Member 'FSBZSurfaceSoundEvents::SlidingCancel' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceSoundEvents, Mantling) == 0x000018, "Member 'FSBZSurfaceSoundEvents::Mantling' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceSoundEvents, StepUp) == 0x000020, "Member 'FSBZSurfaceSoundEvents::StepUp' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceSoundEvents, ProjectileHit) == 0x000028, "Member 'FSBZSurfaceSoundEvents::ProjectileHit' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceSoundEvents, ThrowableProjectileHit) == 0x000030, "Member 'FSBZSurfaceSoundEvents::ThrowableProjectileHit' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceSoundEvents, ThrowableProjectileBounceHit) == 0x000038, "Member 'FSBZSurfaceSoundEvents::ThrowableProjectileBounceHit' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceSoundEvents, MeleeHit) == 0x000040, "Member 'FSBZSurfaceSoundEvents::MeleeHit' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceSoundEvents, ExplosionHit) == 0x000048, "Member 'FSBZSurfaceSoundEvents::ExplosionHit' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceSoundEvents, ObjectImpact) == 0x000050, "Member 'FSBZSurfaceSoundEvents::ObjectImpact' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceSoundEvents, ObjectRolling) == 0x000058, "Member 'FSBZSurfaceSoundEvents::ObjectRolling' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceSoundEvents, DebrisImpact) == 0x000060, "Member 'FSBZSurfaceSoundEvents::DebrisImpact' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceSoundEvents, DebrisRolling) == 0x000068, "Member 'FSBZSurfaceSoundEvents::DebrisRolling' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceSoundEvents, ThrowableImpact) == 0x000070, "Member 'FSBZSurfaceSoundEvents::ThrowableImpact' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceSoundEvents, BagItemImpact) == 0x000078, "Member 'FSBZSurfaceSoundEvents::BagItemImpact' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceSoundEvents, ObjectImpactRtpc) == 0x000080, "Member 'FSBZSurfaceSoundEvents::ObjectImpactRtpc' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceSoundEvents, ObjectRollingRtpc) == 0x000088, "Member 'FSBZSurfaceSoundEvents::ObjectRollingRtpc' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceSoundEvents, MeleeHitRtpc) == 0x000090, "Member 'FSBZSurfaceSoundEvents::MeleeHitRtpc' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceSoundEvents, DebrisImpactRtpc) == 0x000098, "Member 'FSBZSurfaceSoundEvents::DebrisImpactRtpc' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceSoundEvents, DebrisRollingRtpc) == 0x0000A0, "Member 'FSBZSurfaceSoundEvents::DebrisRollingRtpc' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceSoundEvents, ThrowableImpactRtpc) == 0x0000A8, "Member 'FSBZSurfaceSoundEvents::ThrowableImpactRtpc' has a wrong offset!");

// ScriptStruct Starbreeze.SBZQueuedAbilityData
// 0x0010 (0x0010 - 0x0000)
struct FSBZQueuedAbilityData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USBZGameplayAbility*                    CDO;                                               // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZQueuedAbilityData) == 0x000008, "Wrong alignment on FSBZQueuedAbilityData");
static_assert(sizeof(FSBZQueuedAbilityData) == 0x000010, "Wrong size on FSBZQueuedAbilityData");
static_assert(offsetof(FSBZQueuedAbilityData, CDO) == 0x000008, "Member 'FSBZQueuedAbilityData::CDO' has a wrong offset!");

// ScriptStruct Starbreeze.SBZChatMessage
// 0x00A8 (0x00A8 - 0x0000)
struct FSBZChatMessage final
{
public:
	ESBZChatType                                  Type;                                              // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FromString;                                        // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ToString;                                          // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FromId;                                            // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ToId;                                              // 0x0038(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message;                                           // 0x0048(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUniqueNetIdRepl                       From;                                              // 0x0058(0x0028)(BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUniqueNetIdRepl                       To;                                                // 0x0080(0x0028)(BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZChatMessage) == 0x000008, "Wrong alignment on FSBZChatMessage");
static_assert(sizeof(FSBZChatMessage) == 0x0000A8, "Wrong size on FSBZChatMessage");
static_assert(offsetof(FSBZChatMessage, Type) == 0x000000, "Member 'FSBZChatMessage::Type' has a wrong offset!");
static_assert(offsetof(FSBZChatMessage, FromString) == 0x000008, "Member 'FSBZChatMessage::FromString' has a wrong offset!");
static_assert(offsetof(FSBZChatMessage, ToString) == 0x000018, "Member 'FSBZChatMessage::ToString' has a wrong offset!");
static_assert(offsetof(FSBZChatMessage, FromId) == 0x000028, "Member 'FSBZChatMessage::FromId' has a wrong offset!");
static_assert(offsetof(FSBZChatMessage, ToId) == 0x000038, "Member 'FSBZChatMessage::ToId' has a wrong offset!");
static_assert(offsetof(FSBZChatMessage, Message) == 0x000048, "Member 'FSBZChatMessage::Message' has a wrong offset!");
static_assert(offsetof(FSBZChatMessage, From) == 0x000058, "Member 'FSBZChatMessage::From' has a wrong offset!");
static_assert(offsetof(FSBZChatMessage, To) == 0x000080, "Member 'FSBZChatMessage::To' has a wrong offset!");

// ScriptStruct Starbreeze.SBZThreeWayBlendInstance
// 0x0010 (0x0010 - 0x0000)
struct FSBZThreeWayBlendInstance final
{
public:
	class UAnimSequence*                          Animation;                                         // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZThreeWayBlendInstance) == 0x000008, "Wrong alignment on FSBZThreeWayBlendInstance");
static_assert(sizeof(FSBZThreeWayBlendInstance) == 0x000010, "Wrong size on FSBZThreeWayBlendInstance");
static_assert(offsetof(FSBZThreeWayBlendInstance, Animation) == 0x000000, "Member 'FSBZThreeWayBlendInstance::Animation' has a wrong offset!");
static_assert(offsetof(FSBZThreeWayBlendInstance, Alpha) == 0x000008, "Member 'FSBZThreeWayBlendInstance::Alpha' has a wrong offset!");

// ScriptStruct Starbreeze.SBZReplicatedMontage
// 0x0010 (0x0010 - 0x0000)
struct FSBZReplicatedMontage final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Position;                                          // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZReplicatedMontage) == 0x000008, "Wrong alignment on FSBZReplicatedMontage");
static_assert(sizeof(FSBZReplicatedMontage) == 0x000010, "Wrong size on FSBZReplicatedMontage");
static_assert(offsetof(FSBZReplicatedMontage, Montage) == 0x000000, "Member 'FSBZReplicatedMontage::Montage' has a wrong offset!");
static_assert(offsetof(FSBZReplicatedMontage, Position) == 0x000008, "Member 'FSBZReplicatedMontage::Position' has a wrong offset!");

// ScriptStruct Starbreeze.SBZHeistLevelWithOwnership
// 0x0038 (0x0038 - 0x0000)
struct FSBZHeistLevelWithOwnership
{
public:
	struct FSoftObjectPath                        LevelPath;                                         // 0x0000(0x0020)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOwned;                                          // 0x0020(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsQuickplaySelectableLevel;                       // 0x0021(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FirstPlatformPurchaseUrl;                          // 0x0028(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZHeistLevelWithOwnership) == 0x000008, "Wrong alignment on FSBZHeistLevelWithOwnership");
static_assert(sizeof(FSBZHeistLevelWithOwnership) == 0x000038, "Wrong size on FSBZHeistLevelWithOwnership");
static_assert(offsetof(FSBZHeistLevelWithOwnership, LevelPath) == 0x000000, "Member 'FSBZHeistLevelWithOwnership::LevelPath' has a wrong offset!");
static_assert(offsetof(FSBZHeistLevelWithOwnership, bIsOwned) == 0x000020, "Member 'FSBZHeistLevelWithOwnership::bIsOwned' has a wrong offset!");
static_assert(offsetof(FSBZHeistLevelWithOwnership, bIsQuickplaySelectableLevel) == 0x000021, "Member 'FSBZHeistLevelWithOwnership::bIsQuickplaySelectableLevel' has a wrong offset!");
static_assert(offsetof(FSBZHeistLevelWithOwnership, FirstPlatformPurchaseUrl) == 0x000028, "Member 'FSBZHeistLevelWithOwnership::FirstPlatformPurchaseUrl' has a wrong offset!");

// ScriptStruct Starbreeze.SBZHeistCollectionWithOwnership
// 0x0030 (0x0030 - 0x0000)
struct FSBZHeistCollectionWithOwnership final
{
public:
	class FText                                   HeistCollectionName;                               // 0x0000(0x0018)(Transient, NativeAccessSpecifierPublic)
	TArray<struct FSBZHeistLevelWithOwnership>    LevelArray;                                        // 0x0018(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	bool                                          bContainsStoryModeContent;                         // 0x0028(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZHeistCollectionWithOwnership) == 0x000008, "Wrong alignment on FSBZHeistCollectionWithOwnership");
static_assert(sizeof(FSBZHeistCollectionWithOwnership) == 0x000030, "Wrong size on FSBZHeistCollectionWithOwnership");
static_assert(offsetof(FSBZHeistCollectionWithOwnership, HeistCollectionName) == 0x000000, "Member 'FSBZHeistCollectionWithOwnership::HeistCollectionName' has a wrong offset!");
static_assert(offsetof(FSBZHeistCollectionWithOwnership, LevelArray) == 0x000018, "Member 'FSBZHeistCollectionWithOwnership::LevelArray' has a wrong offset!");
static_assert(offsetof(FSBZHeistCollectionWithOwnership, bContainsStoryModeContent) == 0x000028, "Member 'FSBZHeistCollectionWithOwnership::bContainsStoryModeContent' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSystemChatEvent
// 0x0010 (0x0010 - 0x0000)
struct FSBZSystemChatEvent final : public FSBZGameEventStructBase
{
public:
	class FString                                 Message;                                           // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSystemChatEvent) == 0x000008, "Wrong alignment on FSBZSystemChatEvent");
static_assert(sizeof(FSBZSystemChatEvent) == 0x000010, "Wrong size on FSBZSystemChatEvent");
static_assert(offsetof(FSBZSystemChatEvent, Message) == 0x000000, "Member 'FSBZSystemChatEvent::Message' has a wrong offset!");

// ScriptStruct Starbreeze.SBZFacialAnimationContainer
// 0x0010 (0x0010 - 0x0000)
struct FSBZFacialAnimationContainer final
{
public:
	TArray<class UAnimSequence*>                  Animations;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZFacialAnimationContainer) == 0x000008, "Wrong alignment on FSBZFacialAnimationContainer");
static_assert(sizeof(FSBZFacialAnimationContainer) == 0x000010, "Wrong size on FSBZFacialAnimationContainer");
static_assert(offsetof(FSBZFacialAnimationContainer, Animations) == 0x000000, "Member 'FSBZFacialAnimationContainer::Animations' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCustomPrimitiveData
// 0x00E0 (0x00E0 - 0x0000)
struct FSBZCustomPrimitiveData final
{
public:
	float                                         Data[0x24];                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      MorphTargets;                                      // 0x0090(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZCustomPrimitiveData) == 0x000008, "Wrong alignment on FSBZCustomPrimitiveData");
static_assert(sizeof(FSBZCustomPrimitiveData) == 0x0000E0, "Wrong size on FSBZCustomPrimitiveData");
static_assert(offsetof(FSBZCustomPrimitiveData, Data) == 0x000000, "Member 'FSBZCustomPrimitiveData::Data' has a wrong offset!");
static_assert(offsetof(FSBZCustomPrimitiveData, MorphTargets) == 0x000090, "Member 'FSBZCustomPrimitiveData::MorphTargets' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPhoneme
// 0x0014 (0x0014 - 0x0000)
struct FSBZPhoneme final
{
public:
	uint16                                        BlendInStartTime;                                  // 0x0000(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BlendInStartValue;                                 // 0x0002(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        BlendInEndTime;                                    // 0x0004(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BlendInEndValue;                                   // 0x0006(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7[0x1];                                        // 0x0007(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        ControlStartTime;                                  // 0x0008(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ControlStartValue;                                 // 0x000A(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        BlendOutStartTime;                                 // 0x000C(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        BlendOutEndTime;                                   // 0x000E(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BlendOutStartValue;                                // 0x0010(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BlendOutEndValue;                                  // 0x0011(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZPhonemeType                               Phoneme;                                           // 0x0012(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZPhoneme) == 0x000002, "Wrong alignment on FSBZPhoneme");
static_assert(sizeof(FSBZPhoneme) == 0x000014, "Wrong size on FSBZPhoneme");
static_assert(offsetof(FSBZPhoneme, BlendInStartTime) == 0x000000, "Member 'FSBZPhoneme::BlendInStartTime' has a wrong offset!");
static_assert(offsetof(FSBZPhoneme, BlendInStartValue) == 0x000002, "Member 'FSBZPhoneme::BlendInStartValue' has a wrong offset!");
static_assert(offsetof(FSBZPhoneme, BlendInEndTime) == 0x000004, "Member 'FSBZPhoneme::BlendInEndTime' has a wrong offset!");
static_assert(offsetof(FSBZPhoneme, BlendInEndValue) == 0x000006, "Member 'FSBZPhoneme::BlendInEndValue' has a wrong offset!");
static_assert(offsetof(FSBZPhoneme, ControlStartTime) == 0x000008, "Member 'FSBZPhoneme::ControlStartTime' has a wrong offset!");
static_assert(offsetof(FSBZPhoneme, ControlStartValue) == 0x00000A, "Member 'FSBZPhoneme::ControlStartValue' has a wrong offset!");
static_assert(offsetof(FSBZPhoneme, BlendOutStartTime) == 0x00000C, "Member 'FSBZPhoneme::BlendOutStartTime' has a wrong offset!");
static_assert(offsetof(FSBZPhoneme, BlendOutEndTime) == 0x00000E, "Member 'FSBZPhoneme::BlendOutEndTime' has a wrong offset!");
static_assert(offsetof(FSBZPhoneme, BlendOutStartValue) == 0x000010, "Member 'FSBZPhoneme::BlendOutStartValue' has a wrong offset!");
static_assert(offsetof(FSBZPhoneme, BlendOutEndValue) == 0x000011, "Member 'FSBZPhoneme::BlendOutEndValue' has a wrong offset!");
static_assert(offsetof(FSBZPhoneme, Phoneme) == 0x000012, "Member 'FSBZPhoneme::Phoneme' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSuitPresetConfig
// 0x0010 (0x0010 - 0x0000)
struct FSBZSuitPresetConfig final
{
public:
	class USBZSuitPresetData*                     SuitPresetData;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZSuitPresetData*                     OriginalSuitPresetData;                            // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSuitPresetConfig) == 0x000008, "Wrong alignment on FSBZSuitPresetConfig");
static_assert(sizeof(FSBZSuitPresetConfig) == 0x000010, "Wrong size on FSBZSuitPresetConfig");
static_assert(offsetof(FSBZSuitPresetConfig, SuitPresetData) == 0x000000, "Member 'FSBZSuitPresetConfig::SuitPresetData' has a wrong offset!");
static_assert(offsetof(FSBZSuitPresetConfig, OriginalSuitPresetData) == 0x000008, "Member 'FSBZSuitPresetConfig::OriginalSuitPresetData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZClientSaveChallengeV2
// 0x0010 (0x0010 - 0x0000)
struct FSBZClientSaveChallengeV2 final
{
public:
	class FName                                   ChallengeId;                                       // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ChallengeCompleted;                                // 0x000C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZClientSaveChallengeV2) == 0x000004, "Wrong alignment on FSBZClientSaveChallengeV2");
static_assert(sizeof(FSBZClientSaveChallengeV2) == 0x000010, "Wrong size on FSBZClientSaveChallengeV2");
static_assert(offsetof(FSBZClientSaveChallengeV2, ChallengeId) == 0x000000, "Member 'FSBZClientSaveChallengeV2::ChallengeId' has a wrong offset!");
static_assert(offsetof(FSBZClientSaveChallengeV2, ChallengeCompleted) == 0x00000C, "Member 'FSBZClientSaveChallengeV2::ChallengeCompleted' has a wrong offset!");

// ScriptStruct Starbreeze.SBZDailyChallenge
// 0x0014 (0x0014 - 0x0000)
struct FSBZDailyChallenge final
{
public:
	class FName                                   ChallengeId;                                       // 0x0000(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CreationObjectiveStartStatValue;                   // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ChallengeCompleted;                                // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZDailyChallenge) == 0x000004, "Wrong alignment on FSBZDailyChallenge");
static_assert(sizeof(FSBZDailyChallenge) == 0x000014, "Wrong size on FSBZDailyChallenge");
static_assert(offsetof(FSBZDailyChallenge, ChallengeId) == 0x000000, "Member 'FSBZDailyChallenge::ChallengeId' has a wrong offset!");
static_assert(offsetof(FSBZDailyChallenge, CreationObjectiveStartStatValue) == 0x00000C, "Member 'FSBZDailyChallenge::CreationObjectiveStartStatValue' has a wrong offset!");
static_assert(offsetof(FSBZDailyChallenge, ChallengeCompleted) == 0x000010, "Member 'FSBZDailyChallenge::ChallengeCompleted' has a wrong offset!");

// ScriptStruct Starbreeze.SBZDailyChallengeBlock
// 0x0010 (0x0010 - 0x0000)
struct FSBZDailyChallengeBlock final
{
public:
	TArray<struct FSBZDailyChallenge>             ChallengeArray;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZDailyChallengeBlock) == 0x000008, "Wrong alignment on FSBZDailyChallengeBlock");
static_assert(sizeof(FSBZDailyChallengeBlock) == 0x000010, "Wrong size on FSBZDailyChallengeBlock");
static_assert(offsetof(FSBZDailyChallengeBlock, ChallengeArray) == 0x000000, "Member 'FSBZDailyChallengeBlock::ChallengeArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZProgressionSaveChallengesData
// 0x0038 (0x0038 - 0x0000)
struct FSBZProgressionSaveChallengesData final
{
public:
	TArray<struct FSBZClientSaveChallengeV2>      SavedChallenges;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	bool                                          FetchedFromAPI;                                    // 0x0010(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSBZDailyChallengeBlock                DailyChallengeBlockMap;                            // 0x0018(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDateTime                              DailyChallengePullDate;                            // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RerollAvailable;                                   // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZProgressionSaveChallengesData) == 0x000008, "Wrong alignment on FSBZProgressionSaveChallengesData");
static_assert(sizeof(FSBZProgressionSaveChallengesData) == 0x000038, "Wrong size on FSBZProgressionSaveChallengesData");
static_assert(offsetof(FSBZProgressionSaveChallengesData, SavedChallenges) == 0x000000, "Member 'FSBZProgressionSaveChallengesData::SavedChallenges' has a wrong offset!");
static_assert(offsetof(FSBZProgressionSaveChallengesData, FetchedFromAPI) == 0x000010, "Member 'FSBZProgressionSaveChallengesData::FetchedFromAPI' has a wrong offset!");
static_assert(offsetof(FSBZProgressionSaveChallengesData, DailyChallengeBlockMap) == 0x000018, "Member 'FSBZProgressionSaveChallengesData::DailyChallengeBlockMap' has a wrong offset!");
static_assert(offsetof(FSBZProgressionSaveChallengesData, DailyChallengePullDate) == 0x000028, "Member 'FSBZProgressionSaveChallengesData::DailyChallengePullDate' has a wrong offset!");
static_assert(offsetof(FSBZProgressionSaveChallengesData, RerollAvailable) == 0x000030, "Member 'FSBZProgressionSaveChallengesData::RerollAvailable' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPlayerStateAddedEvent
// 0x0008 (0x0008 - 0x0000)
struct FSBZPlayerStateAddedEvent final : public FSBZGameEventStructBase
{
public:
	class APlayerState*                           PlayerState;                                       // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPlayerStateAddedEvent) == 0x000008, "Wrong alignment on FSBZPlayerStateAddedEvent");
static_assert(sizeof(FSBZPlayerStateAddedEvent) == 0x000008, "Wrong size on FSBZPlayerStateAddedEvent");
static_assert(offsetof(FSBZPlayerStateAddedEvent, PlayerState) == 0x000000, "Member 'FSBZPlayerStateAddedEvent::PlayerState' has a wrong offset!");

// ScriptStruct Starbreeze.SBZEndMissionRequestData
// 0x0008 (0x0008 - 0x0000)
struct FSBZEndMissionRequestData final
{
public:
	ESBZEndMissionResult                          MissionResult;                                     // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OutroVariation;                                    // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZEndMissionRequestData) == 0x000004, "Wrong alignment on FSBZEndMissionRequestData");
static_assert(sizeof(FSBZEndMissionRequestData) == 0x000008, "Wrong size on FSBZEndMissionRequestData");
static_assert(offsetof(FSBZEndMissionRequestData, MissionResult) == 0x000000, "Member 'FSBZEndMissionRequestData::MissionResult' has a wrong offset!");
static_assert(offsetof(FSBZEndMissionRequestData, OutroVariation) == 0x000004, "Member 'FSBZEndMissionRequestData::OutroVariation' has a wrong offset!");

// ScriptStruct Starbreeze.SBZBagHandle
// 0x0010 (0x0010 - 0x0000)
struct FSBZBagHandle final
{
public:
	int32                                         Id;                                                // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USBZBagType*                            BagType;                                           // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZBagHandle) == 0x000008, "Wrong alignment on FSBZBagHandle");
static_assert(sizeof(FSBZBagHandle) == 0x000010, "Wrong size on FSBZBagHandle");
static_assert(offsetof(FSBZBagHandle, Id) == 0x000000, "Member 'FSBZBagHandle::Id' has a wrong offset!");
static_assert(offsetof(FSBZBagHandle, BagType) == 0x000008, "Member 'FSBZBagHandle::BagType' has a wrong offset!");

// ScriptStruct Starbreeze.SBZVelocityTrackedComponentData
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x10) FSBZVelocityTrackedComponentData final
{
public:
	uint8                                         Pad_0[0x60];                                       // 0x0000(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZVelocityTrackedComponentData) == 0x000010, "Wrong alignment on FSBZVelocityTrackedComponentData");
static_assert(sizeof(FSBZVelocityTrackedComponentData) == 0x000060, "Wrong size on FSBZVelocityTrackedComponentData");

// ScriptStruct Starbreeze.SBZAllowedStanceTransition
// 0x0028 (0x0028 - 0x0000)
struct FSBZAllowedStanceTransition final
{
public:
	ESBZCharacterStance                           PreviousStance;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZCharacterStance                           CurrentStance;                                     // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  BlockingTags;                                      // 0x0008(0x0020)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAllowedStanceTransition) == 0x000008, "Wrong alignment on FSBZAllowedStanceTransition");
static_assert(sizeof(FSBZAllowedStanceTransition) == 0x000028, "Wrong size on FSBZAllowedStanceTransition");
static_assert(offsetof(FSBZAllowedStanceTransition, PreviousStance) == 0x000000, "Member 'FSBZAllowedStanceTransition::PreviousStance' has a wrong offset!");
static_assert(offsetof(FSBZAllowedStanceTransition, CurrentStance) == 0x000001, "Member 'FSBZAllowedStanceTransition::CurrentStance' has a wrong offset!");
static_assert(offsetof(FSBZAllowedStanceTransition, BlockingTags) == 0x000008, "Member 'FSBZAllowedStanceTransition::BlockingTags' has a wrong offset!");

// ScriptStruct Starbreeze.SBZLootTypeData
// 0x0010 (0x0010 - 0x0000)
struct FSBZLootTypeData final
{
public:
	int32                                         LootValue;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxValueForLootType;                               // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InfamyPointValue;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxInfamyPointsForLootType;                        // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZLootTypeData) == 0x000004, "Wrong alignment on FSBZLootTypeData");
static_assert(sizeof(FSBZLootTypeData) == 0x000010, "Wrong size on FSBZLootTypeData");
static_assert(offsetof(FSBZLootTypeData, LootValue) == 0x000000, "Member 'FSBZLootTypeData::LootValue' has a wrong offset!");
static_assert(offsetof(FSBZLootTypeData, MaxValueForLootType) == 0x000004, "Member 'FSBZLootTypeData::MaxValueForLootType' has a wrong offset!");
static_assert(offsetof(FSBZLootTypeData, InfamyPointValue) == 0x000008, "Member 'FSBZLootTypeData::InfamyPointValue' has a wrong offset!");
static_assert(offsetof(FSBZLootTypeData, MaxInfamyPointsForLootType) == 0x00000C, "Member 'FSBZLootTypeData::MaxInfamyPointsForLootType' has a wrong offset!");

// ScriptStruct Starbreeze.SBZLootValueArray
// 0x0020 (0x0020 - 0x0000)
struct FSBZLootValueArray final
{
public:
	class FString                                 LootName;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSBZLootTypeData>               LootValueDifficultyArray;                          // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZLootValueArray) == 0x000008, "Wrong alignment on FSBZLootValueArray");
static_assert(sizeof(FSBZLootValueArray) == 0x000020, "Wrong size on FSBZLootValueArray");
static_assert(offsetof(FSBZLootValueArray, LootName) == 0x000000, "Member 'FSBZLootValueArray::LootName' has a wrong offset!");
static_assert(offsetof(FSBZLootValueArray, LootValueDifficultyArray) == 0x000010, "Member 'FSBZLootValueArray::LootValueDifficultyArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZOnlineSessionParams
// 0x0070 (0x0070 - 0x0000)
struct FSBZOnlineSessionParams final
{
public:
	ESBZOnlineSessionPhase                        SessionPhase;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsParty;                                          // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZOnlineJoinType                            JoinType;                                          // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LevelIdx;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DifficultyIdx;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SecurityCompaniesList;                             // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDebugSession;                                   // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FreeSlots;                                         // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreFullSession;                                // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	ESBZServerSessionType                         SessionType;                                       // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NetworkVersion;                                    // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MatchMakingGroup;                                  // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MatchMakingGroupLabel;                             // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HostingIpAddress;                                  // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PingInMs;                                          // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZOnlineSessionParams) == 0x000008, "Wrong alignment on FSBZOnlineSessionParams");
static_assert(sizeof(FSBZOnlineSessionParams) == 0x000070, "Wrong size on FSBZOnlineSessionParams");
static_assert(offsetof(FSBZOnlineSessionParams, SessionPhase) == 0x000000, "Member 'FSBZOnlineSessionParams::SessionPhase' has a wrong offset!");
static_assert(offsetof(FSBZOnlineSessionParams, bIsParty) == 0x000001, "Member 'FSBZOnlineSessionParams::bIsParty' has a wrong offset!");
static_assert(offsetof(FSBZOnlineSessionParams, JoinType) == 0x000002, "Member 'FSBZOnlineSessionParams::JoinType' has a wrong offset!");
static_assert(offsetof(FSBZOnlineSessionParams, LevelIdx) == 0x000004, "Member 'FSBZOnlineSessionParams::LevelIdx' has a wrong offset!");
static_assert(offsetof(FSBZOnlineSessionParams, DifficultyIdx) == 0x000008, "Member 'FSBZOnlineSessionParams::DifficultyIdx' has a wrong offset!");
static_assert(offsetof(FSBZOnlineSessionParams, SecurityCompaniesList) == 0x000010, "Member 'FSBZOnlineSessionParams::SecurityCompaniesList' has a wrong offset!");
static_assert(offsetof(FSBZOnlineSessionParams, bIsDebugSession) == 0x000020, "Member 'FSBZOnlineSessionParams::bIsDebugSession' has a wrong offset!");
static_assert(offsetof(FSBZOnlineSessionParams, FreeSlots) == 0x000024, "Member 'FSBZOnlineSessionParams::FreeSlots' has a wrong offset!");
static_assert(offsetof(FSBZOnlineSessionParams, bIgnoreFullSession) == 0x000028, "Member 'FSBZOnlineSessionParams::bIgnoreFullSession' has a wrong offset!");
static_assert(offsetof(FSBZOnlineSessionParams, SessionType) == 0x000030, "Member 'FSBZOnlineSessionParams::SessionType' has a wrong offset!");
static_assert(offsetof(FSBZOnlineSessionParams, NetworkVersion) == 0x000034, "Member 'FSBZOnlineSessionParams::NetworkVersion' has a wrong offset!");
static_assert(offsetof(FSBZOnlineSessionParams, MatchMakingGroup) == 0x000038, "Member 'FSBZOnlineSessionParams::MatchMakingGroup' has a wrong offset!");
static_assert(offsetof(FSBZOnlineSessionParams, MatchMakingGroupLabel) == 0x000048, "Member 'FSBZOnlineSessionParams::MatchMakingGroupLabel' has a wrong offset!");
static_assert(offsetof(FSBZOnlineSessionParams, HostingIpAddress) == 0x000058, "Member 'FSBZOnlineSessionParams::HostingIpAddress' has a wrong offset!");
static_assert(offsetof(FSBZOnlineSessionParams, PingInMs) == 0x000068, "Member 'FSBZOnlineSessionParams::PingInMs' has a wrong offset!");

// ScriptStruct Starbreeze.SBZOnlineSearchResult
// 0x0198 (0x0198 - 0x0000)
struct FSBZOnlineSearchResult final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SessionId;                                         // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x108];                                     // 0x0020(0x0108)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSBZOnlineSessionParams                Parameters;                                        // 0x0128(0x0070)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZOnlineSearchResult) == 0x000008, "Wrong alignment on FSBZOnlineSearchResult");
static_assert(sizeof(FSBZOnlineSearchResult) == 0x000198, "Wrong size on FSBZOnlineSearchResult");
static_assert(offsetof(FSBZOnlineSearchResult, Name) == 0x000000, "Member 'FSBZOnlineSearchResult::Name' has a wrong offset!");
static_assert(offsetof(FSBZOnlineSearchResult, SessionId) == 0x000010, "Member 'FSBZOnlineSearchResult::SessionId' has a wrong offset!");
static_assert(offsetof(FSBZOnlineSearchResult, Parameters) == 0x000128, "Member 'FSBZOnlineSearchResult::Parameters' has a wrong offset!");

// ScriptStruct Starbreeze.SBZChallengeObjectiveInfo
// 0x0010 (0x0010 - 0x0000)
struct FSBZChallengeObjectiveInfo final
{
public:
	ESBZItemProgressionSource                     ItemProgressionSource;                             // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InfamyLevel;                                       // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZSkillLineData*                      SkillLine;                                         // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZChallengeObjectiveInfo) == 0x000008, "Wrong alignment on FSBZChallengeObjectiveInfo");
static_assert(sizeof(FSBZChallengeObjectiveInfo) == 0x000010, "Wrong size on FSBZChallengeObjectiveInfo");
static_assert(offsetof(FSBZChallengeObjectiveInfo, ItemProgressionSource) == 0x000000, "Member 'FSBZChallengeObjectiveInfo::ItemProgressionSource' has a wrong offset!");
static_assert(offsetof(FSBZChallengeObjectiveInfo, InfamyLevel) == 0x000004, "Member 'FSBZChallengeObjectiveInfo::InfamyLevel' has a wrong offset!");
static_assert(offsetof(FSBZChallengeObjectiveInfo, SkillLine) == 0x000008, "Member 'FSBZChallengeObjectiveInfo::SkillLine' has a wrong offset!");

// ScriptStruct Starbreeze.SBZChallengeLock
// 0x0018 (0x0018 - 0x0000)
struct FSBZChallengeLock final
{
public:
	struct FSBZChallengeObjectiveInfo             ChallengeObjectiveInfo;                            // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsLockedByChallenge;                              // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZChallengeLock) == 0x000008, "Wrong alignment on FSBZChallengeLock");
static_assert(sizeof(FSBZChallengeLock) == 0x000018, "Wrong size on FSBZChallengeLock");
static_assert(offsetof(FSBZChallengeLock, ChallengeObjectiveInfo) == 0x000000, "Member 'FSBZChallengeLock::ChallengeObjectiveInfo' has a wrong offset!");
static_assert(offsetof(FSBZChallengeLock, bIsLockedByChallenge) == 0x000010, "Member 'FSBZChallengeLock::bIsLockedByChallenge' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAIUtilityScorerDebugData
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FSBZAIUtilityScorerDebugData final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAIUtilityScorerDebugData) == 0x000008, "Wrong alignment on FSBZAIUtilityScorerDebugData");
static_assert(sizeof(FSBZAIUtilityScorerDebugData) == 0x000030, "Wrong size on FSBZAIUtilityScorerDebugData");

// ScriptStruct Starbreeze.SBZSequentialScatterPlot
// 0x0010 (0x0010 - 0x0000)
struct FSBZSequentialScatterPlot final
{
public:
	TArray<struct FVector2D>                      Points;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSequentialScatterPlot) == 0x000008, "Wrong alignment on FSBZSequentialScatterPlot");
static_assert(sizeof(FSBZSequentialScatterPlot) == 0x000010, "Wrong size on FSBZSequentialScatterPlot");
static_assert(offsetof(FSBZSequentialScatterPlot, Points) == 0x000000, "Member 'FSBZSequentialScatterPlot::Points' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeaponViewKickData
// 0x0140 (0x0140 - 0x0000)
struct FSBZWeaponViewKickData final
{
public:
	float                                         SpeedDeflect;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedRecover;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoverWaitTime;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     DeflectCurve;                                      // 0x0010(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     RecoverCurve;                                      // 0x0098(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSBZSequentialScatterPlot              GraphDisplacementList;                             // 0x0120(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         DisplacementResetTime;                             // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisplacementGraphLoopStart;                        // 0x0134(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisplacementGraphInitialNum;                       // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisplacementHipFireMultiplier;                     // 0x013C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWeaponViewKickData) == 0x000008, "Wrong alignment on FSBZWeaponViewKickData");
static_assert(sizeof(FSBZWeaponViewKickData) == 0x000140, "Wrong size on FSBZWeaponViewKickData");
static_assert(offsetof(FSBZWeaponViewKickData, SpeedDeflect) == 0x000000, "Member 'FSBZWeaponViewKickData::SpeedDeflect' has a wrong offset!");
static_assert(offsetof(FSBZWeaponViewKickData, SpeedRecover) == 0x000004, "Member 'FSBZWeaponViewKickData::SpeedRecover' has a wrong offset!");
static_assert(offsetof(FSBZWeaponViewKickData, RecoverWaitTime) == 0x000008, "Member 'FSBZWeaponViewKickData::RecoverWaitTime' has a wrong offset!");
static_assert(offsetof(FSBZWeaponViewKickData, DeflectCurve) == 0x000010, "Member 'FSBZWeaponViewKickData::DeflectCurve' has a wrong offset!");
static_assert(offsetof(FSBZWeaponViewKickData, RecoverCurve) == 0x000098, "Member 'FSBZWeaponViewKickData::RecoverCurve' has a wrong offset!");
static_assert(offsetof(FSBZWeaponViewKickData, GraphDisplacementList) == 0x000120, "Member 'FSBZWeaponViewKickData::GraphDisplacementList' has a wrong offset!");
static_assert(offsetof(FSBZWeaponViewKickData, DisplacementResetTime) == 0x000130, "Member 'FSBZWeaponViewKickData::DisplacementResetTime' has a wrong offset!");
static_assert(offsetof(FSBZWeaponViewKickData, DisplacementGraphLoopStart) == 0x000134, "Member 'FSBZWeaponViewKickData::DisplacementGraphLoopStart' has a wrong offset!");
static_assert(offsetof(FSBZWeaponViewKickData, DisplacementGraphInitialNum) == 0x000138, "Member 'FSBZWeaponViewKickData::DisplacementGraphInitialNum' has a wrong offset!");
static_assert(offsetof(FSBZWeaponViewKickData, DisplacementHipFireMultiplier) == 0x00013C, "Member 'FSBZWeaponViewKickData::DisplacementHipFireMultiplier' has a wrong offset!");

// ScriptStruct Starbreeze.SBZNamedEquippableEndMissionResultData
// 0x000C (0x0034 - 0x0028)
struct FSBZNamedEquippableEndMissionResultData final : public FSBZEquippableEndMissionResultData
{
public:
	class FName                                   Name;                                              // 0x0028(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZNamedEquippableEndMissionResultData) == 0x000004, "Wrong alignment on FSBZNamedEquippableEndMissionResultData");
static_assert(sizeof(FSBZNamedEquippableEndMissionResultData) == 0x000034, "Wrong size on FSBZNamedEquippableEndMissionResultData");
static_assert(offsetof(FSBZNamedEquippableEndMissionResultData, Name) == 0x000028, "Member 'FSBZNamedEquippableEndMissionResultData::Name' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCharacterEndMissionResultData
// 0x0060 (0x0060 - 0x0000)
struct FSBZCharacterEndMissionResultData
{
public:
	TArray<struct FSBZEquippableEndMissionResultData> EquippableArray;                               // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FSBZNamedEquippableEndMissionResultData> OverkillEquippableArray;                  // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         BeenDefeatedCount;                                 // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BeenRevivedCount;                                  // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BeenKilledCount;                                   // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HaveKilledCount;                                   // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HaveSpecialKilledCount;                            // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HaveCivilianKilledCount;                           // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HaveGuardKilledCount;                              // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HaveHeadshotKilledCount;                           // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SecuredBagCount;                                   // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InstantLootTakenCount;                             // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LocksPicked;                                       // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DownedCount;                                       // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HostagesTraded;                                    // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReviveCount;                                       // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DevicesHacked;                                     // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalDamageDealt;                                  // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZCharacterEndMissionResultData) == 0x000008, "Wrong alignment on FSBZCharacterEndMissionResultData");
static_assert(sizeof(FSBZCharacterEndMissionResultData) == 0x000060, "Wrong size on FSBZCharacterEndMissionResultData");
static_assert(offsetof(FSBZCharacterEndMissionResultData, EquippableArray) == 0x000000, "Member 'FSBZCharacterEndMissionResultData::EquippableArray' has a wrong offset!");
static_assert(offsetof(FSBZCharacterEndMissionResultData, OverkillEquippableArray) == 0x000010, "Member 'FSBZCharacterEndMissionResultData::OverkillEquippableArray' has a wrong offset!");
static_assert(offsetof(FSBZCharacterEndMissionResultData, BeenDefeatedCount) == 0x000020, "Member 'FSBZCharacterEndMissionResultData::BeenDefeatedCount' has a wrong offset!");
static_assert(offsetof(FSBZCharacterEndMissionResultData, BeenRevivedCount) == 0x000024, "Member 'FSBZCharacterEndMissionResultData::BeenRevivedCount' has a wrong offset!");
static_assert(offsetof(FSBZCharacterEndMissionResultData, BeenKilledCount) == 0x000028, "Member 'FSBZCharacterEndMissionResultData::BeenKilledCount' has a wrong offset!");
static_assert(offsetof(FSBZCharacterEndMissionResultData, HaveKilledCount) == 0x00002C, "Member 'FSBZCharacterEndMissionResultData::HaveKilledCount' has a wrong offset!");
static_assert(offsetof(FSBZCharacterEndMissionResultData, HaveSpecialKilledCount) == 0x000030, "Member 'FSBZCharacterEndMissionResultData::HaveSpecialKilledCount' has a wrong offset!");
static_assert(offsetof(FSBZCharacterEndMissionResultData, HaveCivilianKilledCount) == 0x000034, "Member 'FSBZCharacterEndMissionResultData::HaveCivilianKilledCount' has a wrong offset!");
static_assert(offsetof(FSBZCharacterEndMissionResultData, HaveGuardKilledCount) == 0x000038, "Member 'FSBZCharacterEndMissionResultData::HaveGuardKilledCount' has a wrong offset!");
static_assert(offsetof(FSBZCharacterEndMissionResultData, HaveHeadshotKilledCount) == 0x00003C, "Member 'FSBZCharacterEndMissionResultData::HaveHeadshotKilledCount' has a wrong offset!");
static_assert(offsetof(FSBZCharacterEndMissionResultData, SecuredBagCount) == 0x000040, "Member 'FSBZCharacterEndMissionResultData::SecuredBagCount' has a wrong offset!");
static_assert(offsetof(FSBZCharacterEndMissionResultData, InstantLootTakenCount) == 0x000044, "Member 'FSBZCharacterEndMissionResultData::InstantLootTakenCount' has a wrong offset!");
static_assert(offsetof(FSBZCharacterEndMissionResultData, LocksPicked) == 0x000048, "Member 'FSBZCharacterEndMissionResultData::LocksPicked' has a wrong offset!");
static_assert(offsetof(FSBZCharacterEndMissionResultData, DownedCount) == 0x00004C, "Member 'FSBZCharacterEndMissionResultData::DownedCount' has a wrong offset!");
static_assert(offsetof(FSBZCharacterEndMissionResultData, HostagesTraded) == 0x000050, "Member 'FSBZCharacterEndMissionResultData::HostagesTraded' has a wrong offset!");
static_assert(offsetof(FSBZCharacterEndMissionResultData, ReviveCount) == 0x000054, "Member 'FSBZCharacterEndMissionResultData::ReviveCount' has a wrong offset!");
static_assert(offsetof(FSBZCharacterEndMissionResultData, DevicesHacked) == 0x000058, "Member 'FSBZCharacterEndMissionResultData::DevicesHacked' has a wrong offset!");
static_assert(offsetof(FSBZCharacterEndMissionResultData, TotalDamageDealt) == 0x00005C, "Member 'FSBZCharacterEndMissionResultData::TotalDamageDealt' has a wrong offset!");

// ScriptStruct Starbreeze.SBZEndMissionSecuredBag
// 0x0038 (0x0038 - 0x0000)
struct FSBZEndMissionSecuredBag final
{
public:
	TSoftObjectPtr<class USBZBagType>             BagType;                                           // 0x0000(0x0030)(BlueprintVisible, BlueprintReadOnly, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZEndMissionSecuredBag) == 0x000008, "Wrong alignment on FSBZEndMissionSecuredBag");
static_assert(sizeof(FSBZEndMissionSecuredBag) == 0x000038, "Wrong size on FSBZEndMissionSecuredBag");
static_assert(offsetof(FSBZEndMissionSecuredBag, BagType) == 0x000000, "Member 'FSBZEndMissionSecuredBag::BagType' has a wrong offset!");
static_assert(offsetof(FSBZEndMissionSecuredBag, Count) == 0x000030, "Member 'FSBZEndMissionSecuredBag::Count' has a wrong offset!");

// ScriptStruct Starbreeze.SBZObjectiveData
// 0x0018 (0x0018 - 0x0000)
struct FSBZObjectiveData final
{
public:
	class FString                                 ObjectiveId;                                       // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCompleted;                                        // 0x0010(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZObjectiveData) == 0x000008, "Wrong alignment on FSBZObjectiveData");
static_assert(sizeof(FSBZObjectiveData) == 0x000018, "Wrong size on FSBZObjectiveData");
static_assert(offsetof(FSBZObjectiveData, ObjectiveId) == 0x000000, "Member 'FSBZObjectiveData::ObjectiveId' has a wrong offset!");
static_assert(offsetof(FSBZObjectiveData, bCompleted) == 0x000010, "Member 'FSBZObjectiveData::bCompleted' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCashRewardEventData
// 0x000C (0x000C - 0x0000)
struct FSBZCashRewardEventData final
{
public:
	int32                                         DifferencePercentage;                              // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CashDifference;                                    // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZMetaEventType                             EventType;                                         // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZCashRewardEventData) == 0x000004, "Wrong alignment on FSBZCashRewardEventData");
static_assert(sizeof(FSBZCashRewardEventData) == 0x00000C, "Wrong size on FSBZCashRewardEventData");
static_assert(offsetof(FSBZCashRewardEventData, DifferencePercentage) == 0x000000, "Member 'FSBZCashRewardEventData::DifferencePercentage' has a wrong offset!");
static_assert(offsetof(FSBZCashRewardEventData, CashDifference) == 0x000004, "Member 'FSBZCashRewardEventData::CashDifference' has a wrong offset!");
static_assert(offsetof(FSBZCashRewardEventData, EventType) == 0x000008, "Member 'FSBZCashRewardEventData::EventType' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCashRewardBagData
// 0x000C (0x000C - 0x0000)
struct FSBZCashRewardBagData final
{
public:
	int32                                         Count;                                             // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CashDifference;                                    // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZBagCategory                               BagCategory;                                       // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZCashRewardBagData) == 0x000004, "Wrong alignment on FSBZCashRewardBagData");
static_assert(sizeof(FSBZCashRewardBagData) == 0x00000C, "Wrong size on FSBZCashRewardBagData");
static_assert(offsetof(FSBZCashRewardBagData, Count) == 0x000000, "Member 'FSBZCashRewardBagData::Count' has a wrong offset!");
static_assert(offsetof(FSBZCashRewardBagData, CashDifference) == 0x000004, "Member 'FSBZCashRewardBagData::CashDifference' has a wrong offset!");
static_assert(offsetof(FSBZCashRewardBagData, BagCategory) == 0x000008, "Member 'FSBZCashRewardBagData::BagCategory' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCashRewardData
// 0x0058 (0x0058 - 0x0000)
struct FSBZCashRewardData final
{
public:
	int32                                         TotalCashValue;                                    // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalCashEarned;                                   // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LootCashValue;                                     // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IndividualLootCashValue;                           // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IndividualTotalCashValue;                          // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TickingLootValue;                                  // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTickingLootValue;                               // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CashFromChallenges;                                // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSBZCashRewardReductionData>    CashRewardReductionData;                           // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FSBZCashRewardEventData>        CashRewardEventData;                               // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FSBZCashRewardBagData>          CashRewardBagData;                                 // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	ESBZMetaRequestResult                         CashRewardOperationResult;                         // 0x0050(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZCashRewardData) == 0x000008, "Wrong alignment on FSBZCashRewardData");
static_assert(sizeof(FSBZCashRewardData) == 0x000058, "Wrong size on FSBZCashRewardData");
static_assert(offsetof(FSBZCashRewardData, TotalCashValue) == 0x000000, "Member 'FSBZCashRewardData::TotalCashValue' has a wrong offset!");
static_assert(offsetof(FSBZCashRewardData, TotalCashEarned) == 0x000004, "Member 'FSBZCashRewardData::TotalCashEarned' has a wrong offset!");
static_assert(offsetof(FSBZCashRewardData, LootCashValue) == 0x000008, "Member 'FSBZCashRewardData::LootCashValue' has a wrong offset!");
static_assert(offsetof(FSBZCashRewardData, IndividualLootCashValue) == 0x00000C, "Member 'FSBZCashRewardData::IndividualLootCashValue' has a wrong offset!");
static_assert(offsetof(FSBZCashRewardData, IndividualTotalCashValue) == 0x000010, "Member 'FSBZCashRewardData::IndividualTotalCashValue' has a wrong offset!");
static_assert(offsetof(FSBZCashRewardData, TickingLootValue) == 0x000014, "Member 'FSBZCashRewardData::TickingLootValue' has a wrong offset!");
static_assert(offsetof(FSBZCashRewardData, MaxTickingLootValue) == 0x000018, "Member 'FSBZCashRewardData::MaxTickingLootValue' has a wrong offset!");
static_assert(offsetof(FSBZCashRewardData, CashFromChallenges) == 0x00001C, "Member 'FSBZCashRewardData::CashFromChallenges' has a wrong offset!");
static_assert(offsetof(FSBZCashRewardData, CashRewardReductionData) == 0x000020, "Member 'FSBZCashRewardData::CashRewardReductionData' has a wrong offset!");
static_assert(offsetof(FSBZCashRewardData, CashRewardEventData) == 0x000030, "Member 'FSBZCashRewardData::CashRewardEventData' has a wrong offset!");
static_assert(offsetof(FSBZCashRewardData, CashRewardBagData) == 0x000040, "Member 'FSBZCashRewardData::CashRewardBagData' has a wrong offset!");
static_assert(offsetof(FSBZCashRewardData, CashRewardOperationResult) == 0x000050, "Member 'FSBZCashRewardData::CashRewardOperationResult' has a wrong offset!");

// ScriptStruct Starbreeze.SBZRandomItemReward
// 0x0010 (0x0010 - 0x0000)
struct FSBZRandomItemReward final
{
public:
	class USBZInventoryBaseData*                  InventoryBaseData;                                 // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZRandomRewardReason                        RandomRewardReason;                                // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZRandomItemReward) == 0x000008, "Wrong alignment on FSBZRandomItemReward");
static_assert(sizeof(FSBZRandomItemReward) == 0x000010, "Wrong size on FSBZRandomItemReward");
static_assert(offsetof(FSBZRandomItemReward, InventoryBaseData) == 0x000000, "Member 'FSBZRandomItemReward::InventoryBaseData' has a wrong offset!");
static_assert(offsetof(FSBZRandomItemReward, RandomRewardReason) == 0x000008, "Member 'FSBZRandomItemReward::RandomRewardReason' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeaponProgressionUpdateData
// 0x0030 (0x0030 - 0x0000)
struct FSBZWeaponProgressionUpdateData final
{
public:
	class USBZEquippableData*                     EquippableData;                                    // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OldPoints;                                         // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OldLevel;                                          // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewPoints;                                         // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewLevel;                                          // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentLevelPoints;                                // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextLevelPoints;                                   // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USBZWeaponPartDataAsset*>        UnlockedPartArray;                                 // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWeaponProgressionUpdateData) == 0x000008, "Wrong alignment on FSBZWeaponProgressionUpdateData");
static_assert(sizeof(FSBZWeaponProgressionUpdateData) == 0x000030, "Wrong size on FSBZWeaponProgressionUpdateData");
static_assert(offsetof(FSBZWeaponProgressionUpdateData, EquippableData) == 0x000000, "Member 'FSBZWeaponProgressionUpdateData::EquippableData' has a wrong offset!");
static_assert(offsetof(FSBZWeaponProgressionUpdateData, OldPoints) == 0x000008, "Member 'FSBZWeaponProgressionUpdateData::OldPoints' has a wrong offset!");
static_assert(offsetof(FSBZWeaponProgressionUpdateData, OldLevel) == 0x00000C, "Member 'FSBZWeaponProgressionUpdateData::OldLevel' has a wrong offset!");
static_assert(offsetof(FSBZWeaponProgressionUpdateData, NewPoints) == 0x000010, "Member 'FSBZWeaponProgressionUpdateData::NewPoints' has a wrong offset!");
static_assert(offsetof(FSBZWeaponProgressionUpdateData, NewLevel) == 0x000014, "Member 'FSBZWeaponProgressionUpdateData::NewLevel' has a wrong offset!");
static_assert(offsetof(FSBZWeaponProgressionUpdateData, CurrentLevelPoints) == 0x000018, "Member 'FSBZWeaponProgressionUpdateData::CurrentLevelPoints' has a wrong offset!");
static_assert(offsetof(FSBZWeaponProgressionUpdateData, NextLevelPoints) == 0x00001C, "Member 'FSBZWeaponProgressionUpdateData::NextLevelPoints' has a wrong offset!");
static_assert(offsetof(FSBZWeaponProgressionUpdateData, UnlockedPartArray) == 0x000020, "Member 'FSBZWeaponProgressionUpdateData::UnlockedPartArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPlayerEndMissionResultData
// 0x0150 (0x01B0 - 0x0060)
struct FSBZPlayerEndMissionResultData final : public FSBZCharacterEndMissionResultData
{
public:
	bool                                          bPlayerRewardsUpdated;                             // 0x0060(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayerStateId;                                     // 0x0064(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSBZCharacterEndMissionExpBonusData    CharacterEndMissionExpBonusData;                   // 0x0068(0x0030)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	struct FSBZCashRewardData                     CashRewardData;                                    // 0x0098(0x0058)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	TArray<struct FSBZRandomItemReward>           RandomItemRewardArray;                             // 0x00F0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FSBZWeaponProgressionUpdateData> WeaponProgressionUpdateArray;                     // 0x0100(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	struct FSBZSkillRewardData                    SkillRewardData;                                   // 0x0110(0x0030)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	struct FSBZInfamyPointPayoutRewardData        InfamyPointPayoutRewardData;                       // 0x0140(0x0024)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FSBZPlayerStatisticsValue              InfamyStatsValue;                                  // 0x0164(0x0008)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FSBZPlayerStatisticsValue              RenownStatsValue;                                  // 0x016C(0x0008)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bHasBeenInCustody;                                 // 0x0174(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_175[0x3];                                      // 0x0175(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SurvivedAssaultWaves;                              // 0x0178(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmmoPickupCreated;                                 // 0x017C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmmoPickupRemoved;                                 // 0x0180(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSBZEquippableEndMissionResultData     ThrowableData;                                     // 0x0184(0x0028)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         RequestOverkillCount;                              // 0x01AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPlayerEndMissionResultData) == 0x000008, "Wrong alignment on FSBZPlayerEndMissionResultData");
static_assert(sizeof(FSBZPlayerEndMissionResultData) == 0x0001B0, "Wrong size on FSBZPlayerEndMissionResultData");
static_assert(offsetof(FSBZPlayerEndMissionResultData, bPlayerRewardsUpdated) == 0x000060, "Member 'FSBZPlayerEndMissionResultData::bPlayerRewardsUpdated' has a wrong offset!");
static_assert(offsetof(FSBZPlayerEndMissionResultData, PlayerStateId) == 0x000064, "Member 'FSBZPlayerEndMissionResultData::PlayerStateId' has a wrong offset!");
static_assert(offsetof(FSBZPlayerEndMissionResultData, CharacterEndMissionExpBonusData) == 0x000068, "Member 'FSBZPlayerEndMissionResultData::CharacterEndMissionExpBonusData' has a wrong offset!");
static_assert(offsetof(FSBZPlayerEndMissionResultData, CashRewardData) == 0x000098, "Member 'FSBZPlayerEndMissionResultData::CashRewardData' has a wrong offset!");
static_assert(offsetof(FSBZPlayerEndMissionResultData, RandomItemRewardArray) == 0x0000F0, "Member 'FSBZPlayerEndMissionResultData::RandomItemRewardArray' has a wrong offset!");
static_assert(offsetof(FSBZPlayerEndMissionResultData, WeaponProgressionUpdateArray) == 0x000100, "Member 'FSBZPlayerEndMissionResultData::WeaponProgressionUpdateArray' has a wrong offset!");
static_assert(offsetof(FSBZPlayerEndMissionResultData, SkillRewardData) == 0x000110, "Member 'FSBZPlayerEndMissionResultData::SkillRewardData' has a wrong offset!");
static_assert(offsetof(FSBZPlayerEndMissionResultData, InfamyPointPayoutRewardData) == 0x000140, "Member 'FSBZPlayerEndMissionResultData::InfamyPointPayoutRewardData' has a wrong offset!");
static_assert(offsetof(FSBZPlayerEndMissionResultData, InfamyStatsValue) == 0x000164, "Member 'FSBZPlayerEndMissionResultData::InfamyStatsValue' has a wrong offset!");
static_assert(offsetof(FSBZPlayerEndMissionResultData, RenownStatsValue) == 0x00016C, "Member 'FSBZPlayerEndMissionResultData::RenownStatsValue' has a wrong offset!");
static_assert(offsetof(FSBZPlayerEndMissionResultData, bHasBeenInCustody) == 0x000174, "Member 'FSBZPlayerEndMissionResultData::bHasBeenInCustody' has a wrong offset!");
static_assert(offsetof(FSBZPlayerEndMissionResultData, SurvivedAssaultWaves) == 0x000178, "Member 'FSBZPlayerEndMissionResultData::SurvivedAssaultWaves' has a wrong offset!");
static_assert(offsetof(FSBZPlayerEndMissionResultData, AmmoPickupCreated) == 0x00017C, "Member 'FSBZPlayerEndMissionResultData::AmmoPickupCreated' has a wrong offset!");
static_assert(offsetof(FSBZPlayerEndMissionResultData, AmmoPickupRemoved) == 0x000180, "Member 'FSBZPlayerEndMissionResultData::AmmoPickupRemoved' has a wrong offset!");
static_assert(offsetof(FSBZPlayerEndMissionResultData, ThrowableData) == 0x000184, "Member 'FSBZPlayerEndMissionResultData::ThrowableData' has a wrong offset!");
static_assert(offsetof(FSBZPlayerEndMissionResultData, RequestOverkillCount) == 0x0001AC, "Member 'FSBZPlayerEndMissionResultData::RequestOverkillCount' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInstantLootData
// 0x0018 (0x0018 - 0x0000)
struct FSBZInstantLootData final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Counter;                                           // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZInstantLootData) == 0x000008, "Wrong alignment on FSBZInstantLootData");
static_assert(sizeof(FSBZInstantLootData) == 0x000018, "Wrong size on FSBZInstantLootData");
static_assert(offsetof(FSBZInstantLootData, Name) == 0x000000, "Member 'FSBZInstantLootData::Name' has a wrong offset!");
static_assert(offsetof(FSBZInstantLootData, Counter) == 0x000010, "Member 'FSBZInstantLootData::Counter' has a wrong offset!");

// ScriptStruct Starbreeze.SBZEndMissionResultData
// 0x0280 (0x0280 - 0x0000)
struct FSBZEndMissionResultData final
{
public:
	float                                         TickingLootProgress;                               // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZEndMissionResult                          MissionResult;                                     // 0x0004(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MissionTime;                                       // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSBZEndMissionSecuredBag>       SecuredBags;                                       // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         BagTotal;                                          // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSBZObjectiveData>              ExperienceObjectiveArray;                          // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FSBZMilestoneData>              MilestoneArray;                                    // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FSBZPlayerEndMissionResultData> PlayerResultArray;                                 // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	struct FSBZPlayerEndMissionResultData         AllPlayerAIsResult;                                // 0x0058(0x01B0)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	struct FSBZCharacterEndMissionResultData      AllOtherCharacterResult;                           // 0x0208(0x0060)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	TArray<struct FSBZInstantLootData>            InstantLootArray;                                  // 0x0268(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         CompletedAssaultWaveCount;                         // 0x0278(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFinalAssaultTriggered;                          // 0x027C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllCiviliansAlive;                                // 0x027D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27E[0x2];                                      // 0x027E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZEndMissionResultData) == 0x000008, "Wrong alignment on FSBZEndMissionResultData");
static_assert(sizeof(FSBZEndMissionResultData) == 0x000280, "Wrong size on FSBZEndMissionResultData");
static_assert(offsetof(FSBZEndMissionResultData, TickingLootProgress) == 0x000000, "Member 'FSBZEndMissionResultData::TickingLootProgress' has a wrong offset!");
static_assert(offsetof(FSBZEndMissionResultData, MissionResult) == 0x000004, "Member 'FSBZEndMissionResultData::MissionResult' has a wrong offset!");
static_assert(offsetof(FSBZEndMissionResultData, MissionTime) == 0x000008, "Member 'FSBZEndMissionResultData::MissionTime' has a wrong offset!");
static_assert(offsetof(FSBZEndMissionResultData, SecuredBags) == 0x000010, "Member 'FSBZEndMissionResultData::SecuredBags' has a wrong offset!");
static_assert(offsetof(FSBZEndMissionResultData, BagTotal) == 0x000020, "Member 'FSBZEndMissionResultData::BagTotal' has a wrong offset!");
static_assert(offsetof(FSBZEndMissionResultData, ExperienceObjectiveArray) == 0x000028, "Member 'FSBZEndMissionResultData::ExperienceObjectiveArray' has a wrong offset!");
static_assert(offsetof(FSBZEndMissionResultData, MilestoneArray) == 0x000038, "Member 'FSBZEndMissionResultData::MilestoneArray' has a wrong offset!");
static_assert(offsetof(FSBZEndMissionResultData, PlayerResultArray) == 0x000048, "Member 'FSBZEndMissionResultData::PlayerResultArray' has a wrong offset!");
static_assert(offsetof(FSBZEndMissionResultData, AllPlayerAIsResult) == 0x000058, "Member 'FSBZEndMissionResultData::AllPlayerAIsResult' has a wrong offset!");
static_assert(offsetof(FSBZEndMissionResultData, AllOtherCharacterResult) == 0x000208, "Member 'FSBZEndMissionResultData::AllOtherCharacterResult' has a wrong offset!");
static_assert(offsetof(FSBZEndMissionResultData, InstantLootArray) == 0x000268, "Member 'FSBZEndMissionResultData::InstantLootArray' has a wrong offset!");
static_assert(offsetof(FSBZEndMissionResultData, CompletedAssaultWaveCount) == 0x000278, "Member 'FSBZEndMissionResultData::CompletedAssaultWaveCount' has a wrong offset!");
static_assert(offsetof(FSBZEndMissionResultData, bIsFinalAssaultTriggered) == 0x00027C, "Member 'FSBZEndMissionResultData::bIsFinalAssaultTriggered' has a wrong offset!");
static_assert(offsetof(FSBZEndMissionResultData, bAllCiviliansAlive) == 0x00027D, "Member 'FSBZEndMissionResultData::bAllCiviliansAlive' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAgilityTrajectoryPoint
// 0x001C (0x001C - 0x0000)
struct FSBZAgilityTrajectoryPoint final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x000C(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ESBZAgilityPointType                          AgilityPointType;                                  // 0x0018(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAgilityTrajectoryPoint) == 0x000004, "Wrong alignment on FSBZAgilityTrajectoryPoint");
static_assert(sizeof(FSBZAgilityTrajectoryPoint) == 0x00001C, "Wrong size on FSBZAgilityTrajectoryPoint");
static_assert(offsetof(FSBZAgilityTrajectoryPoint, Location) == 0x000000, "Member 'FSBZAgilityTrajectoryPoint::Location' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTrajectoryPoint, Rotation) == 0x00000C, "Member 'FSBZAgilityTrajectoryPoint::Rotation' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTrajectoryPoint, AgilityPointType) == 0x000018, "Member 'FSBZAgilityTrajectoryPoint::AgilityPointType' has a wrong offset!");

// ScriptStruct Starbreeze.SBZHUDNotificationData
// 0x0020 (0x0020 - 0x0000)
struct FSBZHUDNotificationData final
{
public:
	class FText                                   DisplayText;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         DisplayTime;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZHUDNotificationData) == 0x000008, "Wrong alignment on FSBZHUDNotificationData");
static_assert(sizeof(FSBZHUDNotificationData) == 0x000020, "Wrong size on FSBZHUDNotificationData");
static_assert(offsetof(FSBZHUDNotificationData, DisplayText) == 0x000000, "Member 'FSBZHUDNotificationData::DisplayText' has a wrong offset!");
static_assert(offsetof(FSBZHUDNotificationData, DisplayTime) == 0x000018, "Member 'FSBZHUDNotificationData::DisplayTime' has a wrong offset!");

// ScriptStruct Starbreeze.SBZComponentSelector
// 0x0020 (0x0020 - 0x0000)
struct FSBZComponentSelector final
{
public:
	TSubclassOf<class UActorComponent>            ComponentType;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ComponentName;                                     // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UActorComponent*                        Component;                                         // 0x0018(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZComponentSelector) == 0x000008, "Wrong alignment on FSBZComponentSelector");
static_assert(sizeof(FSBZComponentSelector) == 0x000020, "Wrong size on FSBZComponentSelector");
static_assert(offsetof(FSBZComponentSelector, ComponentType) == 0x000000, "Member 'FSBZComponentSelector::ComponentType' has a wrong offset!");
static_assert(offsetof(FSBZComponentSelector, ComponentName) == 0x000008, "Member 'FSBZComponentSelector::ComponentName' has a wrong offset!");
static_assert(offsetof(FSBZComponentSelector, Component) == 0x000018, "Member 'FSBZComponentSelector::Component' has a wrong offset!");

// ScriptStruct Starbreeze.SBZGateMeshData
// 0x0090 (0x0090 - 0x0000)
struct FSBZGateMeshData final
{
public:
	struct FSBZComponentSelector                  MeshSelector;                                      // 0x0000(0x0020)(Edit, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FSBZComponentSelector                  BoundSelector;                                     // 0x0020(0x0020)(Edit, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FBox                                   LocalBoundBox;                                     // 0x0040(0x001C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FBox                                   LocalActorBoundBox;                                // 0x005C(0x001C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsHingedRight;                                    // 0x0078(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        SnapPointsArray;                                   // 0x0080(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZGateMeshData) == 0x000008, "Wrong alignment on FSBZGateMeshData");
static_assert(sizeof(FSBZGateMeshData) == 0x000090, "Wrong size on FSBZGateMeshData");
static_assert(offsetof(FSBZGateMeshData, MeshSelector) == 0x000000, "Member 'FSBZGateMeshData::MeshSelector' has a wrong offset!");
static_assert(offsetof(FSBZGateMeshData, BoundSelector) == 0x000020, "Member 'FSBZGateMeshData::BoundSelector' has a wrong offset!");
static_assert(offsetof(FSBZGateMeshData, LocalBoundBox) == 0x000040, "Member 'FSBZGateMeshData::LocalBoundBox' has a wrong offset!");
static_assert(offsetof(FSBZGateMeshData, LocalActorBoundBox) == 0x00005C, "Member 'FSBZGateMeshData::LocalActorBoundBox' has a wrong offset!");
static_assert(offsetof(FSBZGateMeshData, bIsHingedRight) == 0x000078, "Member 'FSBZGateMeshData::bIsHingedRight' has a wrong offset!");
static_assert(offsetof(FSBZGateMeshData, SnapPointsArray) == 0x000080, "Member 'FSBZGateMeshData::SnapPointsArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPlayerChatEvent
// 0x0018 (0x0018 - 0x0000)
struct FSBZPlayerChatEvent final : public FSBZGameEventStructBase
{
public:
	class APlayerState*                           PlayerState;                                       // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message;                                           // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPlayerChatEvent) == 0x000008, "Wrong alignment on FSBZPlayerChatEvent");
static_assert(sizeof(FSBZPlayerChatEvent) == 0x000018, "Wrong size on FSBZPlayerChatEvent");
static_assert(offsetof(FSBZPlayerChatEvent, PlayerState) == 0x000000, "Member 'FSBZPlayerChatEvent::PlayerState' has a wrong offset!");
static_assert(offsetof(FSBZPlayerChatEvent, Message) == 0x000008, "Member 'FSBZPlayerChatEvent::Message' has a wrong offset!");

// ScriptStruct Starbreeze.SBZEventRequest
// 0x0038 (0x0038 - 0x0000)
struct FSBZEventRequest final
{
public:
	class USBZVoiceCommentDataAsset*              VoiceComment;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZVoicePriority                             VoicePriority;                                     // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnvQuery*                              EQSQuery;                                          // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZTargetFinder*                       TargetFinder;                                      // 0x0018(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldLoopFromBeginPlay;                          // 0x0020(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRange                            SoundLoopInterval;                                 // 0x0024(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZEventRequest) == 0x000008, "Wrong alignment on FSBZEventRequest");
static_assert(sizeof(FSBZEventRequest) == 0x000038, "Wrong size on FSBZEventRequest");
static_assert(offsetof(FSBZEventRequest, VoiceComment) == 0x000000, "Member 'FSBZEventRequest::VoiceComment' has a wrong offset!");
static_assert(offsetof(FSBZEventRequest, VoicePriority) == 0x000008, "Member 'FSBZEventRequest::VoicePriority' has a wrong offset!");
static_assert(offsetof(FSBZEventRequest, EQSQuery) == 0x000010, "Member 'FSBZEventRequest::EQSQuery' has a wrong offset!");
static_assert(offsetof(FSBZEventRequest, TargetFinder) == 0x000018, "Member 'FSBZEventRequest::TargetFinder' has a wrong offset!");
static_assert(offsetof(FSBZEventRequest, bShouldLoopFromBeginPlay) == 0x000020, "Member 'FSBZEventRequest::bShouldLoopFromBeginPlay' has a wrong offset!");
static_assert(offsetof(FSBZEventRequest, SoundLoopInterval) == 0x000024, "Member 'FSBZEventRequest::SoundLoopInterval' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAgilityTraversalSplineHandler
// 0x00A8 (0x00A8 - 0x0000)
struct alignas(0x08) FSBZAgilityTraversalSplineHandler final
{
public:
	uint8                                         Pad_0[0xA8];                                       // 0x0000(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAgilityTraversalSplineHandler) == 0x000008, "Wrong alignment on FSBZAgilityTraversalSplineHandler");
static_assert(sizeof(FSBZAgilityTraversalSplineHandler) == 0x0000A8, "Wrong size on FSBZAgilityTraversalSplineHandler");

// ScriptStruct Starbreeze.SBZArmorInventorySlot
// 0x0040 (0x0068 - 0x0028)
struct FSBZArmorInventorySlot final : public FSBZInventorySlot
{
public:
	struct FGuid                                  ArmorInSlotEntitlementId;                          // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ArmorInSlotAccelByteItemSku;                       // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSBZArmorConfig                        ArmorConfig;                                       // 0x0048(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZArmorInventorySlot) == 0x000008, "Wrong alignment on FSBZArmorInventorySlot");
static_assert(sizeof(FSBZArmorInventorySlot) == 0x000068, "Wrong size on FSBZArmorInventorySlot");
static_assert(offsetof(FSBZArmorInventorySlot, ArmorInSlotEntitlementId) == 0x000028, "Member 'FSBZArmorInventorySlot::ArmorInSlotEntitlementId' has a wrong offset!");
static_assert(offsetof(FSBZArmorInventorySlot, ArmorInSlotAccelByteItemSku) == 0x000038, "Member 'FSBZArmorInventorySlot::ArmorInSlotAccelByteItemSku' has a wrong offset!");
static_assert(offsetof(FSBZArmorInventorySlot, ArmorConfig) == 0x000048, "Member 'FSBZArmorInventorySlot::ArmorConfig' has a wrong offset!");

// ScriptStruct Starbreeze.SBZFactionNameHelper
// 0x000C (0x000C - 0x0000)
struct FSBZFactionNameHelper final
{
public:
	class FName                                   FactionName;                                       // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZFactionNameHelper) == 0x000004, "Wrong alignment on FSBZFactionNameHelper");
static_assert(sizeof(FSBZFactionNameHelper) == 0x00000C, "Wrong size on FSBZFactionNameHelper");
static_assert(offsetof(FSBZFactionNameHelper, FactionName) == 0x000000, "Member 'FSBZFactionNameHelper::FactionName' has a wrong offset!");

// ScriptStruct Starbreeze.SBZThrowItemTargetData
// 0x0028 (0x0030 - 0x0008)
struct FSBZThrowItemTargetData final : public FGameplayAbilityTargetData
{
public:
	uint8                                         Pad_8[0x28];                                       // 0x0008(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZThrowItemTargetData) == 0x000008, "Wrong alignment on FSBZThrowItemTargetData");
static_assert(sizeof(FSBZThrowItemTargetData) == 0x000030, "Wrong size on FSBZThrowItemTargetData");

// ScriptStruct Starbreeze.SBZActorSpawnRequest
// 0x0038 (0x0038 - 0x0000)
struct FSBZActorSpawnRequest final
{
public:
	class USBZActorSpawnRequestData*              Data;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ASBZActorSpawnBase>      Spawner;                                           // 0x0008(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZActorSpawnRequest) == 0x000008, "Wrong alignment on FSBZActorSpawnRequest");
static_assert(sizeof(FSBZActorSpawnRequest) == 0x000038, "Wrong size on FSBZActorSpawnRequest");
static_assert(offsetof(FSBZActorSpawnRequest, Data) == 0x000000, "Member 'FSBZActorSpawnRequest::Data' has a wrong offset!");
static_assert(offsetof(FSBZActorSpawnRequest, Spawner) == 0x000008, "Member 'FSBZActorSpawnRequest::Spawner' has a wrong offset!");

// ScriptStruct Starbreeze.SBZHoldOutDroneTagReactionSelectionConfig
// 0x0010 (0x0010 - 0x0000)
struct FSBZHoldOutDroneTagReactionSelectionConfig final
{
public:
	struct FInt32Range                            TagCountRange;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZHoldOutDroneTagReactionSelectionConfig) == 0x000004, "Wrong alignment on FSBZHoldOutDroneTagReactionSelectionConfig");
static_assert(sizeof(FSBZHoldOutDroneTagReactionSelectionConfig) == 0x000010, "Wrong size on FSBZHoldOutDroneTagReactionSelectionConfig");
static_assert(offsetof(FSBZHoldOutDroneTagReactionSelectionConfig, TagCountRange) == 0x000000, "Member 'FSBZHoldOutDroneTagReactionSelectionConfig::TagCountRange' has a wrong offset!");

// ScriptStruct Starbreeze.SBZHoldOutDroneTagReactionConfig
// 0x0028 (0x0028 - 0x0000)
struct FSBZHoldOutDroneTagReactionConfig final
{
public:
	struct FSBZHoldOutDroneTagReactionSelectionConfig SelectionConfig;                               // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIgnoredOnDedicatedServer;                         // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoredOnClient;                                  // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFireAndForget;                                    // 0x0012(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           VOTag;                                             // 0x0014(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ASBZHoldOutDroneReaction>   DroneReactionClass;                                // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZHoldOutDroneTagReactionConfig) == 0x000008, "Wrong alignment on FSBZHoldOutDroneTagReactionConfig");
static_assert(sizeof(FSBZHoldOutDroneTagReactionConfig) == 0x000028, "Wrong size on FSBZHoldOutDroneTagReactionConfig");
static_assert(offsetof(FSBZHoldOutDroneTagReactionConfig, SelectionConfig) == 0x000000, "Member 'FSBZHoldOutDroneTagReactionConfig::SelectionConfig' has a wrong offset!");
static_assert(offsetof(FSBZHoldOutDroneTagReactionConfig, bIgnoredOnDedicatedServer) == 0x000010, "Member 'FSBZHoldOutDroneTagReactionConfig::bIgnoredOnDedicatedServer' has a wrong offset!");
static_assert(offsetof(FSBZHoldOutDroneTagReactionConfig, bIgnoredOnClient) == 0x000011, "Member 'FSBZHoldOutDroneTagReactionConfig::bIgnoredOnClient' has a wrong offset!");
static_assert(offsetof(FSBZHoldOutDroneTagReactionConfig, bFireAndForget) == 0x000012, "Member 'FSBZHoldOutDroneTagReactionConfig::bFireAndForget' has a wrong offset!");
static_assert(offsetof(FSBZHoldOutDroneTagReactionConfig, VOTag) == 0x000014, "Member 'FSBZHoldOutDroneTagReactionConfig::VOTag' has a wrong offset!");
static_assert(offsetof(FSBZHoldOutDroneTagReactionConfig, DroneReactionClass) == 0x000020, "Member 'FSBZHoldOutDroneTagReactionConfig::DroneReactionClass' has a wrong offset!");

// ScriptStruct Starbreeze.SBZBreachingEquipmentTimes
// 0x0010 (0x0010 - 0x0000)
struct FSBZBreachingEquipmentTimes final
{
public:
	float                                         RedZoneTimeSeconds;                                // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YellowZoneTimeSeconds;                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GreenZoneTimeSeconds;                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalFuelTime;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZBreachingEquipmentTimes) == 0x000004, "Wrong alignment on FSBZBreachingEquipmentTimes");
static_assert(sizeof(FSBZBreachingEquipmentTimes) == 0x000010, "Wrong size on FSBZBreachingEquipmentTimes");
static_assert(offsetof(FSBZBreachingEquipmentTimes, RedZoneTimeSeconds) == 0x000000, "Member 'FSBZBreachingEquipmentTimes::RedZoneTimeSeconds' has a wrong offset!");
static_assert(offsetof(FSBZBreachingEquipmentTimes, YellowZoneTimeSeconds) == 0x000004, "Member 'FSBZBreachingEquipmentTimes::YellowZoneTimeSeconds' has a wrong offset!");
static_assert(offsetof(FSBZBreachingEquipmentTimes, GreenZoneTimeSeconds) == 0x000008, "Member 'FSBZBreachingEquipmentTimes::GreenZoneTimeSeconds' has a wrong offset!");
static_assert(offsetof(FSBZBreachingEquipmentTimes, TotalFuelTime) == 0x00000C, "Member 'FSBZBreachingEquipmentTimes::TotalFuelTime' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPlayerCallEvent
// 0x0010 (0x0010 - 0x0000)
struct FSBZPlayerCallEvent final : public FSBZGameEventStructBase
{
public:
	class ASBZPlayerState*                        PlayerState;                                       // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZPingCallAsset*                      Call;                                              // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPlayerCallEvent) == 0x000008, "Wrong alignment on FSBZPlayerCallEvent");
static_assert(sizeof(FSBZPlayerCallEvent) == 0x000010, "Wrong size on FSBZPlayerCallEvent");
static_assert(offsetof(FSBZPlayerCallEvent, PlayerState) == 0x000000, "Member 'FSBZPlayerCallEvent::PlayerState' has a wrong offset!");
static_assert(offsetof(FSBZPlayerCallEvent, Call) == 0x000008, "Member 'FSBZPlayerCallEvent::Call' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAIAlertnessComment
// 0x0010 (0x0010 - 0x0000)
struct FSBZAIAlertnessComment final
{
public:
	class USBZVoiceCommentDataAsset*              RaisedTo;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZVoiceCommentDataAsset*              LoweredTo;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAIAlertnessComment) == 0x000008, "Wrong alignment on FSBZAIAlertnessComment");
static_assert(sizeof(FSBZAIAlertnessComment) == 0x000010, "Wrong size on FSBZAIAlertnessComment");
static_assert(offsetof(FSBZAIAlertnessComment, RaisedTo) == 0x000000, "Member 'FSBZAIAlertnessComment::RaisedTo' has a wrong offset!");
static_assert(offsetof(FSBZAIAlertnessComment, LoweredTo) == 0x000008, "Member 'FSBZAIAlertnessComment::LoweredTo' has a wrong offset!");

// ScriptStruct Starbreeze.SBZBoneLocker
// 0x00B0 (0x00B0 - 0x0000)
struct alignas(0x10) FSBZBoneLocker final
{
public:
	struct FBoneReference                         BoneRef;                                           // 0x0000(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   LockCurveName;                                     // 0x0014(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x4];                                       // 0x0020(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LockAlphaThreshold;                                // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                YawAxis;                                           // 0x0028(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDist;                                           // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxYaw;                                            // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTranslationLock2D;                                // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterpSpeed;                                       // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x6C];                                      // 0x0044(0x006C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZBoneLocker) == 0x000010, "Wrong alignment on FSBZBoneLocker");
static_assert(sizeof(FSBZBoneLocker) == 0x0000B0, "Wrong size on FSBZBoneLocker");
static_assert(offsetof(FSBZBoneLocker, BoneRef) == 0x000000, "Member 'FSBZBoneLocker::BoneRef' has a wrong offset!");
static_assert(offsetof(FSBZBoneLocker, LockCurveName) == 0x000014, "Member 'FSBZBoneLocker::LockCurveName' has a wrong offset!");
static_assert(offsetof(FSBZBoneLocker, LockAlphaThreshold) == 0x000024, "Member 'FSBZBoneLocker::LockAlphaThreshold' has a wrong offset!");
static_assert(offsetof(FSBZBoneLocker, YawAxis) == 0x000028, "Member 'FSBZBoneLocker::YawAxis' has a wrong offset!");
static_assert(offsetof(FSBZBoneLocker, MaxDist) == 0x000034, "Member 'FSBZBoneLocker::MaxDist' has a wrong offset!");
static_assert(offsetof(FSBZBoneLocker, MaxYaw) == 0x000038, "Member 'FSBZBoneLocker::MaxYaw' has a wrong offset!");
static_assert(offsetof(FSBZBoneLocker, bTranslationLock2D) == 0x00003C, "Member 'FSBZBoneLocker::bTranslationLock2D' has a wrong offset!");
static_assert(offsetof(FSBZBoneLocker, InterpSpeed) == 0x000040, "Member 'FSBZBoneLocker::InterpSpeed' has a wrong offset!");

// ScriptStruct Starbreeze.SBZFootPlacementBoneInfo
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FSBZFootPlacementBoneInfo final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZFootPlacementBoneInfo) == 0x000008, "Wrong alignment on FSBZFootPlacementBoneInfo");
static_assert(sizeof(FSBZFootPlacementBoneInfo) == 0x000030, "Wrong size on FSBZFootPlacementBoneInfo");

// ScriptStruct Starbreeze.SBZAnimNode_ProceduralFootPlacement
// 0x0338 (0x0420 - 0x00E8)
struct FSBZAnimNode_ProceduralFootPlacement final : public FAnimNode_SkeletalControlBase
{
public:
	bool                                          bNewRendered;                                      // 0x00E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E9[0x3];                                       // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoneReference                         PelvisBone;                                        // 0x00EC(0x0014)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FBoneReference                         LeftIKFootBone;                                    // 0x0100(0x0014)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FBoneReference                         LeftFootBone;                                      // 0x0114(0x0014)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FBoneReference                         LeftFootToeBaseBone;                               // 0x0128(0x0014)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FBoneReference                         RightIKFootBone;                                   // 0x013C(0x0014)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FBoneReference                         RightFootBone;                                     // 0x0150(0x0014)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FBoneReference                         RightFootToeBaseBone;                              // 0x0164(0x0014)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         SpineAdjustmentAlpha;                              // 0x0178(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBoneReference                         SpineBone;                                         // 0x017C(0x0014)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         MaxFloorPitchForSpine;                             // 0x0190(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxFloorRollForSpine;                              // 0x0194(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_198[0x8];                                      // 0x0198(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSBZBoneLocker                         LeftFootLocker;                                    // 0x01A0(0x00B0)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSBZBoneLocker                         RightFootLocker;                                   // 0x0250(0x00B0)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSBZFootPlacementBoneInfo              LeftFootPlacementBone;                             // 0x0300(0x0030)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSBZFootPlacementBoneInfo              RightFootPlacementBone;                            // 0x0330(0x0030)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         FootRotationInterpSpeed;                           // 0x0360(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DeltaYaw;                                          // 0x0364(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinFootZOffsetInterSpeed;                          // 0x0368(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ImpactZInterSpeedFactor;                           // 0x036C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatInterval                         FootZOffsetInterval;                               // 0x0370(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatInterval                         FootMaxPitch;                                      // 0x0378(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatInterval                         FootMaxRoll;                                       // 0x0380(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatInterval                         FootZUpOffsetToFixAnkleInterval;                   // 0x0388(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnkleAdjustmentAlpha;                              // 0x0390(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxFootLiftZDist;                                  // 0x0394(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAxis                                         AnklePitchAxis;                                    // 0x0398(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_399[0x3];                                      // 0x0399(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatInterval                         PelvisZOffsetInterval;                             // 0x039C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PelvisMinHeight;                                   // 0x03A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PelvisInterpSpeed;                                 // 0x03A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PelvisHigherHeightInterpSpeedModifier;             // 0x03AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinZDistToPelvis;                                  // 0x03B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CharacterSpeed;                                    // 0x03B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatInterval                         RootReconciliationSpeedInterval;                   // 0x03B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RootSpeedMultiplier;                               // 0x03C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C4[0x5C];                                     // 0x03C4(0x005C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAnimNode_ProceduralFootPlacement) == 0x000010, "Wrong alignment on FSBZAnimNode_ProceduralFootPlacement");
static_assert(sizeof(FSBZAnimNode_ProceduralFootPlacement) == 0x000420, "Wrong size on FSBZAnimNode_ProceduralFootPlacement");
static_assert(offsetof(FSBZAnimNode_ProceduralFootPlacement, bNewRendered) == 0x0000E8, "Member 'FSBZAnimNode_ProceduralFootPlacement::bNewRendered' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ProceduralFootPlacement, PelvisBone) == 0x0000EC, "Member 'FSBZAnimNode_ProceduralFootPlacement::PelvisBone' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ProceduralFootPlacement, LeftIKFootBone) == 0x000100, "Member 'FSBZAnimNode_ProceduralFootPlacement::LeftIKFootBone' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ProceduralFootPlacement, LeftFootBone) == 0x000114, "Member 'FSBZAnimNode_ProceduralFootPlacement::LeftFootBone' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ProceduralFootPlacement, LeftFootToeBaseBone) == 0x000128, "Member 'FSBZAnimNode_ProceduralFootPlacement::LeftFootToeBaseBone' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ProceduralFootPlacement, RightIKFootBone) == 0x00013C, "Member 'FSBZAnimNode_ProceduralFootPlacement::RightIKFootBone' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ProceduralFootPlacement, RightFootBone) == 0x000150, "Member 'FSBZAnimNode_ProceduralFootPlacement::RightFootBone' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ProceduralFootPlacement, RightFootToeBaseBone) == 0x000164, "Member 'FSBZAnimNode_ProceduralFootPlacement::RightFootToeBaseBone' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ProceduralFootPlacement, SpineAdjustmentAlpha) == 0x000178, "Member 'FSBZAnimNode_ProceduralFootPlacement::SpineAdjustmentAlpha' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ProceduralFootPlacement, SpineBone) == 0x00017C, "Member 'FSBZAnimNode_ProceduralFootPlacement::SpineBone' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ProceduralFootPlacement, MaxFloorPitchForSpine) == 0x000190, "Member 'FSBZAnimNode_ProceduralFootPlacement::MaxFloorPitchForSpine' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ProceduralFootPlacement, MaxFloorRollForSpine) == 0x000194, "Member 'FSBZAnimNode_ProceduralFootPlacement::MaxFloorRollForSpine' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ProceduralFootPlacement, LeftFootLocker) == 0x0001A0, "Member 'FSBZAnimNode_ProceduralFootPlacement::LeftFootLocker' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ProceduralFootPlacement, RightFootLocker) == 0x000250, "Member 'FSBZAnimNode_ProceduralFootPlacement::RightFootLocker' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ProceduralFootPlacement, LeftFootPlacementBone) == 0x000300, "Member 'FSBZAnimNode_ProceduralFootPlacement::LeftFootPlacementBone' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ProceduralFootPlacement, RightFootPlacementBone) == 0x000330, "Member 'FSBZAnimNode_ProceduralFootPlacement::RightFootPlacementBone' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ProceduralFootPlacement, FootRotationInterpSpeed) == 0x000360, "Member 'FSBZAnimNode_ProceduralFootPlacement::FootRotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ProceduralFootPlacement, DeltaYaw) == 0x000364, "Member 'FSBZAnimNode_ProceduralFootPlacement::DeltaYaw' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ProceduralFootPlacement, MinFootZOffsetInterSpeed) == 0x000368, "Member 'FSBZAnimNode_ProceduralFootPlacement::MinFootZOffsetInterSpeed' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ProceduralFootPlacement, ImpactZInterSpeedFactor) == 0x00036C, "Member 'FSBZAnimNode_ProceduralFootPlacement::ImpactZInterSpeedFactor' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ProceduralFootPlacement, FootZOffsetInterval) == 0x000370, "Member 'FSBZAnimNode_ProceduralFootPlacement::FootZOffsetInterval' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ProceduralFootPlacement, FootMaxPitch) == 0x000378, "Member 'FSBZAnimNode_ProceduralFootPlacement::FootMaxPitch' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ProceduralFootPlacement, FootMaxRoll) == 0x000380, "Member 'FSBZAnimNode_ProceduralFootPlacement::FootMaxRoll' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ProceduralFootPlacement, FootZUpOffsetToFixAnkleInterval) == 0x000388, "Member 'FSBZAnimNode_ProceduralFootPlacement::FootZUpOffsetToFixAnkleInterval' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ProceduralFootPlacement, AnkleAdjustmentAlpha) == 0x000390, "Member 'FSBZAnimNode_ProceduralFootPlacement::AnkleAdjustmentAlpha' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ProceduralFootPlacement, MaxFootLiftZDist) == 0x000394, "Member 'FSBZAnimNode_ProceduralFootPlacement::MaxFootLiftZDist' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ProceduralFootPlacement, AnklePitchAxis) == 0x000398, "Member 'FSBZAnimNode_ProceduralFootPlacement::AnklePitchAxis' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ProceduralFootPlacement, PelvisZOffsetInterval) == 0x00039C, "Member 'FSBZAnimNode_ProceduralFootPlacement::PelvisZOffsetInterval' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ProceduralFootPlacement, PelvisMinHeight) == 0x0003A4, "Member 'FSBZAnimNode_ProceduralFootPlacement::PelvisMinHeight' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ProceduralFootPlacement, PelvisInterpSpeed) == 0x0003A8, "Member 'FSBZAnimNode_ProceduralFootPlacement::PelvisInterpSpeed' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ProceduralFootPlacement, PelvisHigherHeightInterpSpeedModifier) == 0x0003AC, "Member 'FSBZAnimNode_ProceduralFootPlacement::PelvisHigherHeightInterpSpeedModifier' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ProceduralFootPlacement, MinZDistToPelvis) == 0x0003B0, "Member 'FSBZAnimNode_ProceduralFootPlacement::MinZDistToPelvis' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ProceduralFootPlacement, CharacterSpeed) == 0x0003B4, "Member 'FSBZAnimNode_ProceduralFootPlacement::CharacterSpeed' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ProceduralFootPlacement, RootReconciliationSpeedInterval) == 0x0003B8, "Member 'FSBZAnimNode_ProceduralFootPlacement::RootReconciliationSpeedInterval' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ProceduralFootPlacement, RootSpeedMultiplier) == 0x0003C0, "Member 'FSBZAnimNode_ProceduralFootPlacement::RootSpeedMultiplier' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPlayerReadyInfo
// 0x008C (0x0098 - 0x000C)
struct FSBZPlayerReadyInfo final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUniqueNetIdRepl                       PlayerId;                                          // 0x0010(0x0028)(BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerNamePlatform;                                // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerNameAccelbyte;                               // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AccelByteUserName;                                 // 0x0058(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AccelByteDisplayName;                              // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AccelByteUserId;                                   // 0x0078(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerReadyStatusValue                       PlayerReadyStatusValue;                            // 0x0088(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZPlatform                                  Platform;                                          // 0x0089(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZFirstPartyPlatform                        FirstPartyPlatform;                                // 0x008A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8B[0x1];                                       // 0x008B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InfamyLevel;                                       // 0x008C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RenownLevel;                                       // 0x0090(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZPlayerReadyInfo) == 0x000008, "Wrong alignment on FSBZPlayerReadyInfo");
static_assert(sizeof(FSBZPlayerReadyInfo) == 0x000098, "Wrong size on FSBZPlayerReadyInfo");
static_assert(offsetof(FSBZPlayerReadyInfo, PlayerId) == 0x000010, "Member 'FSBZPlayerReadyInfo::PlayerId' has a wrong offset!");
static_assert(offsetof(FSBZPlayerReadyInfo, PlayerNamePlatform) == 0x000038, "Member 'FSBZPlayerReadyInfo::PlayerNamePlatform' has a wrong offset!");
static_assert(offsetof(FSBZPlayerReadyInfo, PlayerNameAccelbyte) == 0x000048, "Member 'FSBZPlayerReadyInfo::PlayerNameAccelbyte' has a wrong offset!");
static_assert(offsetof(FSBZPlayerReadyInfo, AccelByteUserName) == 0x000058, "Member 'FSBZPlayerReadyInfo::AccelByteUserName' has a wrong offset!");
static_assert(offsetof(FSBZPlayerReadyInfo, AccelByteDisplayName) == 0x000068, "Member 'FSBZPlayerReadyInfo::AccelByteDisplayName' has a wrong offset!");
static_assert(offsetof(FSBZPlayerReadyInfo, AccelByteUserId) == 0x000078, "Member 'FSBZPlayerReadyInfo::AccelByteUserId' has a wrong offset!");
static_assert(offsetof(FSBZPlayerReadyInfo, PlayerReadyStatusValue) == 0x000088, "Member 'FSBZPlayerReadyInfo::PlayerReadyStatusValue' has a wrong offset!");
static_assert(offsetof(FSBZPlayerReadyInfo, Platform) == 0x000089, "Member 'FSBZPlayerReadyInfo::Platform' has a wrong offset!");
static_assert(offsetof(FSBZPlayerReadyInfo, FirstPartyPlatform) == 0x00008A, "Member 'FSBZPlayerReadyInfo::FirstPartyPlatform' has a wrong offset!");
static_assert(offsetof(FSBZPlayerReadyInfo, InfamyLevel) == 0x00008C, "Member 'FSBZPlayerReadyInfo::InfamyLevel' has a wrong offset!");
static_assert(offsetof(FSBZPlayerReadyInfo, RenownLevel) == 0x000090, "Member 'FSBZPlayerReadyInfo::RenownLevel' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPlayersReadyStatusStateArray
// 0x0010 (0x0118 - 0x0108)
struct FSBZPlayersReadyStatusStateArray final : public FFastArraySerializer
{
public:
	TArray<struct FSBZPlayerReadyInfo>            SBZPlayersReadyInfo;                               // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPlayersReadyStatusStateArray) == 0x000008, "Wrong alignment on FSBZPlayersReadyStatusStateArray");
static_assert(sizeof(FSBZPlayersReadyStatusStateArray) == 0x000118, "Wrong size on FSBZPlayersReadyStatusStateArray");
static_assert(offsetof(FSBZPlayersReadyStatusStateArray, SBZPlayersReadyInfo) == 0x000108, "Member 'FSBZPlayersReadyStatusStateArray::SBZPlayersReadyInfo' has a wrong offset!");

// ScriptStruct Starbreeze.SBZLifeActionAnimationTags
// 0x0024 (0x0024 - 0x0000)
struct FSBZLifeActionAnimationTags final
{
public:
	struct FGameplayTag                           EnterAnimationTag;                                 // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AnimationTag;                                      // 0x000C(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ExitAnimationTag;                                  // 0x0018(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZLifeActionAnimationTags) == 0x000004, "Wrong alignment on FSBZLifeActionAnimationTags");
static_assert(sizeof(FSBZLifeActionAnimationTags) == 0x000024, "Wrong size on FSBZLifeActionAnimationTags");
static_assert(offsetof(FSBZLifeActionAnimationTags, EnterAnimationTag) == 0x000000, "Member 'FSBZLifeActionAnimationTags::EnterAnimationTag' has a wrong offset!");
static_assert(offsetof(FSBZLifeActionAnimationTags, AnimationTag) == 0x00000C, "Member 'FSBZLifeActionAnimationTags::AnimationTag' has a wrong offset!");
static_assert(offsetof(FSBZLifeActionAnimationTags, ExitAnimationTag) == 0x000018, "Member 'FSBZLifeActionAnimationTags::ExitAnimationTag' has a wrong offset!");

// ScriptStruct Starbreeze.SBZLifeActionAnimationTagsRandomizer
// 0x0018 (0x0018 - 0x0000)
struct FSBZLifeActionAnimationTagsRandomizer final
{
public:
	float                                         Chance;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSBZLifeActionAnimationTags>    AnimationTags;                                     // 0x0008(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FSBZLifeActionAnimationTagsRandomizer) == 0x000008, "Wrong alignment on FSBZLifeActionAnimationTagsRandomizer");
static_assert(sizeof(FSBZLifeActionAnimationTagsRandomizer) == 0x000018, "Wrong size on FSBZLifeActionAnimationTagsRandomizer");
static_assert(offsetof(FSBZLifeActionAnimationTagsRandomizer, Chance) == 0x000000, "Member 'FSBZLifeActionAnimationTagsRandomizer::Chance' has a wrong offset!");
static_assert(offsetof(FSBZLifeActionAnimationTagsRandomizer, AnimationTags) == 0x000008, "Member 'FSBZLifeActionAnimationTagsRandomizer::AnimationTags' has a wrong offset!");

// ScriptStruct Starbreeze.SBZLifeActionRandomAnimationTagsPicker
// 0x0010 (0x0010 - 0x0000)
struct FSBZLifeActionRandomAnimationTagsPicker final
{
public:
	TArray<struct FSBZLifeActionAnimationTagsRandomizer> AnimationTagsRandomizers;                   // 0x0000(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FSBZLifeActionRandomAnimationTagsPicker) == 0x000008, "Wrong alignment on FSBZLifeActionRandomAnimationTagsPicker");
static_assert(sizeof(FSBZLifeActionRandomAnimationTagsPicker) == 0x000010, "Wrong size on FSBZLifeActionRandomAnimationTagsPicker");
static_assert(offsetof(FSBZLifeActionRandomAnimationTagsPicker, AnimationTagsRandomizers) == 0x000000, "Member 'FSBZLifeActionRandomAnimationTagsPicker::AnimationTagsRandomizers' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMesh
// 0x0020 (0x0020 - 0x0000)
struct FSBZMesh final
{
public:
	TArray<struct FVector>                        Vertices;                                          // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 Indices;                                           // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZMesh) == 0x000008, "Wrong alignment on FSBZMesh");
static_assert(sizeof(FSBZMesh) == 0x000020, "Wrong size on FSBZMesh");
static_assert(offsetof(FSBZMesh, Vertices) == 0x000000, "Member 'FSBZMesh::Vertices' has a wrong offset!");
static_assert(offsetof(FSBZMesh, Indices) == 0x000010, "Member 'FSBZMesh::Indices' has a wrong offset!");

// ScriptStruct Starbreeze.SBZStoreItemUICategory
// 0x0010 (0x0010 - 0x0000)
struct FSBZStoreItemUICategory final
{
public:
	ESBZStoreItemUICategoryType                   StoreItemUICategoryType;                           // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZStoreItemDefaultUICategory                StoreItemDefaultUICategory;                        // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class USBZStoreItemCustomUICategory*          StoreItemCustomUICategory;                         // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZStoreItemUICategory) == 0x000008, "Wrong alignment on FSBZStoreItemUICategory");
static_assert(sizeof(FSBZStoreItemUICategory) == 0x000010, "Wrong size on FSBZStoreItemUICategory");
static_assert(offsetof(FSBZStoreItemUICategory, StoreItemUICategoryType) == 0x000000, "Member 'FSBZStoreItemUICategory::StoreItemUICategoryType' has a wrong offset!");
static_assert(offsetof(FSBZStoreItemUICategory, StoreItemDefaultUICategory) == 0x000001, "Member 'FSBZStoreItemUICategory::StoreItemDefaultUICategory' has a wrong offset!");
static_assert(offsetof(FSBZStoreItemUICategory, StoreItemCustomUICategory) == 0x000008, "Member 'FSBZStoreItemUICategory::StoreItemCustomUICategory' has a wrong offset!");

// ScriptStruct Starbreeze.SBZStoreBaseItem
// 0x00D8 (0x00D8 - 0x0000)
struct FSBZStoreBaseItem
{
public:
	struct FGuid                                  ItemId;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemSku;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Price;                                             // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZCurrencyCode                              CurrencyCode;                                      // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZStoreItemPlatform                         Platform;                                          // 0x0029(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RealMoneyCurrencyCode;                             // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AvailableAtInfamyLevel;                            // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AvailableToBuy;                                    // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZItemLockReason                            ItemLockReason;                                    // 0x0045(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZItemNotLockedReason                       ItemNotLockedReason;                               // 0x0046(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47[0x1];                                       // 0x0047(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxCountPerUser;                                   // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PriceProgression;                                  // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PriceProgressionGroup;                             // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DiscountPercentage;                                // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DiscountAmount;                                    // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         DiscountedPrice;                                   // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZItemCurrencyType                          CurrencyType;                                      // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              PurchaseAt;                                        // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ExpireAt;                                          // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              DiscountPurchaseAt;                                // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              DiscountExpireAt;                                  // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZVendorData*                         VendorData;                                        // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZItemRarity                                ItemRarity;                                        // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPremiumItem;                                    // 0x00A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInexhaustibleItem;                              // 0x00A2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A3[0x5];                                       // 0x00A3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSBZStoreItemUICategory                StoreItemUICategory;                               // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	ESBZItemCategory                              ItemCategory;                                      // 0x00B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMaskOfTheWeek;                                  // 0x00B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReportsTelemetry;                                 // 0x00BA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BB[0x5];                                       // 0x00BB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FirstPlatformPurchaseUrl;                          // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsVendorPermissionRequired;                       // 0x00D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZStoreBaseItem) == 0x000008, "Wrong alignment on FSBZStoreBaseItem");
static_assert(sizeof(FSBZStoreBaseItem) == 0x0000D8, "Wrong size on FSBZStoreBaseItem");
static_assert(offsetof(FSBZStoreBaseItem, ItemId) == 0x000000, "Member 'FSBZStoreBaseItem::ItemId' has a wrong offset!");
static_assert(offsetof(FSBZStoreBaseItem, ItemSku) == 0x000010, "Member 'FSBZStoreBaseItem::ItemSku' has a wrong offset!");
static_assert(offsetof(FSBZStoreBaseItem, Price) == 0x000020, "Member 'FSBZStoreBaseItem::Price' has a wrong offset!");
static_assert(offsetof(FSBZStoreBaseItem, CurrencyCode) == 0x000028, "Member 'FSBZStoreBaseItem::CurrencyCode' has a wrong offset!");
static_assert(offsetof(FSBZStoreBaseItem, Platform) == 0x000029, "Member 'FSBZStoreBaseItem::Platform' has a wrong offset!");
static_assert(offsetof(FSBZStoreBaseItem, RealMoneyCurrencyCode) == 0x000030, "Member 'FSBZStoreBaseItem::RealMoneyCurrencyCode' has a wrong offset!");
static_assert(offsetof(FSBZStoreBaseItem, AvailableAtInfamyLevel) == 0x000040, "Member 'FSBZStoreBaseItem::AvailableAtInfamyLevel' has a wrong offset!");
static_assert(offsetof(FSBZStoreBaseItem, AvailableToBuy) == 0x000044, "Member 'FSBZStoreBaseItem::AvailableToBuy' has a wrong offset!");
static_assert(offsetof(FSBZStoreBaseItem, ItemLockReason) == 0x000045, "Member 'FSBZStoreBaseItem::ItemLockReason' has a wrong offset!");
static_assert(offsetof(FSBZStoreBaseItem, ItemNotLockedReason) == 0x000046, "Member 'FSBZStoreBaseItem::ItemNotLockedReason' has a wrong offset!");
static_assert(offsetof(FSBZStoreBaseItem, MaxCountPerUser) == 0x000048, "Member 'FSBZStoreBaseItem::MaxCountPerUser' has a wrong offset!");
static_assert(offsetof(FSBZStoreBaseItem, PriceProgression) == 0x00004C, "Member 'FSBZStoreBaseItem::PriceProgression' has a wrong offset!");
static_assert(offsetof(FSBZStoreBaseItem, PriceProgressionGroup) == 0x000050, "Member 'FSBZStoreBaseItem::PriceProgressionGroup' has a wrong offset!");
static_assert(offsetof(FSBZStoreBaseItem, DiscountPercentage) == 0x000060, "Member 'FSBZStoreBaseItem::DiscountPercentage' has a wrong offset!");
static_assert(offsetof(FSBZStoreBaseItem, DiscountAmount) == 0x000064, "Member 'FSBZStoreBaseItem::DiscountAmount' has a wrong offset!");
static_assert(offsetof(FSBZStoreBaseItem, DiscountedPrice) == 0x000068, "Member 'FSBZStoreBaseItem::DiscountedPrice' has a wrong offset!");
static_assert(offsetof(FSBZStoreBaseItem, CurrencyType) == 0x000070, "Member 'FSBZStoreBaseItem::CurrencyType' has a wrong offset!");
static_assert(offsetof(FSBZStoreBaseItem, PurchaseAt) == 0x000078, "Member 'FSBZStoreBaseItem::PurchaseAt' has a wrong offset!");
static_assert(offsetof(FSBZStoreBaseItem, ExpireAt) == 0x000080, "Member 'FSBZStoreBaseItem::ExpireAt' has a wrong offset!");
static_assert(offsetof(FSBZStoreBaseItem, DiscountPurchaseAt) == 0x000088, "Member 'FSBZStoreBaseItem::DiscountPurchaseAt' has a wrong offset!");
static_assert(offsetof(FSBZStoreBaseItem, DiscountExpireAt) == 0x000090, "Member 'FSBZStoreBaseItem::DiscountExpireAt' has a wrong offset!");
static_assert(offsetof(FSBZStoreBaseItem, VendorData) == 0x000098, "Member 'FSBZStoreBaseItem::VendorData' has a wrong offset!");
static_assert(offsetof(FSBZStoreBaseItem, ItemRarity) == 0x0000A0, "Member 'FSBZStoreBaseItem::ItemRarity' has a wrong offset!");
static_assert(offsetof(FSBZStoreBaseItem, bIsPremiumItem) == 0x0000A1, "Member 'FSBZStoreBaseItem::bIsPremiumItem' has a wrong offset!");
static_assert(offsetof(FSBZStoreBaseItem, bIsInexhaustibleItem) == 0x0000A2, "Member 'FSBZStoreBaseItem::bIsInexhaustibleItem' has a wrong offset!");
static_assert(offsetof(FSBZStoreBaseItem, StoreItemUICategory) == 0x0000A8, "Member 'FSBZStoreBaseItem::StoreItemUICategory' has a wrong offset!");
static_assert(offsetof(FSBZStoreBaseItem, ItemCategory) == 0x0000B8, "Member 'FSBZStoreBaseItem::ItemCategory' has a wrong offset!");
static_assert(offsetof(FSBZStoreBaseItem, bIsMaskOfTheWeek) == 0x0000B9, "Member 'FSBZStoreBaseItem::bIsMaskOfTheWeek' has a wrong offset!");
static_assert(offsetof(FSBZStoreBaseItem, bReportsTelemetry) == 0x0000BA, "Member 'FSBZStoreBaseItem::bReportsTelemetry' has a wrong offset!");
static_assert(offsetof(FSBZStoreBaseItem, FirstPlatformPurchaseUrl) == 0x0000C0, "Member 'FSBZStoreBaseItem::FirstPlatformPurchaseUrl' has a wrong offset!");
static_assert(offsetof(FSBZStoreBaseItem, bIsVendorPermissionRequired) == 0x0000D0, "Member 'FSBZStoreBaseItem::bIsVendorPermissionRequired' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSprayCanStoreItem
// 0x0008 (0x00E0 - 0x00D8)
struct FSBZSprayCanStoreItem final : public FSBZStoreBaseItem
{
public:
	class USBZSprayCanData*                       SprayCanData;                                      // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSprayCanStoreItem) == 0x000008, "Wrong alignment on FSBZSprayCanStoreItem");
static_assert(sizeof(FSBZSprayCanStoreItem) == 0x0000E0, "Wrong size on FSBZSprayCanStoreItem");
static_assert(offsetof(FSBZSprayCanStoreItem, SprayCanData) == 0x0000D8, "Member 'FSBZSprayCanStoreItem::SprayCanData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZDialogPlaylist
// 0x0018 (0x0018 - 0x0000)
struct FSBZDialogPlaylist final
{
public:
	TArray<class USBZDialogDataAsset*>            Dialogs;                                           // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZDialogPlaylist) == 0x000008, "Wrong alignment on FSBZDialogPlaylist");
static_assert(sizeof(FSBZDialogPlaylist) == 0x000018, "Wrong size on FSBZDialogPlaylist");
static_assert(offsetof(FSBZDialogPlaylist, Dialogs) == 0x000000, "Member 'FSBZDialogPlaylist::Dialogs' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPropDamageContext
// 0x0018 (0x0018 - 0x0000)
struct FSBZPropDamageContext final
{
public:
	struct FVector                                FromDirection;                                     // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacter*                             CharacterInstigator;                               // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPropDamageContext) == 0x000008, "Wrong alignment on FSBZPropDamageContext");
static_assert(sizeof(FSBZPropDamageContext) == 0x000018, "Wrong size on FSBZPropDamageContext");
static_assert(offsetof(FSBZPropDamageContext, FromDirection) == 0x000000, "Member 'FSBZPropDamageContext::FromDirection' has a wrong offset!");
static_assert(offsetof(FSBZPropDamageContext, CharacterInstigator) == 0x000010, "Member 'FSBZPropDamageContext::CharacterInstigator' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSkillLineCountData
// 0x0010 (0x0010 - 0x0000)
struct FSBZSkillLineCountData final
{
public:
	class USBZSkillLineData*                      SkillLine;                                         // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZSkillLineCountData) == 0x000008, "Wrong alignment on FSBZSkillLineCountData");
static_assert(sizeof(FSBZSkillLineCountData) == 0x000010, "Wrong size on FSBZSkillLineCountData");
static_assert(offsetof(FSBZSkillLineCountData, SkillLine) == 0x000000, "Member 'FSBZSkillLineCountData::SkillLine' has a wrong offset!");
static_assert(offsetof(FSBZSkillLineCountData, Count) == 0x000008, "Member 'FSBZSkillLineCountData::Count' has a wrong offset!");

// ScriptStruct Starbreeze.SBZKickingInfo
// 0x00A8 (0x00A8 - 0x0000)
struct FSBZKickingInfo final
{
public:
	bool                                          bActive;                                           // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUniqueNetIdRepl                       PlayerToKick;                                      // 0x0008(0x0028)(BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUniqueNetIdRepl                       PlayerProposed;                                    // 0x0030(0x0028)(BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FUniqueNetIdRepl>               KickVotes;                                         // 0x0058(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FUniqueNetIdRepl>               KeepVotes;                                         // 0x0068(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         VotesNeededToKick;                                 // 0x0078(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZKickingMode                               ModeKick;                                          // 0x007C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUniqueNetIdRepl>               PlayersVoted;                                      // 0x0080(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         TimeLeft;                                          // 0x0090(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              TimeKickStarted;                                   // 0x0098(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasClientKicked;                                  // 0x00A0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZKickingInfo) == 0x000008, "Wrong alignment on FSBZKickingInfo");
static_assert(sizeof(FSBZKickingInfo) == 0x0000A8, "Wrong size on FSBZKickingInfo");
static_assert(offsetof(FSBZKickingInfo, bActive) == 0x000000, "Member 'FSBZKickingInfo::bActive' has a wrong offset!");
static_assert(offsetof(FSBZKickingInfo, PlayerToKick) == 0x000008, "Member 'FSBZKickingInfo::PlayerToKick' has a wrong offset!");
static_assert(offsetof(FSBZKickingInfo, PlayerProposed) == 0x000030, "Member 'FSBZKickingInfo::PlayerProposed' has a wrong offset!");
static_assert(offsetof(FSBZKickingInfo, KickVotes) == 0x000058, "Member 'FSBZKickingInfo::KickVotes' has a wrong offset!");
static_assert(offsetof(FSBZKickingInfo, KeepVotes) == 0x000068, "Member 'FSBZKickingInfo::KeepVotes' has a wrong offset!");
static_assert(offsetof(FSBZKickingInfo, VotesNeededToKick) == 0x000078, "Member 'FSBZKickingInfo::VotesNeededToKick' has a wrong offset!");
static_assert(offsetof(FSBZKickingInfo, ModeKick) == 0x00007C, "Member 'FSBZKickingInfo::ModeKick' has a wrong offset!");
static_assert(offsetof(FSBZKickingInfo, PlayersVoted) == 0x000080, "Member 'FSBZKickingInfo::PlayersVoted' has a wrong offset!");
static_assert(offsetof(FSBZKickingInfo, TimeLeft) == 0x000090, "Member 'FSBZKickingInfo::TimeLeft' has a wrong offset!");
static_assert(offsetof(FSBZKickingInfo, TimeKickStarted) == 0x000098, "Member 'FSBZKickingInfo::TimeKickStarted' has a wrong offset!");
static_assert(offsetof(FSBZKickingInfo, bWasClientKicked) == 0x0000A0, "Member 'FSBZKickingInfo::bWasClientKicked' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAirNodeNeighborInfo
// 0x0018 (0x0018 - 0x0000)
struct FSBZAirNodeNeighborInfo final
{
public:
	uint8                                         TreeIndex;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint16>                                Indicies;                                          // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAirNodeNeighborInfo) == 0x000008, "Wrong alignment on FSBZAirNodeNeighborInfo");
static_assert(sizeof(FSBZAirNodeNeighborInfo) == 0x000018, "Wrong size on FSBZAirNodeNeighborInfo");
static_assert(offsetof(FSBZAirNodeNeighborInfo, TreeIndex) == 0x000000, "Member 'FSBZAirNodeNeighborInfo::TreeIndex' has a wrong offset!");
static_assert(offsetof(FSBZAirNodeNeighborInfo, Indicies) == 0x000008, "Member 'FSBZAirNodeNeighborInfo::Indicies' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAirNavigationNode
// 0x0030 (0x0030 - 0x0000)
struct FSBZAirNavigationNode final
{
public:
	int16                                         Center[0x3];                                       // 0x0000(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        HalfSize;                                          // 0x0006(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsLeaf : 1;                                       // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsBlocked : 1;                                    // 0x0008(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x1];                                        // 0x0009(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        FirstChildIndex;                                   // 0x000A(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSBZAirNodeNeighborInfo>        NeighborInfo;                                      // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint16>                                NavLinkIDArray;                                    // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAirNavigationNode) == 0x000008, "Wrong alignment on FSBZAirNavigationNode");
static_assert(sizeof(FSBZAirNavigationNode) == 0x000030, "Wrong size on FSBZAirNavigationNode");
static_assert(offsetof(FSBZAirNavigationNode, Center) == 0x000000, "Member 'FSBZAirNavigationNode::Center' has a wrong offset!");
static_assert(offsetof(FSBZAirNavigationNode, HalfSize) == 0x000006, "Member 'FSBZAirNavigationNode::HalfSize' has a wrong offset!");
static_assert(offsetof(FSBZAirNavigationNode, FirstChildIndex) == 0x00000A, "Member 'FSBZAirNavigationNode::FirstChildIndex' has a wrong offset!");
static_assert(offsetof(FSBZAirNavigationNode, NeighborInfo) == 0x000010, "Member 'FSBZAirNavigationNode::NeighborInfo' has a wrong offset!");
static_assert(offsetof(FSBZAirNavigationNode, NavLinkIDArray) == 0x000020, "Member 'FSBZAirNavigationNode::NavLinkIDArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAirNavigationTree
// 0x0048 (0x0048 - 0x0000)
struct FSBZAirNavigationTree final
{
public:
	TArray<struct FSBZAirNavigationNode>          Nodes;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint16                                        MinHalfSize;                                       // 0x0010(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TreeHalfSize;                                      // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                TreeCenter;                                        // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24[0x24];                                      // 0x0024(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAirNavigationTree) == 0x000008, "Wrong alignment on FSBZAirNavigationTree");
static_assert(sizeof(FSBZAirNavigationTree) == 0x000048, "Wrong size on FSBZAirNavigationTree");
static_assert(offsetof(FSBZAirNavigationTree, Nodes) == 0x000000, "Member 'FSBZAirNavigationTree::Nodes' has a wrong offset!");
static_assert(offsetof(FSBZAirNavigationTree, MinHalfSize) == 0x000010, "Member 'FSBZAirNavigationTree::MinHalfSize' has a wrong offset!");
static_assert(offsetof(FSBZAirNavigationTree, TreeHalfSize) == 0x000014, "Member 'FSBZAirNavigationTree::TreeHalfSize' has a wrong offset!");
static_assert(offsetof(FSBZAirNavigationTree, TreeCenter) == 0x000018, "Member 'FSBZAirNavigationTree::TreeCenter' has a wrong offset!");

// ScriptStruct Starbreeze.SBZRelocateRequest
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FSBZRelocateRequest final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZRelocateRequest) == 0x000004, "Wrong alignment on FSBZRelocateRequest");
static_assert(sizeof(FSBZRelocateRequest) == 0x000018, "Wrong size on FSBZRelocateRequest");

// ScriptStruct Starbreeze.SBZNewsDataUIEntry
// 0x0070 (0x0070 - 0x0000)
struct FSBZNewsDataUIEntry final
{
public:
	class FString                                 NewsId;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StackName;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Title;                                             // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Subtitle;                                          // 0x0038(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UPaperSprite*                           Image;                                             // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Link;                                              // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsExpired;                                        // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZNewsDataUIEntry) == 0x000008, "Wrong alignment on FSBZNewsDataUIEntry");
static_assert(sizeof(FSBZNewsDataUIEntry) == 0x000070, "Wrong size on FSBZNewsDataUIEntry");
static_assert(offsetof(FSBZNewsDataUIEntry, NewsId) == 0x000000, "Member 'FSBZNewsDataUIEntry::NewsId' has a wrong offset!");
static_assert(offsetof(FSBZNewsDataUIEntry, StackName) == 0x000010, "Member 'FSBZNewsDataUIEntry::StackName' has a wrong offset!");
static_assert(offsetof(FSBZNewsDataUIEntry, Title) == 0x000020, "Member 'FSBZNewsDataUIEntry::Title' has a wrong offset!");
static_assert(offsetof(FSBZNewsDataUIEntry, Subtitle) == 0x000038, "Member 'FSBZNewsDataUIEntry::Subtitle' has a wrong offset!");
static_assert(offsetof(FSBZNewsDataUIEntry, Image) == 0x000050, "Member 'FSBZNewsDataUIEntry::Image' has a wrong offset!");
static_assert(offsetof(FSBZNewsDataUIEntry, Link) == 0x000058, "Member 'FSBZNewsDataUIEntry::Link' has a wrong offset!");
static_assert(offsetof(FSBZNewsDataUIEntry, bIsExpired) == 0x000068, "Member 'FSBZNewsDataUIEntry::bIsExpired' has a wrong offset!");

// ScriptStruct Starbreeze.SBZUIStackChangedEvent
// 0x001C (0x001C - 0x0000)
struct FSBZUIStackChangedEvent final
{
public:
	class FName                                   NewValue;                                          // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OldValue;                                          // 0x000C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasAddedEvent;                                    // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZUIStackChangedEvent) == 0x000004, "Wrong alignment on FSBZUIStackChangedEvent");
static_assert(sizeof(FSBZUIStackChangedEvent) == 0x00001C, "Wrong size on FSBZUIStackChangedEvent");
static_assert(offsetof(FSBZUIStackChangedEvent, NewValue) == 0x000000, "Member 'FSBZUIStackChangedEvent::NewValue' has a wrong offset!");
static_assert(offsetof(FSBZUIStackChangedEvent, OldValue) == 0x00000C, "Member 'FSBZUIStackChangedEvent::OldValue' has a wrong offset!");
static_assert(offsetof(FSBZUIStackChangedEvent, bWasAddedEvent) == 0x000018, "Member 'FSBZUIStackChangedEvent::bWasAddedEvent' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCurrency
// 0x0018 (0x0018 - 0x0000)
struct FSBZCurrency final
{
public:
	ESBZCurrencyCode                              CurrencyType;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Amount;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LifetimeAmount;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZCurrency) == 0x000008, "Wrong alignment on FSBZCurrency");
static_assert(sizeof(FSBZCurrency) == 0x000018, "Wrong size on FSBZCurrency");
static_assert(offsetof(FSBZCurrency, CurrencyType) == 0x000000, "Member 'FSBZCurrency::CurrencyType' has a wrong offset!");
static_assert(offsetof(FSBZCurrency, Amount) == 0x000008, "Member 'FSBZCurrency::Amount' has a wrong offset!");
static_assert(offsetof(FSBZCurrency, LifetimeAmount) == 0x000010, "Member 'FSBZCurrency::LifetimeAmount' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPlayerCurrencyBalanceData
// 0x0048 (0x0048 - 0x0000)
struct FSBZPlayerCurrencyBalanceData final
{
public:
	struct FSBZCurrency                           Cash;                                              // 0x0000(0x0018)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FSBZCurrency                           Gold;                                              // 0x0018(0x0018)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FSBZCurrency                           Credit;                                            // 0x0030(0x0018)(Transient, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPlayerCurrencyBalanceData) == 0x000008, "Wrong alignment on FSBZPlayerCurrencyBalanceData");
static_assert(sizeof(FSBZPlayerCurrencyBalanceData) == 0x000048, "Wrong size on FSBZPlayerCurrencyBalanceData");
static_assert(offsetof(FSBZPlayerCurrencyBalanceData, Cash) == 0x000000, "Member 'FSBZPlayerCurrencyBalanceData::Cash' has a wrong offset!");
static_assert(offsetof(FSBZPlayerCurrencyBalanceData, Gold) == 0x000018, "Member 'FSBZPlayerCurrencyBalanceData::Gold' has a wrong offset!");
static_assert(offsetof(FSBZPlayerCurrencyBalanceData, Credit) == 0x000030, "Member 'FSBZPlayerCurrencyBalanceData::Credit' has a wrong offset!");

// ScriptStruct Starbreeze.SBZUIHUDContext
// 0x0001 (0x0001 - 0x0000)
struct FSBZUIHUDContext final
{
public:
	bool                                          bIsPlayerHUDDisplayed;                             // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZUIHUDContext) == 0x000001, "Wrong alignment on FSBZUIHUDContext");
static_assert(sizeof(FSBZUIHUDContext) == 0x000001, "Wrong size on FSBZUIHUDContext");
static_assert(offsetof(FSBZUIHUDContext, bIsPlayerHUDDisplayed) == 0x000000, "Member 'FSBZUIHUDContext::bIsPlayerHUDDisplayed' has a wrong offset!");

// ScriptStruct Starbreeze.SBZDamageDistance
// 0x0008 (0x0008 - 0x0000)
struct FSBZDamageDistance final
{
public:
	float                                         Damage;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZDamageDistance) == 0x000004, "Wrong alignment on FSBZDamageDistance");
static_assert(sizeof(FSBZDamageDistance) == 0x000008, "Wrong size on FSBZDamageDistance");
static_assert(offsetof(FSBZDamageDistance, Damage) == 0x000000, "Member 'FSBZDamageDistance::Damage' has a wrong offset!");
static_assert(offsetof(FSBZDamageDistance, Distance) == 0x000004, "Member 'FSBZDamageDistance::Distance' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAgentStateVariables
// 0x0028 (0x0028 - 0x0000)
struct FSBZAgentStateVariables
{
public:
	struct FIntVector                             Position;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FIntVector                             DesiredAcceleration;                               // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint32                                        MontageHash;                                       // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint16                                        MaxSpeed;                                          // 0x001C(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Yaw;                                               // 0x001E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         RemoteViewYaw;                                     // 0x001F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         RemoteDesiredViewYaw;                              // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESBZMovementMode                              MovementMode;                                      // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESBZCharacterMovementState                    CharacterMovementState;                            // 0x0022(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESBZTurnDirection                             TurnDirection;                                     // 0x0023(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bClearVelocity;                                    // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         MontagePosition;                                   // 0x0025(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         ReplicationGroupIndex;                             // 0x0026(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bVelocityIsRequested;                              // 0x0027(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FSBZAgentStateVariables) == 0x000004, "Wrong alignment on FSBZAgentStateVariables");
static_assert(sizeof(FSBZAgentStateVariables) == 0x000028, "Wrong size on FSBZAgentStateVariables");
static_assert(offsetof(FSBZAgentStateVariables, Position) == 0x000000, "Member 'FSBZAgentStateVariables::Position' has a wrong offset!");
static_assert(offsetof(FSBZAgentStateVariables, DesiredAcceleration) == 0x00000C, "Member 'FSBZAgentStateVariables::DesiredAcceleration' has a wrong offset!");
static_assert(offsetof(FSBZAgentStateVariables, MontageHash) == 0x000018, "Member 'FSBZAgentStateVariables::MontageHash' has a wrong offset!");
static_assert(offsetof(FSBZAgentStateVariables, MaxSpeed) == 0x00001C, "Member 'FSBZAgentStateVariables::MaxSpeed' has a wrong offset!");
static_assert(offsetof(FSBZAgentStateVariables, Yaw) == 0x00001E, "Member 'FSBZAgentStateVariables::Yaw' has a wrong offset!");
static_assert(offsetof(FSBZAgentStateVariables, RemoteViewYaw) == 0x00001F, "Member 'FSBZAgentStateVariables::RemoteViewYaw' has a wrong offset!");
static_assert(offsetof(FSBZAgentStateVariables, RemoteDesiredViewYaw) == 0x000020, "Member 'FSBZAgentStateVariables::RemoteDesiredViewYaw' has a wrong offset!");
static_assert(offsetof(FSBZAgentStateVariables, MovementMode) == 0x000021, "Member 'FSBZAgentStateVariables::MovementMode' has a wrong offset!");
static_assert(offsetof(FSBZAgentStateVariables, CharacterMovementState) == 0x000022, "Member 'FSBZAgentStateVariables::CharacterMovementState' has a wrong offset!");
static_assert(offsetof(FSBZAgentStateVariables, TurnDirection) == 0x000023, "Member 'FSBZAgentStateVariables::TurnDirection' has a wrong offset!");
static_assert(offsetof(FSBZAgentStateVariables, bClearVelocity) == 0x000024, "Member 'FSBZAgentStateVariables::bClearVelocity' has a wrong offset!");
static_assert(offsetof(FSBZAgentStateVariables, MontagePosition) == 0x000025, "Member 'FSBZAgentStateVariables::MontagePosition' has a wrong offset!");
static_assert(offsetof(FSBZAgentStateVariables, ReplicationGroupIndex) == 0x000026, "Member 'FSBZAgentStateVariables::ReplicationGroupIndex' has a wrong offset!");
static_assert(offsetof(FSBZAgentStateVariables, bVelocityIsRequested) == 0x000027, "Member 'FSBZAgentStateVariables::bVelocityIsRequested' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWindData
// 0x0018 (0x0018 - 0x0000)
struct FSBZWindData final
{
public:
	float                                         Speed;                                             // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinGustAmt;                                        // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxGustAmt;                                        // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x000C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWindData) == 0x000004, "Wrong alignment on FSBZWindData");
static_assert(sizeof(FSBZWindData) == 0x000018, "Wrong size on FSBZWindData");
static_assert(offsetof(FSBZWindData, Speed) == 0x000000, "Member 'FSBZWindData::Speed' has a wrong offset!");
static_assert(offsetof(FSBZWindData, MinGustAmt) == 0x000004, "Member 'FSBZWindData::MinGustAmt' has a wrong offset!");
static_assert(offsetof(FSBZWindData, MaxGustAmt) == 0x000008, "Member 'FSBZWindData::MaxGustAmt' has a wrong offset!");
static_assert(offsetof(FSBZWindData, Direction) == 0x00000C, "Member 'FSBZWindData::Direction' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInteractableAudioData
// 0x0018 (0x0018 - 0x0000)
struct FSBZInteractableAudioData final
{
public:
	class UAkAudioEvent*                          AudioEvent2D;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AudioEvent3D;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZVoiceCommentDataAsset*              VoiceComment;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZInteractableAudioData) == 0x000008, "Wrong alignment on FSBZInteractableAudioData");
static_assert(sizeof(FSBZInteractableAudioData) == 0x000018, "Wrong size on FSBZInteractableAudioData");
static_assert(offsetof(FSBZInteractableAudioData, AudioEvent2D) == 0x000000, "Member 'FSBZInteractableAudioData::AudioEvent2D' has a wrong offset!");
static_assert(offsetof(FSBZInteractableAudioData, AudioEvent3D) == 0x000008, "Member 'FSBZInteractableAudioData::AudioEvent3D' has a wrong offset!");
static_assert(offsetof(FSBZInteractableAudioData, VoiceComment) == 0x000010, "Member 'FSBZInteractableAudioData::VoiceComment' has a wrong offset!");

// ScriptStruct Starbreeze.SBZRewardItem
// 0x0018 (0x0018 - 0x0000)
struct FSBZRewardItem final
{
public:
	class FString                                 ItemSku;                                           // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Probability;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZRewardItem) == 0x000008, "Wrong alignment on FSBZRewardItem");
static_assert(sizeof(FSBZRewardItem) == 0x000018, "Wrong size on FSBZRewardItem");
static_assert(offsetof(FSBZRewardItem, ItemSku) == 0x000000, "Member 'FSBZRewardItem::ItemSku' has a wrong offset!");
static_assert(offsetof(FSBZRewardItem, Probability) == 0x000010, "Member 'FSBZRewardItem::Probability' has a wrong offset!");

// ScriptStruct Starbreeze.SBZDamageEvent
// 0x00C0 (0x00C0 - 0x0000)
struct FSBZDamageEvent final : public FSBZGameEventStructBase
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Causer;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZEquippableData*                     EquippableData;                                    // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZThrowableData*                      ThrowableData;                                     // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmorDamage;                                       // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Armor;                                             // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthDamage;                                      // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverHealDamage;                                    // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverskillProgressionDamage;                        // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCritical;                                       // 0x0044(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsArmorBreak;                                     // 0x0045(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsKillshot;                                       // 0x0046(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFrequent;                                       // 0x0047(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOverskillBroken;                                // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HitCount;                                          // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<ESBZArmorChunkType>                    ArmorChunkArray;                                   // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<ESBZArmorChunkType>                    ArmorChunkBreakArray;                              // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0070(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  DamageTypeTagContainer;                            // 0x0080(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         EquippableIndex;                                   // 0x00A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x1C];                                      // 0x00A4(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZDamageEvent) == 0x000008, "Wrong alignment on FSBZDamageEvent");
static_assert(sizeof(FSBZDamageEvent) == 0x0000C0, "Wrong size on FSBZDamageEvent");
static_assert(offsetof(FSBZDamageEvent, Attacker) == 0x000000, "Member 'FSBZDamageEvent::Attacker' has a wrong offset!");
static_assert(offsetof(FSBZDamageEvent, Causer) == 0x000008, "Member 'FSBZDamageEvent::Causer' has a wrong offset!");
static_assert(offsetof(FSBZDamageEvent, Victim) == 0x000010, "Member 'FSBZDamageEvent::Victim' has a wrong offset!");
static_assert(offsetof(FSBZDamageEvent, EquippableData) == 0x000018, "Member 'FSBZDamageEvent::EquippableData' has a wrong offset!");
static_assert(offsetof(FSBZDamageEvent, ThrowableData) == 0x000020, "Member 'FSBZDamageEvent::ThrowableData' has a wrong offset!");
static_assert(offsetof(FSBZDamageEvent, Damage) == 0x000028, "Member 'FSBZDamageEvent::Damage' has a wrong offset!");
static_assert(offsetof(FSBZDamageEvent, ArmorDamage) == 0x00002C, "Member 'FSBZDamageEvent::ArmorDamage' has a wrong offset!");
static_assert(offsetof(FSBZDamageEvent, Armor) == 0x000030, "Member 'FSBZDamageEvent::Armor' has a wrong offset!");
static_assert(offsetof(FSBZDamageEvent, HealthDamage) == 0x000034, "Member 'FSBZDamageEvent::HealthDamage' has a wrong offset!");
static_assert(offsetof(FSBZDamageEvent, OverHealDamage) == 0x000038, "Member 'FSBZDamageEvent::OverHealDamage' has a wrong offset!");
static_assert(offsetof(FSBZDamageEvent, OverskillProgressionDamage) == 0x00003C, "Member 'FSBZDamageEvent::OverskillProgressionDamage' has a wrong offset!");
static_assert(offsetof(FSBZDamageEvent, Distance) == 0x000040, "Member 'FSBZDamageEvent::Distance' has a wrong offset!");
static_assert(offsetof(FSBZDamageEvent, bIsCritical) == 0x000044, "Member 'FSBZDamageEvent::bIsCritical' has a wrong offset!");
static_assert(offsetof(FSBZDamageEvent, bIsArmorBreak) == 0x000045, "Member 'FSBZDamageEvent::bIsArmorBreak' has a wrong offset!");
static_assert(offsetof(FSBZDamageEvent, bIsKillshot) == 0x000046, "Member 'FSBZDamageEvent::bIsKillshot' has a wrong offset!");
static_assert(offsetof(FSBZDamageEvent, bIsFrequent) == 0x000047, "Member 'FSBZDamageEvent::bIsFrequent' has a wrong offset!");
static_assert(offsetof(FSBZDamageEvent, bIsOverskillBroken) == 0x000048, "Member 'FSBZDamageEvent::bIsOverskillBroken' has a wrong offset!");
static_assert(offsetof(FSBZDamageEvent, HitCount) == 0x00004C, "Member 'FSBZDamageEvent::HitCount' has a wrong offset!");
static_assert(offsetof(FSBZDamageEvent, ArmorChunkArray) == 0x000050, "Member 'FSBZDamageEvent::ArmorChunkArray' has a wrong offset!");
static_assert(offsetof(FSBZDamageEvent, ArmorChunkBreakArray) == 0x000060, "Member 'FSBZDamageEvent::ArmorChunkBreakArray' has a wrong offset!");
static_assert(offsetof(FSBZDamageEvent, Origin) == 0x000070, "Member 'FSBZDamageEvent::Origin' has a wrong offset!");
static_assert(offsetof(FSBZDamageEvent, DamageTypeTagContainer) == 0x000080, "Member 'FSBZDamageEvent::DamageTypeTagContainer' has a wrong offset!");
static_assert(offsetof(FSBZDamageEvent, EquippableIndex) == 0x0000A0, "Member 'FSBZDamageEvent::EquippableIndex' has a wrong offset!");

// ScriptStruct Starbreeze.SBZReviveEvent
// 0x0010 (0x0010 - 0x0000)
struct FSBZReviveEvent final : public FSBZGameEventStructBase
{
public:
	class ASBZPlayerCharacter*                    Reviver;                                           // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASBZPlayerCharacter*                    CharacterBeingRevived;                             // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZReviveEvent) == 0x000008, "Wrong alignment on FSBZReviveEvent");
static_assert(sizeof(FSBZReviveEvent) == 0x000010, "Wrong size on FSBZReviveEvent");
static_assert(offsetof(FSBZReviveEvent, Reviver) == 0x000000, "Member 'FSBZReviveEvent::Reviver' has a wrong offset!");
static_assert(offsetof(FSBZReviveEvent, CharacterBeingRevived) == 0x000008, "Member 'FSBZReviveEvent::CharacterBeingRevived' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeightTagData
// 0x0090 (0x0090 - 0x0000)
struct FSBZWeightTagData final
{
public:
	struct FGameplayTagContainer                  IncludeAnyTagContainer;                            // 0x0000(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  IncludeAllTagContainer;                            // 0x0020(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ExcludeAnyTagContainer;                            // 0x0040(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ExcludeAllTagContainer;                            // 0x0060(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         WeightTierOffset;                                  // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USBZPlayerMovementWeightAsset*          WeightOverride;                                    // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWeightTagData) == 0x000008, "Wrong alignment on FSBZWeightTagData");
static_assert(sizeof(FSBZWeightTagData) == 0x000090, "Wrong size on FSBZWeightTagData");
static_assert(offsetof(FSBZWeightTagData, IncludeAnyTagContainer) == 0x000000, "Member 'FSBZWeightTagData::IncludeAnyTagContainer' has a wrong offset!");
static_assert(offsetof(FSBZWeightTagData, IncludeAllTagContainer) == 0x000020, "Member 'FSBZWeightTagData::IncludeAllTagContainer' has a wrong offset!");
static_assert(offsetof(FSBZWeightTagData, ExcludeAnyTagContainer) == 0x000040, "Member 'FSBZWeightTagData::ExcludeAnyTagContainer' has a wrong offset!");
static_assert(offsetof(FSBZWeightTagData, ExcludeAllTagContainer) == 0x000060, "Member 'FSBZWeightTagData::ExcludeAllTagContainer' has a wrong offset!");
static_assert(offsetof(FSBZWeightTagData, WeightTierOffset) == 0x000080, "Member 'FSBZWeightTagData::WeightTierOffset' has a wrong offset!");
static_assert(offsetof(FSBZWeightTagData, WeightOverride) == 0x000088, "Member 'FSBZWeightTagData::WeightOverride' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAxisSettings
// 0x0008 (0x0008 - 0x0000)
struct FSBZAxisSettings final
{
public:
	EAxis                                         YawRotationAxis;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BodyOrientationAlpha;                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAxisSettings) == 0x000004, "Wrong alignment on FSBZAxisSettings");
static_assert(sizeof(FSBZAxisSettings) == 0x000008, "Wrong size on FSBZAxisSettings");
static_assert(offsetof(FSBZAxisSettings, YawRotationAxis) == 0x000000, "Member 'FSBZAxisSettings::YawRotationAxis' has a wrong offset!");
static_assert(offsetof(FSBZAxisSettings, BodyOrientationAlpha) == 0x000004, "Member 'FSBZAxisSettings::BodyOrientationAlpha' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAICrewChatEvent
// 0x0018 (0x0018 - 0x0000)
struct FSBZAICrewChatEvent final : public FSBZGameEventStructBase
{
public:
	class ASBZAICrewState*                        CrewState;                                         // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message;                                           // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAICrewChatEvent) == 0x000008, "Wrong alignment on FSBZAICrewChatEvent");
static_assert(sizeof(FSBZAICrewChatEvent) == 0x000018, "Wrong size on FSBZAICrewChatEvent");
static_assert(offsetof(FSBZAICrewChatEvent, CrewState) == 0x000000, "Member 'FSBZAICrewChatEvent::CrewState' has a wrong offset!");
static_assert(offsetof(FSBZAICrewChatEvent, Message) == 0x000008, "Member 'FSBZAICrewChatEvent::Message' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAgilityTraversalTrajectoryPoint
// 0x0018 (0x0018 - 0x0000)
struct FSBZAgilityTraversalTrajectoryPoint final
{
public:
	bool                                          bIsColliding;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Radius;                                            // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Height;                                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Center;                                            // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FSBZAgilityTraversalTrajectoryPoint) == 0x000004, "Wrong alignment on FSBZAgilityTraversalTrajectoryPoint");
static_assert(sizeof(FSBZAgilityTraversalTrajectoryPoint) == 0x000018, "Wrong size on FSBZAgilityTraversalTrajectoryPoint");
static_assert(offsetof(FSBZAgilityTraversalTrajectoryPoint, bIsColliding) == 0x000000, "Member 'FSBZAgilityTraversalTrajectoryPoint::bIsColliding' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTraversalTrajectoryPoint, Radius) == 0x000004, "Member 'FSBZAgilityTraversalTrajectoryPoint::Radius' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTraversalTrajectoryPoint, Height) == 0x000008, "Member 'FSBZAgilityTraversalTrajectoryPoint::Height' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTraversalTrajectoryPoint, Center) == 0x00000C, "Member 'FSBZAgilityTraversalTrajectoryPoint::Center' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAgilityTraversalTrajectory
// 0x0104 (0x0104 - 0x0000)
struct FSBZAgilityTraversalTrajectory final
{
public:
	struct FVector                                WallImpactNormal;                                  // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WallImpactLocation;                                // 0x000C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSBZAgilityTraversalTrajectoryPoint    JumpPoint;                                         // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FSBZAgilityTraversalTrajectoryPoint    EdgePointFront;                                    // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FSBZAgilityTraversalTrajectoryPoint    EdgePointBack;                                     // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FSBZAgilityTraversalTrajectoryPoint    LandPoint;                                         // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	ESBZAgilityTraversalType                      AgilityType;                                       // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEndsFalling;                                      // 0x0079(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEndsInCrouchState;                                // 0x007A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B[0x5];                                       // 0x007B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsValid;                                          // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x83];                                      // 0x0081(0x0083)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAgilityTraversalTrajectory) == 0x000004, "Wrong alignment on FSBZAgilityTraversalTrajectory");
static_assert(sizeof(FSBZAgilityTraversalTrajectory) == 0x000104, "Wrong size on FSBZAgilityTraversalTrajectory");
static_assert(offsetof(FSBZAgilityTraversalTrajectory, WallImpactNormal) == 0x000000, "Member 'FSBZAgilityTraversalTrajectory::WallImpactNormal' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTraversalTrajectory, WallImpactLocation) == 0x00000C, "Member 'FSBZAgilityTraversalTrajectory::WallImpactLocation' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTraversalTrajectory, JumpPoint) == 0x000018, "Member 'FSBZAgilityTraversalTrajectory::JumpPoint' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTraversalTrajectory, EdgePointFront) == 0x000030, "Member 'FSBZAgilityTraversalTrajectory::EdgePointFront' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTraversalTrajectory, EdgePointBack) == 0x000048, "Member 'FSBZAgilityTraversalTrajectory::EdgePointBack' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTraversalTrajectory, LandPoint) == 0x000060, "Member 'FSBZAgilityTraversalTrajectory::LandPoint' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTraversalTrajectory, AgilityType) == 0x000078, "Member 'FSBZAgilityTraversalTrajectory::AgilityType' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTraversalTrajectory, bEndsFalling) == 0x000079, "Member 'FSBZAgilityTraversalTrajectory::bEndsFalling' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTraversalTrajectory, bEndsInCrouchState) == 0x00007A, "Member 'FSBZAgilityTraversalTrajectory::bEndsInCrouchState' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTraversalTrajectory, bIsValid) == 0x000080, "Member 'FSBZAgilityTraversalTrajectory::bIsValid' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPerformanceBonusEntry
// 0x000C (0x000C - 0x0000)
struct FSBZPerformanceBonusEntry final
{
public:
	int32                                         Min;                                               // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Modifier;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPerformanceBonusEntry) == 0x000004, "Wrong alignment on FSBZPerformanceBonusEntry");
static_assert(sizeof(FSBZPerformanceBonusEntry) == 0x00000C, "Wrong size on FSBZPerformanceBonusEntry");
static_assert(offsetof(FSBZPerformanceBonusEntry, Min) == 0x000000, "Member 'FSBZPerformanceBonusEntry::Min' has a wrong offset!");
static_assert(offsetof(FSBZPerformanceBonusEntry, Max) == 0x000004, "Member 'FSBZPerformanceBonusEntry::Max' has a wrong offset!");
static_assert(offsetof(FSBZPerformanceBonusEntry, Modifier) == 0x000008, "Member 'FSBZPerformanceBonusEntry::Modifier' has a wrong offset!");

// ScriptStruct Starbreeze.SBZVotingChatEvent
// 0x0010 (0x0010 - 0x0000)
struct FSBZVotingChatEvent final : public FSBZGameEventStructBase
{
public:
	class FString                                 Message;                                           // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZVotingChatEvent) == 0x000008, "Wrong alignment on FSBZVotingChatEvent");
static_assert(sizeof(FSBZVotingChatEvent) == 0x000010, "Wrong size on FSBZVotingChatEvent");
static_assert(offsetof(FSBZVotingChatEvent, Message) == 0x000000, "Member 'FSBZVotingChatEvent::Message' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPathFocusHandler
// 0x0028 (0x0028 - 0x0000)
struct FSBZPathFocusHandler final
{
public:
	class AActor*                                 CurrentEnemy;                                      // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 TargetActor;                                       // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USBZPathFocusSettings*                  Settings;                                          // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZPathFocusHandler) == 0x000008, "Wrong alignment on FSBZPathFocusHandler");
static_assert(sizeof(FSBZPathFocusHandler) == 0x000028, "Wrong size on FSBZPathFocusHandler");
static_assert(offsetof(FSBZPathFocusHandler, CurrentEnemy) == 0x000000, "Member 'FSBZPathFocusHandler::CurrentEnemy' has a wrong offset!");
static_assert(offsetof(FSBZPathFocusHandler, TargetActor) == 0x000008, "Member 'FSBZPathFocusHandler::TargetActor' has a wrong offset!");
static_assert(offsetof(FSBZPathFocusHandler, Settings) == 0x000010, "Member 'FSBZPathFocusHandler::Settings' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPlayerPingEvent
// 0x0010 (0x0010 - 0x0000)
struct FSBZPlayerPingEvent final : public FSBZGameEventStructBase
{
public:
	class APlayerState*                           PlayerState;                                       // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZShoutTargetComponent*               ShoutoutTarget;                                    // 0x0008(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPlayerPingEvent) == 0x000008, "Wrong alignment on FSBZPlayerPingEvent");
static_assert(sizeof(FSBZPlayerPingEvent) == 0x000010, "Wrong size on FSBZPlayerPingEvent");
static_assert(offsetof(FSBZPlayerPingEvent, PlayerState) == 0x000000, "Member 'FSBZPlayerPingEvent::PlayerState' has a wrong offset!");
static_assert(offsetof(FSBZPlayerPingEvent, ShoutoutTarget) == 0x000008, "Member 'FSBZPlayerPingEvent::ShoutoutTarget' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMarkerReplication
// 0x0020 (0x0020 - 0x0000)
struct FSBZMarkerReplication final
{
public:
	uint32                                        ID;                                                // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USBZMarkerDataAsset*                    MarkerAsset;                                       // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZMarkerReplication) == 0x000008, "Wrong alignment on FSBZMarkerReplication");
static_assert(sizeof(FSBZMarkerReplication) == 0x000020, "Wrong size on FSBZMarkerReplication");
static_assert(offsetof(FSBZMarkerReplication, ID) == 0x000000, "Member 'FSBZMarkerReplication::ID' has a wrong offset!");
static_assert(offsetof(FSBZMarkerReplication, MarkerAsset) == 0x000008, "Member 'FSBZMarkerReplication::MarkerAsset' has a wrong offset!");
static_assert(offsetof(FSBZMarkerReplication, Location) == 0x000010, "Member 'FSBZMarkerReplication::Location' has a wrong offset!");

// ScriptStruct Starbreeze.SBZKeyItemCountChangedEvent
// 0x0030 (0x0030 - 0x0000)
struct FSBZKeyItemCountChangedEvent final : public FSBZGameEventStructBase
{
public:
	class APlayerState*                           PlayerState;                                       // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           KeyTag;                                            // 0x0008(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   KeyTagName;                                        // 0x0014(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZKeyItemData*                        KeyItem;                                           // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OldValue;                                          // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewValue;                                          // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZKeyItemCountChangedEvent) == 0x000008, "Wrong alignment on FSBZKeyItemCountChangedEvent");
static_assert(sizeof(FSBZKeyItemCountChangedEvent) == 0x000030, "Wrong size on FSBZKeyItemCountChangedEvent");
static_assert(offsetof(FSBZKeyItemCountChangedEvent, PlayerState) == 0x000000, "Member 'FSBZKeyItemCountChangedEvent::PlayerState' has a wrong offset!");
static_assert(offsetof(FSBZKeyItemCountChangedEvent, KeyTag) == 0x000008, "Member 'FSBZKeyItemCountChangedEvent::KeyTag' has a wrong offset!");
static_assert(offsetof(FSBZKeyItemCountChangedEvent, KeyTagName) == 0x000014, "Member 'FSBZKeyItemCountChangedEvent::KeyTagName' has a wrong offset!");
static_assert(offsetof(FSBZKeyItemCountChangedEvent, KeyItem) == 0x000020, "Member 'FSBZKeyItemCountChangedEvent::KeyItem' has a wrong offset!");
static_assert(offsetof(FSBZKeyItemCountChangedEvent, OldValue) == 0x000028, "Member 'FSBZKeyItemCountChangedEvent::OldValue' has a wrong offset!");
static_assert(offsetof(FSBZKeyItemCountChangedEvent, NewValue) == 0x00002C, "Member 'FSBZKeyItemCountChangedEvent::NewValue' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSpeedWarpingFootDefinition
// 0x0028 (0x0028 - 0x0000)
struct FSBZSpeedWarpingFootDefinition final
{
public:
	struct FBoneReference                         IKFootBone;                                        // 0x0000(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         ThighBone;                                         // 0x0014(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSpeedWarpingFootDefinition) == 0x000004, "Wrong alignment on FSBZSpeedWarpingFootDefinition");
static_assert(sizeof(FSBZSpeedWarpingFootDefinition) == 0x000028, "Wrong size on FSBZSpeedWarpingFootDefinition");
static_assert(offsetof(FSBZSpeedWarpingFootDefinition, IKFootBone) == 0x000000, "Member 'FSBZSpeedWarpingFootDefinition::IKFootBone' has a wrong offset!");
static_assert(offsetof(FSBZSpeedWarpingFootDefinition, ThighBone) == 0x000014, "Member 'FSBZSpeedWarpingFootDefinition::ThighBone' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAnimNode_SpeedWarping
// 0x0070 (0x0158 - 0x00E8)
struct FSBZAnimNode_SpeedWarping final : public FAnimNode_SkeletalControlBase
{
public:
	struct FBoneReference                         IKFootRootBone;                                    // 0x00E8(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSBZSpeedWarpingFootDefinition> FeetDefinitions;                                   // 0x0100(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         PelvisBone;                                        // 0x0110(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	EBoneControlSpace                             Space;                                             // 0x0124(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_125[0x3];                                      // 0x0125(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Direction;                                         // 0x0128(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedScaling;                                      // 0x0134(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PelvisZOffset;                                     // 0x0138(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LegsZOffset;                                       // 0x013C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PelvisLegsInterpSpeed;                             // 0x0140(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PelvisLegsAdjustmentAlpha;                         // 0x0144(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bClampIKUsingFKLeg : 1;                            // 0x0148(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_149[0xF];                                      // 0x0149(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAnimNode_SpeedWarping) == 0x000008, "Wrong alignment on FSBZAnimNode_SpeedWarping");
static_assert(sizeof(FSBZAnimNode_SpeedWarping) == 0x000158, "Wrong size on FSBZAnimNode_SpeedWarping");
static_assert(offsetof(FSBZAnimNode_SpeedWarping, IKFootRootBone) == 0x0000E8, "Member 'FSBZAnimNode_SpeedWarping::IKFootRootBone' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_SpeedWarping, FeetDefinitions) == 0x000100, "Member 'FSBZAnimNode_SpeedWarping::FeetDefinitions' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_SpeedWarping, PelvisBone) == 0x000110, "Member 'FSBZAnimNode_SpeedWarping::PelvisBone' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_SpeedWarping, Space) == 0x000124, "Member 'FSBZAnimNode_SpeedWarping::Space' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_SpeedWarping, Direction) == 0x000128, "Member 'FSBZAnimNode_SpeedWarping::Direction' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_SpeedWarping, SpeedScaling) == 0x000134, "Member 'FSBZAnimNode_SpeedWarping::SpeedScaling' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_SpeedWarping, PelvisZOffset) == 0x000138, "Member 'FSBZAnimNode_SpeedWarping::PelvisZOffset' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_SpeedWarping, LegsZOffset) == 0x00013C, "Member 'FSBZAnimNode_SpeedWarping::LegsZOffset' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_SpeedWarping, PelvisLegsInterpSpeed) == 0x000140, "Member 'FSBZAnimNode_SpeedWarping::PelvisLegsInterpSpeed' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_SpeedWarping, PelvisLegsAdjustmentAlpha) == 0x000144, "Member 'FSBZAnimNode_SpeedWarping::PelvisLegsAdjustmentAlpha' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMarkerRuntime
// 0x0090 (0x0090 - 0x0000)
struct FSBZMarkerRuntime
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USBZMarkerDataAsset*                    MarkerAsset;                                       // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZMarkerWidget*                       MarkerWidget;                                      // 0x0010(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanelSlot*                       PanelSlot;                                         // 0x0018(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        Component;                                         // 0x0020(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x68];                                      // 0x0028(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZMarkerRuntime) == 0x000008, "Wrong alignment on FSBZMarkerRuntime");
static_assert(sizeof(FSBZMarkerRuntime) == 0x000090, "Wrong size on FSBZMarkerRuntime");
static_assert(offsetof(FSBZMarkerRuntime, MarkerAsset) == 0x000008, "Member 'FSBZMarkerRuntime::MarkerAsset' has a wrong offset!");
static_assert(offsetof(FSBZMarkerRuntime, MarkerWidget) == 0x000010, "Member 'FSBZMarkerRuntime::MarkerWidget' has a wrong offset!");
static_assert(offsetof(FSBZMarkerRuntime, PanelSlot) == 0x000018, "Member 'FSBZMarkerRuntime::PanelSlot' has a wrong offset!");
static_assert(offsetof(FSBZMarkerRuntime, Component) == 0x000020, "Member 'FSBZMarkerRuntime::Component' has a wrong offset!");

// ScriptStruct Starbreeze.SBZDamageStatusMarkerRuntime
// 0x0008 (0x0098 - 0x0090)
struct FSBZDamageStatusMarkerRuntime final : public FSBZMarkerRuntime
{
public:
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZDamageStatusMarkerRuntime) == 0x000008, "Wrong alignment on FSBZDamageStatusMarkerRuntime");
static_assert(sizeof(FSBZDamageStatusMarkerRuntime) == 0x000098, "Wrong size on FSBZDamageStatusMarkerRuntime");

// ScriptStruct Starbreeze.SBZSharedKeyItemTagChangedEvent
// 0x0018 (0x0018 - 0x0000)
struct FSBZSharedKeyItemTagChangedEvent final : public FSBZGameEventStructBase
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZKeyItemData*                        KeyItem;                                           // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSharedKeyItemTagChangedEvent) == 0x000008, "Wrong alignment on FSBZSharedKeyItemTagChangedEvent");
static_assert(sizeof(FSBZSharedKeyItemTagChangedEvent) == 0x000018, "Wrong size on FSBZSharedKeyItemTagChangedEvent");
static_assert(offsetof(FSBZSharedKeyItemTagChangedEvent, Tag) == 0x000000, "Member 'FSBZSharedKeyItemTagChangedEvent::Tag' has a wrong offset!");
static_assert(offsetof(FSBZSharedKeyItemTagChangedEvent, Count) == 0x00000C, "Member 'FSBZSharedKeyItemTagChangedEvent::Count' has a wrong offset!");
static_assert(offsetof(FSBZSharedKeyItemTagChangedEvent, KeyItem) == 0x000010, "Member 'FSBZSharedKeyItemTagChangedEvent::KeyItem' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMeleeHitBoxData
// 0x0020 (0x0020 - 0x0000)
struct FSBZMeleeHitBoxData final
{
public:
	struct FVector                                HitboxSize;                                        // 0x0000(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitboxViewOffset;                                  // 0x000C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitboxViewRotation;                                // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTargetsPerHit;                                  // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZMeleeHitBoxData) == 0x000004, "Wrong alignment on FSBZMeleeHitBoxData");
static_assert(sizeof(FSBZMeleeHitBoxData) == 0x000020, "Wrong size on FSBZMeleeHitBoxData");
static_assert(offsetof(FSBZMeleeHitBoxData, HitboxSize) == 0x000000, "Member 'FSBZMeleeHitBoxData::HitboxSize' has a wrong offset!");
static_assert(offsetof(FSBZMeleeHitBoxData, HitboxViewOffset) == 0x00000C, "Member 'FSBZMeleeHitBoxData::HitboxViewOffset' has a wrong offset!");
static_assert(offsetof(FSBZMeleeHitBoxData, HitboxViewRotation) == 0x000018, "Member 'FSBZMeleeHitBoxData::HitboxViewRotation' has a wrong offset!");
static_assert(offsetof(FSBZMeleeHitBoxData, MaxTargetsPerHit) == 0x00001C, "Member 'FSBZMeleeHitBoxData::MaxTargetsPerHit' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAsyncLoadingProgress
// 0x0004 (0x0004 - 0x0000)
struct FSBZAsyncLoadingProgress final : public FSBZGameEventStructBase
{
public:
	float                                         Progress;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAsyncLoadingProgress) == 0x000004, "Wrong alignment on FSBZAsyncLoadingProgress");
static_assert(sizeof(FSBZAsyncLoadingProgress) == 0x000004, "Wrong size on FSBZAsyncLoadingProgress");
static_assert(offsetof(FSBZAsyncLoadingProgress, Progress) == 0x000000, "Member 'FSBZAsyncLoadingProgress::Progress' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAgentAvoidance
// 0x0020 (0x0020 - 0x0000)
struct FSBZAgentAvoidance final
{
public:
	int32                                         AvoidanceUID;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LockedVelocity;                                    // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timer;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BottleNeckDetectionTimer;                          // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusModifier;                                    // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetRadiusModifier;                              // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAgentAvoidance) == 0x000004, "Wrong alignment on FSBZAgentAvoidance");
static_assert(sizeof(FSBZAgentAvoidance) == 0x000020, "Wrong size on FSBZAgentAvoidance");
static_assert(offsetof(FSBZAgentAvoidance, AvoidanceUID) == 0x000000, "Member 'FSBZAgentAvoidance::AvoidanceUID' has a wrong offset!");
static_assert(offsetof(FSBZAgentAvoidance, LockedVelocity) == 0x000004, "Member 'FSBZAgentAvoidance::LockedVelocity' has a wrong offset!");
static_assert(offsetof(FSBZAgentAvoidance, Timer) == 0x000010, "Member 'FSBZAgentAvoidance::Timer' has a wrong offset!");
static_assert(offsetof(FSBZAgentAvoidance, BottleNeckDetectionTimer) == 0x000014, "Member 'FSBZAgentAvoidance::BottleNeckDetectionTimer' has a wrong offset!");
static_assert(offsetof(FSBZAgentAvoidance, RadiusModifier) == 0x000018, "Member 'FSBZAgentAvoidance::RadiusModifier' has a wrong offset!");
static_assert(offsetof(FSBZAgentAvoidance, TargetRadiusModifier) == 0x00001C, "Member 'FSBZAgentAvoidance::TargetRadiusModifier' has a wrong offset!");

// ScriptStruct Starbreeze.SBZGameDifficultyChangedEvent
// 0x0001 (0x0001 - 0x0000)
struct FSBZGameDifficultyChangedEvent final : public FSBZGameEventStructBase
{
public:
	uint8                                         DifficultyIdx;                                     // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZGameDifficultyChangedEvent) == 0x000001, "Wrong alignment on FSBZGameDifficultyChangedEvent");
static_assert(sizeof(FSBZGameDifficultyChangedEvent) == 0x000001, "Wrong size on FSBZGameDifficultyChangedEvent");
static_assert(offsetof(FSBZGameDifficultyChangedEvent, DifficultyIdx) == 0x000000, "Member 'FSBZGameDifficultyChangedEvent::DifficultyIdx' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSequenceViewerSet
// 0x0010 (0x0010 - 0x0000)
struct FSBZSequenceViewerSet final
{
public:
	TArray<class AActor*>                         SequenceViewerArray;                               // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSequenceViewerSet) == 0x000008, "Wrong alignment on FSBZSequenceViewerSet");
static_assert(sizeof(FSBZSequenceViewerSet) == 0x000010, "Wrong size on FSBZSequenceViewerSet");
static_assert(offsetof(FSBZSequenceViewerSet, SequenceViewerArray) == 0x000000, "Member 'FSBZSequenceViewerSet::SequenceViewerArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZDefeatStateChangedData
// 0x0003 (0x0003 - 0x0000)
struct FSBZDefeatStateChangedData : public FSBZGameEventStructBase
{
public:
	EPD3DefeatState                               OldDefeatState;                                    // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPD3DefeatState                               NewDefeatState;                                    // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInitialDefeatStateChange;                       // 0x0002(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZDefeatStateChangedData) == 0x000001, "Wrong alignment on FSBZDefeatStateChangedData");
static_assert(sizeof(FSBZDefeatStateChangedData) == 0x000003, "Wrong size on FSBZDefeatStateChangedData");
static_assert(offsetof(FSBZDefeatStateChangedData, OldDefeatState) == 0x000000, "Member 'FSBZDefeatStateChangedData::OldDefeatState' has a wrong offset!");
static_assert(offsetof(FSBZDefeatStateChangedData, NewDefeatState) == 0x000001, "Member 'FSBZDefeatStateChangedData::NewDefeatState' has a wrong offset!");
static_assert(offsetof(FSBZDefeatStateChangedData, bIsInitialDefeatStateChange) == 0x000002, "Member 'FSBZDefeatStateChangedData::bIsInitialDefeatStateChange' has a wrong offset!");

// ScriptStruct Starbreeze.SBZDifficultyConfiguration
// 0x0060 (0x0060 - 0x0000)
struct FSBZDifficultyConfiguration final
{
public:
	class FString                                 LevelShortName;                                    // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Normal;                                            // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         Hard;                                              // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         VeryHard;                                          // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         Overkill;                                          // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZDifficultyConfiguration) == 0x000008, "Wrong alignment on FSBZDifficultyConfiguration");
static_assert(sizeof(FSBZDifficultyConfiguration) == 0x000060, "Wrong size on FSBZDifficultyConfiguration");
static_assert(offsetof(FSBZDifficultyConfiguration, LevelShortName) == 0x000000, "Member 'FSBZDifficultyConfiguration::LevelShortName' has a wrong offset!");
static_assert(offsetof(FSBZDifficultyConfiguration, Description) == 0x000010, "Member 'FSBZDifficultyConfiguration::Description' has a wrong offset!");
static_assert(offsetof(FSBZDifficultyConfiguration, Normal) == 0x000020, "Member 'FSBZDifficultyConfiguration::Normal' has a wrong offset!");
static_assert(offsetof(FSBZDifficultyConfiguration, Hard) == 0x000030, "Member 'FSBZDifficultyConfiguration::Hard' has a wrong offset!");
static_assert(offsetof(FSBZDifficultyConfiguration, VeryHard) == 0x000040, "Member 'FSBZDifficultyConfiguration::VeryHard' has a wrong offset!");
static_assert(offsetof(FSBZDifficultyConfiguration, Overkill) == 0x000050, "Member 'FSBZDifficultyConfiguration::Overkill' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSecurityFirmRotation
// 0x0010 (0x0010 - 0x0000)
struct FSBZSecurityFirmRotation final
{
public:
	TArray<struct FSBZDifficultyConfiguration>    Configurations;                                    // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSecurityFirmRotation) == 0x000008, "Wrong alignment on FSBZSecurityFirmRotation");
static_assert(sizeof(FSBZSecurityFirmRotation) == 0x000010, "Wrong size on FSBZSecurityFirmRotation");
static_assert(offsetof(FSBZSecurityFirmRotation, Configurations) == 0x000000, "Member 'FSBZSecurityFirmRotation::Configurations' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPlayerDefeatStateChangedData
// 0x000D (0x0010 - 0x0003)
struct FSBZPlayerDefeatStateChangedData final : public FSBZDefeatStateChangedData
{
public:
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class ASBZPlayerState*                        PlayerState;                                       // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPlayerDefeatStateChangedData) == 0x000008, "Wrong alignment on FSBZPlayerDefeatStateChangedData");
static_assert(sizeof(FSBZPlayerDefeatStateChangedData) == 0x000010, "Wrong size on FSBZPlayerDefeatStateChangedData");
static_assert(offsetof(FSBZPlayerDefeatStateChangedData, PlayerState) == 0x000008, "Member 'FSBZPlayerDefeatStateChangedData::PlayerState' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCheaterHandlingSettings
// 0x0008 (0x0008 - 0x0000)
struct FSBZCheaterHandlingSettings final
{
public:
	ESBZCheaterPolicyType                         CheaterPolicy;                                     // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZNotOwningHeistPolicyType                  NotOwningHeistPolicyType;                          // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BanPeriodInDays;                                   // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZCheaterHandlingSettings) == 0x000004, "Wrong alignment on FSBZCheaterHandlingSettings");
static_assert(sizeof(FSBZCheaterHandlingSettings) == 0x000008, "Wrong size on FSBZCheaterHandlingSettings");
static_assert(offsetof(FSBZCheaterHandlingSettings, CheaterPolicy) == 0x000000, "Member 'FSBZCheaterHandlingSettings::CheaterPolicy' has a wrong offset!");
static_assert(offsetof(FSBZCheaterHandlingSettings, NotOwningHeistPolicyType) == 0x000001, "Member 'FSBZCheaterHandlingSettings::NotOwningHeistPolicyType' has a wrong offset!");
static_assert(offsetof(FSBZCheaterHandlingSettings, BanPeriodInDays) == 0x000004, "Member 'FSBZCheaterHandlingSettings::BanPeriodInDays' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAICrewDefeatStateChangedData
// 0x000D (0x0010 - 0x0003)
struct FSBZAICrewDefeatStateChangedData final : public FSBZDefeatStateChangedData
{
public:
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class ASBZAICrewState*                        AICrewState;                                       // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAICrewDefeatStateChangedData) == 0x000008, "Wrong alignment on FSBZAICrewDefeatStateChangedData");
static_assert(sizeof(FSBZAICrewDefeatStateChangedData) == 0x000010, "Wrong size on FSBZAICrewDefeatStateChangedData");
static_assert(offsetof(FSBZAICrewDefeatStateChangedData, AICrewState) == 0x000008, "Member 'FSBZAICrewDefeatStateChangedData::AICrewState' has a wrong offset!");

// ScriptStruct Starbreeze.SBZChallengesDsSettingsBlock
// 0x0010 (0x0010 - 0x0000)
struct FSBZChallengesDsSettingsBlock final
{
public:
	TArray<struct FSBZChallengeData>              SlotArray;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZChallengesDsSettingsBlock) == 0x000008, "Wrong alignment on FSBZChallengesDsSettingsBlock");
static_assert(sizeof(FSBZChallengesDsSettingsBlock) == 0x000010, "Wrong size on FSBZChallengesDsSettingsBlock");
static_assert(offsetof(FSBZChallengesDsSettingsBlock, SlotArray) == 0x000000, "Member 'FSBZChallengesDsSettingsBlock::SlotArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPlayersCarryBagChangedEvent
// 0x0010 (0x0010 - 0x0000)
struct FSBZPlayersCarryBagChangedEvent final : public FSBZGameEventStructBase
{
public:
	class USBZBagType*                            BagType;                                           // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoCosmetics;                                      // 0x000C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZPlayersCarryBagChangedEvent) == 0x000008, "Wrong alignment on FSBZPlayersCarryBagChangedEvent");
static_assert(sizeof(FSBZPlayersCarryBagChangedEvent) == 0x000010, "Wrong size on FSBZPlayersCarryBagChangedEvent");
static_assert(offsetof(FSBZPlayersCarryBagChangedEvent, BagType) == 0x000000, "Member 'FSBZPlayersCarryBagChangedEvent::BagType' has a wrong offset!");
static_assert(offsetof(FSBZPlayersCarryBagChangedEvent, Amount) == 0x000008, "Member 'FSBZPlayersCarryBagChangedEvent::Amount' has a wrong offset!");
static_assert(offsetof(FSBZPlayersCarryBagChangedEvent, bDoCosmetics) == 0x00000C, "Member 'FSBZPlayersCarryBagChangedEvent::bDoCosmetics' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeaponConfigInventorySlot
// 0x0080 (0x0080 - 0x0000)
struct FSBZWeaponConfigInventorySlot final
{
public:
	struct FSBZEquippableConfig                   EquippableConfig;                                  // 0x0000(0x0070)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	TArray<class FString>                         PayedWeaponPartAttachmentItemIdArray;              // 0x0070(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWeaponConfigInventorySlot) == 0x000008, "Wrong alignment on FSBZWeaponConfigInventorySlot");
static_assert(sizeof(FSBZWeaponConfigInventorySlot) == 0x000080, "Wrong size on FSBZWeaponConfigInventorySlot");
static_assert(offsetof(FSBZWeaponConfigInventorySlot, EquippableConfig) == 0x000000, "Member 'FSBZWeaponConfigInventorySlot::EquippableConfig' has a wrong offset!");
static_assert(offsetof(FSBZWeaponConfigInventorySlot, PayedWeaponPartAttachmentItemIdArray) == 0x000070, "Member 'FSBZWeaponConfigInventorySlot::PayedWeaponPartAttachmentItemIdArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeaponPresetConfigInventorySlot
// 0x0008 (0x0008 - 0x0000)
struct FSBZWeaponPresetConfigInventorySlot final
{
public:
	class USBZWeaponPresetConfigData*             WeaponPresetConfigData;                            // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWeaponPresetConfigInventorySlot) == 0x000008, "Wrong alignment on FSBZWeaponPresetConfigInventorySlot");
static_assert(sizeof(FSBZWeaponPresetConfigInventorySlot) == 0x000008, "Wrong size on FSBZWeaponPresetConfigInventorySlot");
static_assert(offsetof(FSBZWeaponPresetConfigInventorySlot, WeaponPresetConfigData) == 0x000000, "Member 'FSBZWeaponPresetConfigInventorySlot::WeaponPresetConfigData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeaponInventorySlot
// 0x00B0 (0x00D8 - 0x0028)
struct FSBZWeaponInventorySlot final : public FSBZInventorySlot
{
public:
	struct FGuid                                  WeaponInSlotEntitlementId;                         // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WeaponInSlotAccelByteItemSku;                      // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZItemInventorySlotType                     WeaponInventorySlotType;                           // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSBZWeaponConfigInventorySlot          WeaponConfigInventorySlot;                         // 0x0050(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FSBZWeaponPresetConfigInventorySlot    WeaponPresetConfigInventorySlot;                   // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWeaponInventorySlot) == 0x000008, "Wrong alignment on FSBZWeaponInventorySlot");
static_assert(sizeof(FSBZWeaponInventorySlot) == 0x0000D8, "Wrong size on FSBZWeaponInventorySlot");
static_assert(offsetof(FSBZWeaponInventorySlot, WeaponInSlotEntitlementId) == 0x000028, "Member 'FSBZWeaponInventorySlot::WeaponInSlotEntitlementId' has a wrong offset!");
static_assert(offsetof(FSBZWeaponInventorySlot, WeaponInSlotAccelByteItemSku) == 0x000038, "Member 'FSBZWeaponInventorySlot::WeaponInSlotAccelByteItemSku' has a wrong offset!");
static_assert(offsetof(FSBZWeaponInventorySlot, WeaponInventorySlotType) == 0x000048, "Member 'FSBZWeaponInventorySlot::WeaponInventorySlotType' has a wrong offset!");
static_assert(offsetof(FSBZWeaponInventorySlot, WeaponConfigInventorySlot) == 0x000050, "Member 'FSBZWeaponInventorySlot::WeaponConfigInventorySlot' has a wrong offset!");
static_assert(offsetof(FSBZWeaponInventorySlot, WeaponPresetConfigInventorySlot) == 0x0000D0, "Member 'FSBZWeaponInventorySlot::WeaponPresetConfigInventorySlot' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAgentStateBase
// 0x0004 (0x002C - 0x0028)
struct FSBZAgentStateBase : public FSBZAgentStateVariables
{
public:
	uint32                                        Id;                                                // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FSBZAgentStateBase) == 0x000004, "Wrong alignment on FSBZAgentStateBase");
static_assert(sizeof(FSBZAgentStateBase) == 0x00002C, "Wrong size on FSBZAgentStateBase");
static_assert(offsetof(FSBZAgentStateBase, Id) == 0x000028, "Member 'FSBZAgentStateBase::Id' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeaponAttributIdentifier
// 0x0050 (0x0050 - 0x0000)
struct FSBZWeaponAttributIdentifier final
{
public:
	class FName                                   Name;                                              // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Context;                                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsParent;                                         // 0x0020(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ESBZWeaponAttribute>                   ChildAttributeArray;                               // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0038(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWeaponAttributIdentifier) == 0x000008, "Wrong alignment on FSBZWeaponAttributIdentifier");
static_assert(sizeof(FSBZWeaponAttributIdentifier) == 0x000050, "Wrong size on FSBZWeaponAttributIdentifier");
static_assert(offsetof(FSBZWeaponAttributIdentifier, Name) == 0x000000, "Member 'FSBZWeaponAttributIdentifier::Name' has a wrong offset!");
static_assert(offsetof(FSBZWeaponAttributIdentifier, Context) == 0x000010, "Member 'FSBZWeaponAttributIdentifier::Context' has a wrong offset!");
static_assert(offsetof(FSBZWeaponAttributIdentifier, bIsParent) == 0x000020, "Member 'FSBZWeaponAttributIdentifier::bIsParent' has a wrong offset!");
static_assert(offsetof(FSBZWeaponAttributIdentifier, ChildAttributeArray) == 0x000028, "Member 'FSBZWeaponAttributIdentifier::ChildAttributeArray' has a wrong offset!");
static_assert(offsetof(FSBZWeaponAttributIdentifier, DisplayName) == 0x000038, "Member 'FSBZWeaponAttributIdentifier::DisplayName' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeaponModificationData
// 0x00B0 (0x00B0 - 0x0000)
struct FSBZWeaponModificationData final
{
public:
	TSoftObjectPtr<class USBZUIWeaponStatsAsset>  WeaponStatsAssetPath;                              // 0x0000(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   SuppressorDisplayName;                             // 0x0030(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   MagazineDisplayName;                               // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<ESBZWeaponAttribute, struct FSBZWeaponAttributIdentifier> AttributeIdentifierMap;           // 0x0060(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWeaponModificationData) == 0x000008, "Wrong alignment on FSBZWeaponModificationData");
static_assert(sizeof(FSBZWeaponModificationData) == 0x0000B0, "Wrong size on FSBZWeaponModificationData");
static_assert(offsetof(FSBZWeaponModificationData, WeaponStatsAssetPath) == 0x000000, "Member 'FSBZWeaponModificationData::WeaponStatsAssetPath' has a wrong offset!");
static_assert(offsetof(FSBZWeaponModificationData, SuppressorDisplayName) == 0x000030, "Member 'FSBZWeaponModificationData::SuppressorDisplayName' has a wrong offset!");
static_assert(offsetof(FSBZWeaponModificationData, MagazineDisplayName) == 0x000048, "Member 'FSBZWeaponModificationData::MagazineDisplayName' has a wrong offset!");
static_assert(offsetof(FSBZWeaponModificationData, AttributeIdentifierMap) == 0x000060, "Member 'FSBZWeaponModificationData::AttributeIdentifierMap' has a wrong offset!");

// ScriptStruct Starbreeze.SBZTagReactionEffect
// 0x0018 (0x0018 - 0x0000)
struct FSBZTagReactionEffect final
{
public:
	class UNiagaraComponent*                      TagReactionEffect;                                 // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZTagReactionEffect) == 0x000008, "Wrong alignment on FSBZTagReactionEffect");
static_assert(sizeof(FSBZTagReactionEffect) == 0x000018, "Wrong size on FSBZTagReactionEffect");
static_assert(offsetof(FSBZTagReactionEffect, TagReactionEffect) == 0x000000, "Member 'FSBZTagReactionEffect::TagReactionEffect' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPlayerCosmeticsConfig
// 0x000C (0x000C - 0x0000)
struct FSBZPlayerCosmeticsConfig final
{
public:
	int32                                         MaskConfigSlotIndex;                               // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SuitConfigSlotIndex;                               // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GloveConfigSlotIndex;                              // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPlayerCosmeticsConfig) == 0x000004, "Wrong alignment on FSBZPlayerCosmeticsConfig");
static_assert(sizeof(FSBZPlayerCosmeticsConfig) == 0x00000C, "Wrong size on FSBZPlayerCosmeticsConfig");
static_assert(offsetof(FSBZPlayerCosmeticsConfig, MaskConfigSlotIndex) == 0x000000, "Member 'FSBZPlayerCosmeticsConfig::MaskConfigSlotIndex' has a wrong offset!");
static_assert(offsetof(FSBZPlayerCosmeticsConfig, SuitConfigSlotIndex) == 0x000004, "Member 'FSBZPlayerCosmeticsConfig::SuitConfigSlotIndex' has a wrong offset!");
static_assert(offsetof(FSBZPlayerCosmeticsConfig, GloveConfigSlotIndex) == 0x000008, "Member 'FSBZPlayerCosmeticsConfig::GloveConfigSlotIndex' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPreferredPlayerCharacterArray
// 0x0010 (0x0010 - 0x0000)
struct FSBZPreferredPlayerCharacterArray final
{
public:
	TArray<class USBZPlayerCharacterData*>        PlayerPreferredCharacterArray;                     // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPreferredPlayerCharacterArray) == 0x000008, "Wrong alignment on FSBZPreferredPlayerCharacterArray");
static_assert(sizeof(FSBZPreferredPlayerCharacterArray) == 0x000010, "Wrong size on FSBZPreferredPlayerCharacterArray");
static_assert(offsetof(FSBZPreferredPlayerCharacterArray, PlayerPreferredCharacterArray) == 0x000000, "Member 'FSBZPreferredPlayerCharacterArray::PlayerPreferredCharacterArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPlayerLoadoutConfig
// 0x0098 (0x0098 - 0x0000)
struct FSBZPlayerLoadoutConfig final
{
public:
	class FString                                 LoadoutName;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrimaryWeaponConfigSlotIndex;                      // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SecondaryWeaponConfigSlotIndex;                    // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSBZPlayerCosmeticsConfig              PlayerCosmeticsConfig;                             // 0x0018(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ArmorConfigSlotIndex;                              // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSBZPreferredPlayerCharacterArray      PreferredPlayerCharacterArray;                     // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class USBZEquippableData*                     OverkillWeapon;                                    // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZOverskillLoadoutData*               OverskillLoadout;                                  // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZThrowableData*                      Throwable;                                         // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZToolData*                           Tool;                                              // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZPlaceableData*                      Placeable;                                         // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USBZSkillData*>                  Skills;                                            // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class USBZSkillData*>                  RemovedOverskillSkillArray;                        // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class USBZArmorData*                          Armor;                                             // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<ESBZArmorChunkType>                    ChunkTypeArray;                                    // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPlayerLoadoutConfig) == 0x000008, "Wrong alignment on FSBZPlayerLoadoutConfig");
static_assert(sizeof(FSBZPlayerLoadoutConfig) == 0x000098, "Wrong size on FSBZPlayerLoadoutConfig");
static_assert(offsetof(FSBZPlayerLoadoutConfig, LoadoutName) == 0x000000, "Member 'FSBZPlayerLoadoutConfig::LoadoutName' has a wrong offset!");
static_assert(offsetof(FSBZPlayerLoadoutConfig, PrimaryWeaponConfigSlotIndex) == 0x000010, "Member 'FSBZPlayerLoadoutConfig::PrimaryWeaponConfigSlotIndex' has a wrong offset!");
static_assert(offsetof(FSBZPlayerLoadoutConfig, SecondaryWeaponConfigSlotIndex) == 0x000014, "Member 'FSBZPlayerLoadoutConfig::SecondaryWeaponConfigSlotIndex' has a wrong offset!");
static_assert(offsetof(FSBZPlayerLoadoutConfig, PlayerCosmeticsConfig) == 0x000018, "Member 'FSBZPlayerLoadoutConfig::PlayerCosmeticsConfig' has a wrong offset!");
static_assert(offsetof(FSBZPlayerLoadoutConfig, ArmorConfigSlotIndex) == 0x000024, "Member 'FSBZPlayerLoadoutConfig::ArmorConfigSlotIndex' has a wrong offset!");
static_assert(offsetof(FSBZPlayerLoadoutConfig, PreferredPlayerCharacterArray) == 0x000028, "Member 'FSBZPlayerLoadoutConfig::PreferredPlayerCharacterArray' has a wrong offset!");
static_assert(offsetof(FSBZPlayerLoadoutConfig, OverkillWeapon) == 0x000038, "Member 'FSBZPlayerLoadoutConfig::OverkillWeapon' has a wrong offset!");
static_assert(offsetof(FSBZPlayerLoadoutConfig, OverskillLoadout) == 0x000040, "Member 'FSBZPlayerLoadoutConfig::OverskillLoadout' has a wrong offset!");
static_assert(offsetof(FSBZPlayerLoadoutConfig, Throwable) == 0x000048, "Member 'FSBZPlayerLoadoutConfig::Throwable' has a wrong offset!");
static_assert(offsetof(FSBZPlayerLoadoutConfig, Tool) == 0x000050, "Member 'FSBZPlayerLoadoutConfig::Tool' has a wrong offset!");
static_assert(offsetof(FSBZPlayerLoadoutConfig, Placeable) == 0x000058, "Member 'FSBZPlayerLoadoutConfig::Placeable' has a wrong offset!");
static_assert(offsetof(FSBZPlayerLoadoutConfig, Skills) == 0x000060, "Member 'FSBZPlayerLoadoutConfig::Skills' has a wrong offset!");
static_assert(offsetof(FSBZPlayerLoadoutConfig, RemovedOverskillSkillArray) == 0x000070, "Member 'FSBZPlayerLoadoutConfig::RemovedOverskillSkillArray' has a wrong offset!");
static_assert(offsetof(FSBZPlayerLoadoutConfig, Armor) == 0x000080, "Member 'FSBZPlayerLoadoutConfig::Armor' has a wrong offset!");
static_assert(offsetof(FSBZPlayerLoadoutConfig, ChunkTypeArray) == 0x000088, "Member 'FSBZPlayerLoadoutConfig::ChunkTypeArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZHurtReactionAnimation
// 0x0010 (0x0010 - 0x0000)
struct FSBZHurtReactionAnimation final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZHurtReactionAnimation) == 0x000008, "Wrong alignment on FSBZHurtReactionAnimation");
static_assert(sizeof(FSBZHurtReactionAnimation) == 0x000010, "Wrong size on FSBZHurtReactionAnimation");
static_assert(offsetof(FSBZHurtReactionAnimation, Montage) == 0x000000, "Member 'FSBZHurtReactionAnimation::Montage' has a wrong offset!");
static_assert(offsetof(FSBZHurtReactionAnimation, Index) == 0x000008, "Member 'FSBZHurtReactionAnimation::Index' has a wrong offset!");

// ScriptStruct Starbreeze.SBZHurtReactionDirection
// 0x0040 (0x0040 - 0x0000)
struct FSBZHurtReactionDirection final
{
public:
	TArray<struct FSBZHurtReactionAnimation>      Forward;                                           // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSBZHurtReactionAnimation>      Right;                                             // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSBZHurtReactionAnimation>      Backward;                                          // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSBZHurtReactionAnimation>      Left;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZHurtReactionDirection) == 0x000008, "Wrong alignment on FSBZHurtReactionDirection");
static_assert(sizeof(FSBZHurtReactionDirection) == 0x000040, "Wrong size on FSBZHurtReactionDirection");
static_assert(offsetof(FSBZHurtReactionDirection, Forward) == 0x000000, "Member 'FSBZHurtReactionDirection::Forward' has a wrong offset!");
static_assert(offsetof(FSBZHurtReactionDirection, Right) == 0x000010, "Member 'FSBZHurtReactionDirection::Right' has a wrong offset!");
static_assert(offsetof(FSBZHurtReactionDirection, Backward) == 0x000020, "Member 'FSBZHurtReactionDirection::Backward' has a wrong offset!");
static_assert(offsetof(FSBZHurtReactionDirection, Left) == 0x000030, "Member 'FSBZHurtReactionDirection::Left' has a wrong offset!");

// ScriptStruct Starbreeze.SBZBoneHurtReaction
// 0x0060 (0x0060 - 0x0000)
struct FSBZBoneHurtReaction final
{
public:
	class FName                                   DefaultBoneName;                                   // 0x0000(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FSBZHurtReactionDirection> BoneMap;                                     // 0x0010(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZBoneHurtReaction) == 0x000008, "Wrong alignment on FSBZBoneHurtReaction");
static_assert(sizeof(FSBZBoneHurtReaction) == 0x000060, "Wrong size on FSBZBoneHurtReaction");
static_assert(offsetof(FSBZBoneHurtReaction, DefaultBoneName) == 0x000000, "Member 'FSBZBoneHurtReaction::DefaultBoneName' has a wrong offset!");
static_assert(offsetof(FSBZBoneHurtReaction, BoneMap) == 0x000010, "Member 'FSBZBoneHurtReaction::BoneMap' has a wrong offset!");

// ScriptStruct Starbreeze.SBZGasCellHitData
// 0x0080 (0x0080 - 0x0000)
struct alignas(0x10) FSBZGasCellHitData final
{
public:
	class UPrimitiveComponent*                    HitComponent;                                      // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x78];                                       // 0x0008(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZGasCellHitData) == 0x000010, "Wrong alignment on FSBZGasCellHitData");
static_assert(sizeof(FSBZGasCellHitData) == 0x000080, "Wrong size on FSBZGasCellHitData");
static_assert(offsetof(FSBZGasCellHitData, HitComponent) == 0x000000, "Member 'FSBZGasCellHitData::HitComponent' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAirPathQueryResult
// 0x0068 (0x0068 - 0x0000)
struct alignas(0x08) FSBZAirPathQueryResult final
{
public:
	uint8                                         Pad_0[0x68];                                       // 0x0000(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAirPathQueryResult) == 0x000008, "Wrong alignment on FSBZAirPathQueryResult");
static_assert(sizeof(FSBZAirPathQueryResult) == 0x000068, "Wrong size on FSBZAirPathQueryResult");

// ScriptStruct Starbreeze.SBZVoiceEventData
// 0x0018 (0x0018 - 0x0000)
struct FSBZVoiceEventData final
{
public:
	class UAkAudioEvent*                          AudioEvent;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SwitchGroup;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZVoiceEventData) == 0x000008, "Wrong alignment on FSBZVoiceEventData");
static_assert(sizeof(FSBZVoiceEventData) == 0x000018, "Wrong size on FSBZVoiceEventData");
static_assert(offsetof(FSBZVoiceEventData, AudioEvent) == 0x000000, "Member 'FSBZVoiceEventData::AudioEvent' has a wrong offset!");
static_assert(offsetof(FSBZVoiceEventData, SwitchGroup) == 0x000008, "Member 'FSBZVoiceEventData::SwitchGroup' has a wrong offset!");

// ScriptStruct Starbreeze.SBZReconnectPlayerStateLoadoutData
// 0x0070 (0x0070 - 0x0000)
struct FSBZReconnectPlayerStateLoadoutData final
{
public:
	float                                         HealthScale;                                       // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmorTrauma;                                       // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmorScale;                                        // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownedCount;                                       // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<ESBZArmorChunkType>                    ChunkTypeArray;                                    // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<float>                                 EquippableAmmoLoadedScaleArray;                    // 0x0020(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<float>                                 EquippableAmmoInventoryScaleArray;                 // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<float>                                 ThrowableAmmoInventoryScaleArray;                  // 0x0040(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<float>                                 ToolPlaceableAmmoInventoryScaleArray;              // 0x0050(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<float>                                 ToolAmmoInventoryScaleArray;                       // 0x0060(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZReconnectPlayerStateLoadoutData) == 0x000008, "Wrong alignment on FSBZReconnectPlayerStateLoadoutData");
static_assert(sizeof(FSBZReconnectPlayerStateLoadoutData) == 0x000070, "Wrong size on FSBZReconnectPlayerStateLoadoutData");
static_assert(offsetof(FSBZReconnectPlayerStateLoadoutData, HealthScale) == 0x000000, "Member 'FSBZReconnectPlayerStateLoadoutData::HealthScale' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateLoadoutData, ArmorTrauma) == 0x000004, "Member 'FSBZReconnectPlayerStateLoadoutData::ArmorTrauma' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateLoadoutData, ArmorScale) == 0x000008, "Member 'FSBZReconnectPlayerStateLoadoutData::ArmorScale' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateLoadoutData, DownedCount) == 0x00000C, "Member 'FSBZReconnectPlayerStateLoadoutData::DownedCount' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateLoadoutData, ChunkTypeArray) == 0x000010, "Member 'FSBZReconnectPlayerStateLoadoutData::ChunkTypeArray' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateLoadoutData, EquippableAmmoLoadedScaleArray) == 0x000020, "Member 'FSBZReconnectPlayerStateLoadoutData::EquippableAmmoLoadedScaleArray' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateLoadoutData, EquippableAmmoInventoryScaleArray) == 0x000030, "Member 'FSBZReconnectPlayerStateLoadoutData::EquippableAmmoInventoryScaleArray' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateLoadoutData, ThrowableAmmoInventoryScaleArray) == 0x000040, "Member 'FSBZReconnectPlayerStateLoadoutData::ThrowableAmmoInventoryScaleArray' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateLoadoutData, ToolPlaceableAmmoInventoryScaleArray) == 0x000050, "Member 'FSBZReconnectPlayerStateLoadoutData::ToolPlaceableAmmoInventoryScaleArray' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateLoadoutData, ToolAmmoInventoryScaleArray) == 0x000060, "Member 'FSBZReconnectPlayerStateLoadoutData::ToolAmmoInventoryScaleArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPawnSpawnRequestHandle
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FSBZPawnSpawnRequestHandle final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZPawnSpawnRequestHandle) == 0x000008, "Wrong alignment on FSBZPawnSpawnRequestHandle");
static_assert(sizeof(FSBZPawnSpawnRequestHandle) == 0x000010, "Wrong size on FSBZPawnSpawnRequestHandle");

// ScriptStruct Starbreeze.SBZDetectionData
// 0x0010 (0x0010 - 0x0000)
struct FSBZDetectionData final
{
public:
	class AActor*                                 Detector;                                          // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Detection;                                         // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZDetectionData) == 0x000008, "Wrong alignment on FSBZDetectionData");
static_assert(sizeof(FSBZDetectionData) == 0x000010, "Wrong size on FSBZDetectionData");
static_assert(offsetof(FSBZDetectionData, Detector) == 0x000000, "Member 'FSBZDetectionData::Detector' has a wrong offset!");
static_assert(offsetof(FSBZDetectionData, Detection) == 0x000008, "Member 'FSBZDetectionData::Detection' has a wrong offset!");

// ScriptStruct Starbreeze.SBZActorSpawnRequestHandle
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FSBZActorSpawnRequestHandle final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZActorSpawnRequestHandle) == 0x000008, "Wrong alignment on FSBZActorSpawnRequestHandle");
static_assert(sizeof(FSBZActorSpawnRequestHandle) == 0x000010, "Wrong size on FSBZActorSpawnRequestHandle");

// ScriptStruct Starbreeze.SBZRagdollSyncData
// 0x0010 (0x0010 - 0x0000)
struct FSBZRagdollSyncData final
{
public:
	struct FVector_NetQuantize                    HipsLocation;                                      // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        NetID;                                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZRagdollSyncData) == 0x000004, "Wrong alignment on FSBZRagdollSyncData");
static_assert(sizeof(FSBZRagdollSyncData) == 0x000010, "Wrong size on FSBZRagdollSyncData");
static_assert(offsetof(FSBZRagdollSyncData, HipsLocation) == 0x000000, "Member 'FSBZRagdollSyncData::HipsLocation' has a wrong offset!");
static_assert(offsetof(FSBZRagdollSyncData, NetID) == 0x00000C, "Member 'FSBZRagdollSyncData::NetID' has a wrong offset!");

// ScriptStruct Starbreeze.SBZJoinableHeistData
// 0x0060 (0x0060 - 0x0000)
struct FSBZJoinableHeistData final
{
public:
	class FString                                 SessionID;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HeistName;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HeistOwner;                                        // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZDifficulty                                Difficulty;                                        // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZOnlineTacticType                          Tactic;                                            // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZOnlineJoinType                            LobbyType;                                         // 0x0032(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33[0x1];                                       // 0x0033(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PeopleAmount;                                      // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFriendSession;                                  // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x27];                                      // 0x0039(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZJoinableHeistData) == 0x000008, "Wrong alignment on FSBZJoinableHeistData");
static_assert(sizeof(FSBZJoinableHeistData) == 0x000060, "Wrong size on FSBZJoinableHeistData");
static_assert(offsetof(FSBZJoinableHeistData, SessionID) == 0x000000, "Member 'FSBZJoinableHeistData::SessionID' has a wrong offset!");
static_assert(offsetof(FSBZJoinableHeistData, HeistName) == 0x000010, "Member 'FSBZJoinableHeistData::HeistName' has a wrong offset!");
static_assert(offsetof(FSBZJoinableHeistData, HeistOwner) == 0x000020, "Member 'FSBZJoinableHeistData::HeistOwner' has a wrong offset!");
static_assert(offsetof(FSBZJoinableHeistData, Difficulty) == 0x000030, "Member 'FSBZJoinableHeistData::Difficulty' has a wrong offset!");
static_assert(offsetof(FSBZJoinableHeistData, Tactic) == 0x000031, "Member 'FSBZJoinableHeistData::Tactic' has a wrong offset!");
static_assert(offsetof(FSBZJoinableHeistData, LobbyType) == 0x000032, "Member 'FSBZJoinableHeistData::LobbyType' has a wrong offset!");
static_assert(offsetof(FSBZJoinableHeistData, PeopleAmount) == 0x000034, "Member 'FSBZJoinableHeistData::PeopleAmount' has a wrong offset!");
static_assert(offsetof(FSBZJoinableHeistData, bIsFriendSession) == 0x000038, "Member 'FSBZJoinableHeistData::bIsFriendSession' has a wrong offset!");

// ScriptStruct Starbreeze.SBZServerBrowserHeistLevel
// 0x0080 (0x00B8 - 0x0038)
struct FSBZServerBrowserHeistLevel final : public FSBZHeistLevelWithOwnership
{
public:
	class FText                                   LevelName;                                         // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         LevelIndex;                                        // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CollectionIndex;                                   // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSBZJoinableHeistData                  JoinableHeistData;                                 // 0x0058(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZServerBrowserHeistLevel) == 0x000008, "Wrong alignment on FSBZServerBrowserHeistLevel");
static_assert(sizeof(FSBZServerBrowserHeistLevel) == 0x0000B8, "Wrong size on FSBZServerBrowserHeistLevel");
static_assert(offsetof(FSBZServerBrowserHeistLevel, LevelName) == 0x000038, "Member 'FSBZServerBrowserHeistLevel::LevelName' has a wrong offset!");
static_assert(offsetof(FSBZServerBrowserHeistLevel, LevelIndex) == 0x000050, "Member 'FSBZServerBrowserHeistLevel::LevelIndex' has a wrong offset!");
static_assert(offsetof(FSBZServerBrowserHeistLevel, CollectionIndex) == 0x000054, "Member 'FSBZServerBrowserHeistLevel::CollectionIndex' has a wrong offset!");
static_assert(offsetof(FSBZServerBrowserHeistLevel, JoinableHeistData) == 0x000058, "Member 'FSBZServerBrowserHeistLevel::JoinableHeistData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZServerBrowserHeistCollection
// 0x0030 (0x0030 - 0x0000)
struct FSBZServerBrowserHeistCollection final
{
public:
	class FText                                   HeistCollectionName;                               // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSBZServerBrowserHeistLevel>    LevelArray;                                        // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bContainsStoryModeContent;                         // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZServerBrowserHeistCollection) == 0x000008, "Wrong alignment on FSBZServerBrowserHeistCollection");
static_assert(sizeof(FSBZServerBrowserHeistCollection) == 0x000030, "Wrong size on FSBZServerBrowserHeistCollection");
static_assert(offsetof(FSBZServerBrowserHeistCollection, HeistCollectionName) == 0x000000, "Member 'FSBZServerBrowserHeistCollection::HeistCollectionName' has a wrong offset!");
static_assert(offsetof(FSBZServerBrowserHeistCollection, LevelArray) == 0x000018, "Member 'FSBZServerBrowserHeistCollection::LevelArray' has a wrong offset!");
static_assert(offsetof(FSBZServerBrowserHeistCollection, bContainsStoryModeContent) == 0x000028, "Member 'FSBZServerBrowserHeistCollection::bContainsStoryModeContent' has a wrong offset!");

// ScriptStruct Starbreeze.SBZFloatLimit
// 0x0008 (0x0008 - 0x0000)
struct FSBZFloatLimit final
{
public:
	float                                         Limit;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZComparisonType                            Type;                                              // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZFloatLimit) == 0x000004, "Wrong alignment on FSBZFloatLimit");
static_assert(sizeof(FSBZFloatLimit) == 0x000008, "Wrong size on FSBZFloatLimit");
static_assert(offsetof(FSBZFloatLimit, Limit) == 0x000000, "Member 'FSBZFloatLimit::Limit' has a wrong offset!");
static_assert(offsetof(FSBZFloatLimit, Type) == 0x000004, "Member 'FSBZFloatLimit::Type' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWorldHandIKHandler
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x04) FSBZWorldHandIKHandler final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZWorldHandIKHandler) == 0x000004, "Wrong alignment on FSBZWorldHandIKHandler");
static_assert(sizeof(FSBZWorldHandIKHandler) == 0x000038, "Wrong size on FSBZWorldHandIKHandler");

// ScriptStruct Starbreeze.SBZEventIndexes
// 0x0010 (0x0010 - 0x0000)
struct FSBZEventIndexes final
{
public:
	TArray<int32>                                 IndexArray;                                        // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZEventIndexes) == 0x000008, "Wrong alignment on FSBZEventIndexes");
static_assert(sizeof(FSBZEventIndexes) == 0x000010, "Wrong size on FSBZEventIndexes");
static_assert(offsetof(FSBZEventIndexes, IndexArray) == 0x000000, "Member 'FSBZEventIndexes::IndexArray' has a wrong offset!");

// ScriptStruct Starbreeze.PD3DramaSettings
// 0x00E0 (0x00E0 - 0x0000)
struct FPD3DramaSettings final
{
public:
	float                                         FullyDecaySeconds;                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecayDelayTime;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerHurtChange;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     PlayerHurtDistanceMultiplier;                      // 0x0010(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         PlayerDefeatedChange;                              // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerKilledChange;                                // 0x009C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AIKillDistance;                                    // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AIKillDramaIncreaseAmount;                         // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AITypesToIgnore;                                   // 0x00A8(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<float>                                 DramaAlivePlayersModifier;                         // 0x00C8(0x0010)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         DramaCooldownTime;                                 // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DramaSpawnModifier;                                // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPD3DramaSettings) == 0x000008, "Wrong alignment on FPD3DramaSettings");
static_assert(sizeof(FPD3DramaSettings) == 0x0000E0, "Wrong size on FPD3DramaSettings");
static_assert(offsetof(FPD3DramaSettings, FullyDecaySeconds) == 0x000000, "Member 'FPD3DramaSettings::FullyDecaySeconds' has a wrong offset!");
static_assert(offsetof(FPD3DramaSettings, DecayDelayTime) == 0x000004, "Member 'FPD3DramaSettings::DecayDelayTime' has a wrong offset!");
static_assert(offsetof(FPD3DramaSettings, PlayerHurtChange) == 0x000008, "Member 'FPD3DramaSettings::PlayerHurtChange' has a wrong offset!");
static_assert(offsetof(FPD3DramaSettings, PlayerHurtDistanceMultiplier) == 0x000010, "Member 'FPD3DramaSettings::PlayerHurtDistanceMultiplier' has a wrong offset!");
static_assert(offsetof(FPD3DramaSettings, PlayerDefeatedChange) == 0x000098, "Member 'FPD3DramaSettings::PlayerDefeatedChange' has a wrong offset!");
static_assert(offsetof(FPD3DramaSettings, PlayerKilledChange) == 0x00009C, "Member 'FPD3DramaSettings::PlayerKilledChange' has a wrong offset!");
static_assert(offsetof(FPD3DramaSettings, AIKillDistance) == 0x0000A0, "Member 'FPD3DramaSettings::AIKillDistance' has a wrong offset!");
static_assert(offsetof(FPD3DramaSettings, AIKillDramaIncreaseAmount) == 0x0000A4, "Member 'FPD3DramaSettings::AIKillDramaIncreaseAmount' has a wrong offset!");
static_assert(offsetof(FPD3DramaSettings, AITypesToIgnore) == 0x0000A8, "Member 'FPD3DramaSettings::AITypesToIgnore' has a wrong offset!");
static_assert(offsetof(FPD3DramaSettings, DramaAlivePlayersModifier) == 0x0000C8, "Member 'FPD3DramaSettings::DramaAlivePlayersModifier' has a wrong offset!");
static_assert(offsetof(FPD3DramaSettings, DramaCooldownTime) == 0x0000D8, "Member 'FPD3DramaSettings::DramaCooldownTime' has a wrong offset!");
static_assert(offsetof(FPD3DramaSettings, DramaSpawnModifier) == 0x0000DC, "Member 'FPD3DramaSettings::DramaSpawnModifier' has a wrong offset!");

// ScriptStruct Starbreeze.SBZRewardCategory
// 0x0028 (0x0028 - 0x0000)
struct FSBZRewardCategory final
{
public:
	class FString                                 CategoryName;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSBZRewardItem>                 CategorySkuItems;                                  // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         Probability;                                       // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZRewardCategory) == 0x000008, "Wrong alignment on FSBZRewardCategory");
static_assert(sizeof(FSBZRewardCategory) == 0x000028, "Wrong size on FSBZRewardCategory");
static_assert(offsetof(FSBZRewardCategory, CategoryName) == 0x000000, "Member 'FSBZRewardCategory::CategoryName' has a wrong offset!");
static_assert(offsetof(FSBZRewardCategory, CategorySkuItems) == 0x000010, "Member 'FSBZRewardCategory::CategorySkuItems' has a wrong offset!");
static_assert(offsetof(FSBZRewardCategory, Probability) == 0x000020, "Member 'FSBZRewardCategory::Probability' has a wrong offset!");

// ScriptStruct Starbreeze.SBZRenownRewardConfiguration
// 0x0018 (0x0018 - 0x0000)
struct FSBZRenownRewardConfiguration final
{
public:
	TArray<struct FSBZRewardCategory>             RewardCategoryArray;                               // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         InfamyPointsForReward;                             // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxRenownLevel;                                    // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZRenownRewardConfiguration) == 0x000008, "Wrong alignment on FSBZRenownRewardConfiguration");
static_assert(sizeof(FSBZRenownRewardConfiguration) == 0x000018, "Wrong size on FSBZRenownRewardConfiguration");
static_assert(offsetof(FSBZRenownRewardConfiguration, RewardCategoryArray) == 0x000000, "Member 'FSBZRenownRewardConfiguration::RewardCategoryArray' has a wrong offset!");
static_assert(offsetof(FSBZRenownRewardConfiguration, InfamyPointsForReward) == 0x000010, "Member 'FSBZRenownRewardConfiguration::InfamyPointsForReward' has a wrong offset!");
static_assert(offsetof(FSBZRenownRewardConfiguration, MaxRenownLevel) == 0x000014, "Member 'FSBZRenownRewardConfiguration::MaxRenownLevel' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSpawnWaveSegmentSettings
// 0x0050 (0x0050 - 0x0000)
struct FSBZSpawnWaveSegmentSettings final
{
public:
	class FName                                   Name;                                              // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSquads;                                        // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPD3PawnVariation*>              PawnVariations;                                    // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class APD3PawnSpawnGroup*>             SpawnerGroups;                                     // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class USBZAISquadOrder>           SquadOrder;                                        // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ASBZPawnSpawnPredefined*>        SpecificSpawners;                                  // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZSpawnWaveSegmentSettings) == 0x000008, "Wrong alignment on FSBZSpawnWaveSegmentSettings");
static_assert(sizeof(FSBZSpawnWaveSegmentSettings) == 0x000050, "Wrong size on FSBZSpawnWaveSegmentSettings");
static_assert(offsetof(FSBZSpawnWaveSegmentSettings, Name) == 0x000000, "Member 'FSBZSpawnWaveSegmentSettings::Name' has a wrong offset!");
static_assert(offsetof(FSBZSpawnWaveSegmentSettings, bUseSquads) == 0x00000C, "Member 'FSBZSpawnWaveSegmentSettings::bUseSquads' has a wrong offset!");
static_assert(offsetof(FSBZSpawnWaveSegmentSettings, PawnVariations) == 0x000010, "Member 'FSBZSpawnWaveSegmentSettings::PawnVariations' has a wrong offset!");
static_assert(offsetof(FSBZSpawnWaveSegmentSettings, SpawnerGroups) == 0x000020, "Member 'FSBZSpawnWaveSegmentSettings::SpawnerGroups' has a wrong offset!");
static_assert(offsetof(FSBZSpawnWaveSegmentSettings, SquadOrder) == 0x000030, "Member 'FSBZSpawnWaveSegmentSettings::SquadOrder' has a wrong offset!");
static_assert(offsetof(FSBZSpawnWaveSegmentSettings, SpecificSpawners) == 0x000038, "Member 'FSBZSpawnWaveSegmentSettings::SpecificSpawners' has a wrong offset!");
static_assert(offsetof(FSBZSpawnWaveSegmentSettings, Weight) == 0x000048, "Member 'FSBZSpawnWaveSegmentSettings::Weight' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSpawnWaveTypeLimit
// 0x000C (0x000C - 0x0000)
struct FSBZSpawnWaveTypeLimit final
{
public:
	int32                                         CountLimit;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cooldown;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KilledCooldown;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSpawnWaveTypeLimit) == 0x000004, "Wrong alignment on FSBZSpawnWaveTypeLimit");
static_assert(sizeof(FSBZSpawnWaveTypeLimit) == 0x00000C, "Wrong size on FSBZSpawnWaveTypeLimit");
static_assert(offsetof(FSBZSpawnWaveTypeLimit, CountLimit) == 0x000000, "Member 'FSBZSpawnWaveTypeLimit::CountLimit' has a wrong offset!");
static_assert(offsetof(FSBZSpawnWaveTypeLimit, Cooldown) == 0x000004, "Member 'FSBZSpawnWaveTypeLimit::Cooldown' has a wrong offset!");
static_assert(offsetof(FSBZSpawnWaveTypeLimit, KilledCooldown) == 0x000008, "Member 'FSBZSpawnWaveTypeLimit::KilledCooldown' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSpawnWaveSquadOrderLimits
// 0x0008 (0x0008 - 0x0000)
struct FSBZSpawnWaveSquadOrderLimits final
{
public:
	int32                                         OrderCountLimit;                                   // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OrderCooldown;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSpawnWaveSquadOrderLimits) == 0x000004, "Wrong alignment on FSBZSpawnWaveSquadOrderLimits");
static_assert(sizeof(FSBZSpawnWaveSquadOrderLimits) == 0x000008, "Wrong size on FSBZSpawnWaveSquadOrderLimits");
static_assert(offsetof(FSBZSpawnWaveSquadOrderLimits, OrderCountLimit) == 0x000000, "Member 'FSBZSpawnWaveSquadOrderLimits::OrderCountLimit' has a wrong offset!");
static_assert(offsetof(FSBZSpawnWaveSquadOrderLimits, OrderCooldown) == 0x000004, "Member 'FSBZSpawnWaveSquadOrderLimits::OrderCooldown' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSpawnWaveSettings
// 0x00C0 (0x00C0 - 0x0000)
struct FSBZSpawnWaveSettings final
{
public:
	class FName                                   Name;                                              // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnInterval;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FSBZSpawnWaveTypeLimit> SpawnTypeLimits;                        // 0x0010(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<TSoftClassPtr<class UClass>, struct FSBZSpawnWaveSquadOrderLimits> AllSquadOrderLimits;     // 0x0060(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FSBZSpawnWaveSegmentSettings>   AllWaveSegmentSettings;                            // 0x00B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSpawnWaveSettings) == 0x000008, "Wrong alignment on FSBZSpawnWaveSettings");
static_assert(sizeof(FSBZSpawnWaveSettings) == 0x0000C0, "Wrong size on FSBZSpawnWaveSettings");
static_assert(offsetof(FSBZSpawnWaveSettings, Name) == 0x000000, "Member 'FSBZSpawnWaveSettings::Name' has a wrong offset!");
static_assert(offsetof(FSBZSpawnWaveSettings, SpawnInterval) == 0x00000C, "Member 'FSBZSpawnWaveSettings::SpawnInterval' has a wrong offset!");
static_assert(offsetof(FSBZSpawnWaveSettings, SpawnTypeLimits) == 0x000010, "Member 'FSBZSpawnWaveSettings::SpawnTypeLimits' has a wrong offset!");
static_assert(offsetof(FSBZSpawnWaveSettings, AllSquadOrderLimits) == 0x000060, "Member 'FSBZSpawnWaveSettings::AllSquadOrderLimits' has a wrong offset!");
static_assert(offsetof(FSBZSpawnWaveSettings, AllWaveSegmentSettings) == 0x0000B0, "Member 'FSBZSpawnWaveSettings::AllWaveSegmentSettings' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSpawnWaveManagerDifficultySettings
// 0x0010 (0x0010 - 0x0000)
struct FSBZSpawnWaveManagerDifficultySettings final
{
public:
	TArray<struct FSBZSpawnWaveSettings>          SpawnWaveSettingsArray;                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSpawnWaveManagerDifficultySettings) == 0x000008, "Wrong alignment on FSBZSpawnWaveManagerDifficultySettings");
static_assert(sizeof(FSBZSpawnWaveManagerDifficultySettings) == 0x000010, "Wrong size on FSBZSpawnWaveManagerDifficultySettings");
static_assert(offsetof(FSBZSpawnWaveManagerDifficultySettings, SpawnWaveSettingsArray) == 0x000000, "Member 'FSBZSpawnWaveManagerDifficultySettings::SpawnWaveSettingsArray' has a wrong offset!");

// ScriptStruct Starbreeze.PD3SpawnSquad
// 0x0038 (0x0038 - 0x0000)
struct FPD3SpawnSquad final
{
public:
	TArray<class UPD3SpawnSquadPawn*>             PawnArray;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  CachedPawnTypes;                                   // 0x0018(0x0020)(Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FPD3SpawnSquad) == 0x000008, "Wrong alignment on FPD3SpawnSquad");
static_assert(sizeof(FPD3SpawnSquad) == 0x000038, "Wrong size on FPD3SpawnSquad");
static_assert(offsetof(FPD3SpawnSquad, PawnArray) == 0x000000, "Member 'FPD3SpawnSquad::PawnArray' has a wrong offset!");
static_assert(offsetof(FPD3SpawnSquad, Weight) == 0x000010, "Member 'FPD3SpawnSquad::Weight' has a wrong offset!");
static_assert(offsetof(FPD3SpawnSquad, CachedPawnTypes) == 0x000018, "Member 'FPD3SpawnSquad::CachedPawnTypes' has a wrong offset!");

// ScriptStruct Starbreeze.PD3AssaultProgressionSettings
// 0x0018 (0x0018 - 0x0000)
struct FPD3AssaultProgressionSettings final
{
public:
	float                                         StartAtProgression;                                // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPD3SpawnSquad>                 SquadArray;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPD3AssaultProgressionSettings) == 0x000008, "Wrong alignment on FPD3AssaultProgressionSettings");
static_assert(sizeof(FPD3AssaultProgressionSettings) == 0x000018, "Wrong size on FPD3AssaultProgressionSettings");
static_assert(offsetof(FPD3AssaultProgressionSettings, StartAtProgression) == 0x000000, "Member 'FPD3AssaultProgressionSettings::StartAtProgression' has a wrong offset!");
static_assert(offsetof(FPD3AssaultProgressionSettings, SquadArray) == 0x000008, "Member 'FPD3AssaultProgressionSettings::SquadArray' has a wrong offset!");

// ScriptStruct Starbreeze.PD3AssaultWaitPhaseSettings
// 0x0008 (0x0008 - 0x0000)
struct FPD3AssaultWaitPhaseSettings final
{
public:
	float                                         StartAtProgression;                                // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitPhaseDuration;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPD3AssaultWaitPhaseSettings) == 0x000004, "Wrong alignment on FPD3AssaultWaitPhaseSettings");
static_assert(sizeof(FPD3AssaultWaitPhaseSettings) == 0x000008, "Wrong size on FPD3AssaultWaitPhaseSettings");
static_assert(offsetof(FPD3AssaultWaitPhaseSettings, StartAtProgression) == 0x000000, "Member 'FPD3AssaultWaitPhaseSettings::StartAtProgression' has a wrong offset!");
static_assert(offsetof(FPD3AssaultWaitPhaseSettings, WaitPhaseDuration) == 0x000004, "Member 'FPD3AssaultWaitPhaseSettings::WaitPhaseDuration' has a wrong offset!");

// ScriptStruct Starbreeze.PD3AssaulSustainPhaseSettings
// 0x0008 (0x0008 - 0x0000)
struct FPD3AssaulSustainPhaseSettings final
{
public:
	float                                         StartAtProgression;                                // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SustainPhaseDuration;                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPD3AssaulSustainPhaseSettings) == 0x000004, "Wrong alignment on FPD3AssaulSustainPhaseSettings");
static_assert(sizeof(FPD3AssaulSustainPhaseSettings) == 0x000008, "Wrong size on FPD3AssaulSustainPhaseSettings");
static_assert(offsetof(FPD3AssaulSustainPhaseSettings, StartAtProgression) == 0x000000, "Member 'FPD3AssaulSustainPhaseSettings::StartAtProgression' has a wrong offset!");
static_assert(offsetof(FPD3AssaulSustainPhaseSettings, SustainPhaseDuration) == 0x000004, "Member 'FPD3AssaulSustainPhaseSettings::SustainPhaseDuration' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSquadLimits
// 0x0014 (0x0014 - 0x0000)
struct FSBZSquadLimits final
{
public:
	int32                                         MaxNumSquadsAlive;                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNumSquadsPerWave;                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNumPawnsAlive;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNumPawnsPerPlayer;                              // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SquadCooldown;                                     // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSquadLimits) == 0x000004, "Wrong alignment on FSBZSquadLimits");
static_assert(sizeof(FSBZSquadLimits) == 0x000014, "Wrong size on FSBZSquadLimits");
static_assert(offsetof(FSBZSquadLimits, MaxNumSquadsAlive) == 0x000000, "Member 'FSBZSquadLimits::MaxNumSquadsAlive' has a wrong offset!");
static_assert(offsetof(FSBZSquadLimits, MaxNumSquadsPerWave) == 0x000004, "Member 'FSBZSquadLimits::MaxNumSquadsPerWave' has a wrong offset!");
static_assert(offsetof(FSBZSquadLimits, MaxNumPawnsAlive) == 0x000008, "Member 'FSBZSquadLimits::MaxNumPawnsAlive' has a wrong offset!");
static_assert(offsetof(FSBZSquadLimits, MaxNumPawnsPerPlayer) == 0x00000C, "Member 'FSBZSquadLimits::MaxNumPawnsPerPlayer' has a wrong offset!");
static_assert(offsetof(FSBZSquadLimits, SquadCooldown) == 0x000010, "Member 'FSBZSquadLimits::SquadCooldown' has a wrong offset!");

// ScriptStruct Starbreeze.PD3AssaultDifficultySettings
// 0x00D8 (0x00D8 - 0x0000)
struct FPD3AssaultDifficultySettings final
{
public:
	int32                                         MaxAliveAISpawnCount;                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowMixing;                                      // 0x0004(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPD3AssaultProgressionSettings> ProgressionArray;                                  // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FPD3AssaultWaitPhaseSettings>   WaitPhaseDurationProgressionArray;                 // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPD3AssaulSustainPhaseSettings> SustainPhaseDurationProgressionArray;              // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<TSoftClassPtr<class UClass>, struct FSBZSquadLimits> SquadLimits;                           // 0x0038(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, int32>              TypeLimits;                                        // 0x0088(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPD3AssaultDifficultySettings) == 0x000008, "Wrong alignment on FPD3AssaultDifficultySettings");
static_assert(sizeof(FPD3AssaultDifficultySettings) == 0x0000D8, "Wrong size on FPD3AssaultDifficultySettings");
static_assert(offsetof(FPD3AssaultDifficultySettings, MaxAliveAISpawnCount) == 0x000000, "Member 'FPD3AssaultDifficultySettings::MaxAliveAISpawnCount' has a wrong offset!");
static_assert(offsetof(FPD3AssaultDifficultySettings, bAllowMixing) == 0x000004, "Member 'FPD3AssaultDifficultySettings::bAllowMixing' has a wrong offset!");
static_assert(offsetof(FPD3AssaultDifficultySettings, ProgressionArray) == 0x000008, "Member 'FPD3AssaultDifficultySettings::ProgressionArray' has a wrong offset!");
static_assert(offsetof(FPD3AssaultDifficultySettings, WaitPhaseDurationProgressionArray) == 0x000018, "Member 'FPD3AssaultDifficultySettings::WaitPhaseDurationProgressionArray' has a wrong offset!");
static_assert(offsetof(FPD3AssaultDifficultySettings, SustainPhaseDurationProgressionArray) == 0x000028, "Member 'FPD3AssaultDifficultySettings::SustainPhaseDurationProgressionArray' has a wrong offset!");
static_assert(offsetof(FPD3AssaultDifficultySettings, SquadLimits) == 0x000038, "Member 'FPD3AssaultDifficultySettings::SquadLimits' has a wrong offset!");
static_assert(offsetof(FPD3AssaultDifficultySettings, TypeLimits) == 0x000088, "Member 'FPD3AssaultDifficultySettings::TypeLimits' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMeleeTargetData
// 0x5B98 (0x5BA0 - 0x0008)
struct FSBZMeleeTargetData : public FGameplayAbilityTargetData
{
public:
	uint8                                         Pad_8[0x5B98];                                     // 0x0008(0x5B98)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZMeleeTargetData) == 0x000008, "Wrong alignment on FSBZMeleeTargetData");
static_assert(sizeof(FSBZMeleeTargetData) == 0x005BA0, "Wrong size on FSBZMeleeTargetData");

// ScriptStruct Starbreeze.SBZSkillTriggeredHurtTargetData
// 0x0000 (0x5BA0 - 0x5BA0)
struct FSBZSkillTriggeredHurtTargetData final : public FSBZMeleeTargetData
{
};
static_assert(alignof(FSBZSkillTriggeredHurtTargetData) == 0x000008, "Wrong alignment on FSBZSkillTriggeredHurtTargetData");
static_assert(sizeof(FSBZSkillTriggeredHurtTargetData) == 0x005BA0, "Wrong size on FSBZSkillTriggeredHurtTargetData");

// ScriptStruct Starbreeze.SBZItemEntitlementArray
// 0x0010 (0x0010 - 0x0000)
struct FSBZItemEntitlementArray final
{
public:
	TArray<class FString>                         PlayerItemSkuArray;                                // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZItemEntitlementArray) == 0x000008, "Wrong alignment on FSBZItemEntitlementArray");
static_assert(sizeof(FSBZItemEntitlementArray) == 0x000010, "Wrong size on FSBZItemEntitlementArray");
static_assert(offsetof(FSBZItemEntitlementArray, PlayerItemSkuArray) == 0x000000, "Member 'FSBZItemEntitlementArray::PlayerItemSkuArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZBaseImpactData
// 0x0028 (0x0028 - 0x0000)
struct FSBZBaseImpactData
{
public:
	class UNiagaraSystem*                         Effect;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             Decals;                                            // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 OverrideMaterialSoundSwitchState;                  // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZBaseImpactData) == 0x000008, "Wrong alignment on FSBZBaseImpactData");
static_assert(sizeof(FSBZBaseImpactData) == 0x000028, "Wrong size on FSBZBaseImpactData");
static_assert(offsetof(FSBZBaseImpactData, Effect) == 0x000000, "Member 'FSBZBaseImpactData::Effect' has a wrong offset!");
static_assert(offsetof(FSBZBaseImpactData, Decals) == 0x000008, "Member 'FSBZBaseImpactData::Decals' has a wrong offset!");
static_assert(offsetof(FSBZBaseImpactData, OverrideMaterialSoundSwitchState) == 0x000018, "Member 'FSBZBaseImpactData::OverrideMaterialSoundSwitchState' has a wrong offset!");

// ScriptStruct Starbreeze.PD3AssaultPlatformSettings
// 0x000C (0x000C - 0x0000)
struct FPD3AssaultPlatformSettings final
{
public:
	int32                                         MaxTotalAISpawnCountModifier;                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxAliveAISpawnCountModifier;                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSpawnGroupQueryCountModifier;                   // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPD3AssaultPlatformSettings) == 0x000004, "Wrong alignment on FPD3AssaultPlatformSettings");
static_assert(sizeof(FPD3AssaultPlatformSettings) == 0x00000C, "Wrong size on FPD3AssaultPlatformSettings");
static_assert(offsetof(FPD3AssaultPlatformSettings, MaxTotalAISpawnCountModifier) == 0x000000, "Member 'FPD3AssaultPlatformSettings::MaxTotalAISpawnCountModifier' has a wrong offset!");
static_assert(offsetof(FPD3AssaultPlatformSettings, MaxAliveAISpawnCountModifier) == 0x000004, "Member 'FPD3AssaultPlatformSettings::MaxAliveAISpawnCountModifier' has a wrong offset!");
static_assert(offsetof(FPD3AssaultPlatformSettings, MaxSpawnGroupQueryCountModifier) == 0x000008, "Member 'FPD3AssaultPlatformSettings::MaxSpawnGroupQueryCountModifier' has a wrong offset!");

// ScriptStruct Starbreeze.SBZGamepadBindingInputAction
// 0x000C (0x000C - 0x0000)
struct FSBZGamepadBindingInputAction final
{
public:
	class FName                                   ActionName;                                        // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZGamepadBindingInputAction) == 0x000004, "Wrong alignment on FSBZGamepadBindingInputAction");
static_assert(sizeof(FSBZGamepadBindingInputAction) == 0x00000C, "Wrong size on FSBZGamepadBindingInputAction");
static_assert(offsetof(FSBZGamepadBindingInputAction, ActionName) == 0x000000, "Member 'FSBZGamepadBindingInputAction::ActionName' has a wrong offset!");

// ScriptStruct Starbreeze.SBZGamepadBinding
// 0x0060 (0x0060 - 0x0000)
struct FSBZGamepadBinding final
{
public:
	class FText                                   NameLocalized;                                     // 0x0000(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0018(0x000C)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSBZGamepadBindingInputAction>  InputActions;                                      // 0x0028(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	struct FInputChord                            Button;                                            // 0x0038(0x0028)(Edit, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZGamepadBinding) == 0x000008, "Wrong alignment on FSBZGamepadBinding");
static_assert(sizeof(FSBZGamepadBinding) == 0x000060, "Wrong size on FSBZGamepadBinding");
static_assert(offsetof(FSBZGamepadBinding, NameLocalized) == 0x000000, "Member 'FSBZGamepadBinding::NameLocalized' has a wrong offset!");
static_assert(offsetof(FSBZGamepadBinding, Name) == 0x000018, "Member 'FSBZGamepadBinding::Name' has a wrong offset!");
static_assert(offsetof(FSBZGamepadBinding, InputActions) == 0x000028, "Member 'FSBZGamepadBinding::InputActions' has a wrong offset!");
static_assert(offsetof(FSBZGamepadBinding, Button) == 0x000038, "Member 'FSBZGamepadBinding::Button' has a wrong offset!");

// ScriptStruct Starbreeze.PD3SquadSpawnReservation
// 0x0138 (0x0138 - 0x0000)
struct alignas(0x08) FPD3SquadSpawnReservation final
{
public:
	uint8                                         Pad_0[0x138];                                      // 0x0000(0x0138)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPD3SquadSpawnReservation) == 0x000008, "Wrong alignment on FPD3SquadSpawnReservation");
static_assert(sizeof(FPD3SquadSpawnReservation) == 0x000138, "Wrong size on FPD3SquadSpawnReservation");

// ScriptStruct Starbreeze.SBZEditVariationSetData
// 0x0038 (0x0038 - 0x0000)
struct FSBZEditVariationSetData final
{
public:
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            StaticMesh;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             OverrideMaterials;                                 // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UDataTable*                             CDPFormat;                                         // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZEditVariationSetData) == 0x000008, "Wrong alignment on FSBZEditVariationSetData");
static_assert(sizeof(FSBZEditVariationSetData) == 0x000038, "Wrong size on FSBZEditVariationSetData");
static_assert(offsetof(FSBZEditVariationSetData, SkeletalMesh) == 0x000000, "Member 'FSBZEditVariationSetData::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(FSBZEditVariationSetData, StaticMesh) == 0x000008, "Member 'FSBZEditVariationSetData::StaticMesh' has a wrong offset!");
static_assert(offsetof(FSBZEditVariationSetData, OverrideMaterials) == 0x000010, "Member 'FSBZEditVariationSetData::OverrideMaterials' has a wrong offset!");
static_assert(offsetof(FSBZEditVariationSetData, CDPFormat) == 0x000020, "Member 'FSBZEditVariationSetData::CDPFormat' has a wrong offset!");

// ScriptStruct Starbreeze.SBZYawControl
// 0x0118 (0x0118 - 0x0000)
struct FSBZYawControl final
{
public:
	struct FRuntimeFloatCurve                     YawCurve;                                          // 0x0000(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     BlendCurve;                                        // 0x0088(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FFloatInterval                         Bounds;                                            // 0x0110(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZYawControl) == 0x000008, "Wrong alignment on FSBZYawControl");
static_assert(sizeof(FSBZYawControl) == 0x000118, "Wrong size on FSBZYawControl");
static_assert(offsetof(FSBZYawControl, YawCurve) == 0x000000, "Member 'FSBZYawControl::YawCurve' has a wrong offset!");
static_assert(offsetof(FSBZYawControl, BlendCurve) == 0x000088, "Member 'FSBZYawControl::BlendCurve' has a wrong offset!");
static_assert(offsetof(FSBZYawControl, Bounds) == 0x000110, "Member 'FSBZYawControl::Bounds' has a wrong offset!");

// ScriptStruct Starbreeze.PD3VehicleSpawnRequest
// 0x0020 (0x0020 - 0x0000)
struct FPD3VehicleSpawnRequest final
{
public:
	class USBZAssaultVehicleSpawnerData*          SpawnData;                                         // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASBZSpline*                             EnterSpline;                                       // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASBZSpline*                             ExitSpline;                                        // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPD3VehicleSpawnRequest) == 0x000008, "Wrong alignment on FPD3VehicleSpawnRequest");
static_assert(sizeof(FPD3VehicleSpawnRequest) == 0x000020, "Wrong size on FPD3VehicleSpawnRequest");
static_assert(offsetof(FPD3VehicleSpawnRequest, SpawnData) == 0x000000, "Member 'FPD3VehicleSpawnRequest::SpawnData' has a wrong offset!");
static_assert(offsetof(FPD3VehicleSpawnRequest, EnterSpline) == 0x000008, "Member 'FPD3VehicleSpawnRequest::EnterSpline' has a wrong offset!");
static_assert(offsetof(FPD3VehicleSpawnRequest, ExitSpline) == 0x000010, "Member 'FPD3VehicleSpawnRequest::ExitSpline' has a wrong offset!");

// ScriptStruct Starbreeze.PD3CallerReason
// 0x0080 (0x0080 - 0x0000)
struct FPD3CallerReason final
{
public:
	class USBZActionNotificationAsset*            Reason[0x10];                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPD3CallerReason) == 0x000008, "Wrong alignment on FPD3CallerReason");
static_assert(sizeof(FPD3CallerReason) == 0x000080, "Wrong size on FPD3CallerReason");
static_assert(offsetof(FPD3CallerReason, Reason) == 0x000000, "Member 'FPD3CallerReason::Reason' has a wrong offset!");

// ScriptStruct Starbreeze.SBZStorymodeStruct
// 0x0058 (0x0058 - 0x0000)
struct FSBZStorymodeStruct final
{
public:
	struct FFilePath                              VideoURL;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPaperSprite>            DisplayIcon;                                       // 0x0010(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ButtonText;                                        // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZStorymodeStruct) == 0x000008, "Wrong alignment on FSBZStorymodeStruct");
static_assert(sizeof(FSBZStorymodeStruct) == 0x000058, "Wrong size on FSBZStorymodeStruct");
static_assert(offsetof(FSBZStorymodeStruct, VideoURL) == 0x000000, "Member 'FSBZStorymodeStruct::VideoURL' has a wrong offset!");
static_assert(offsetof(FSBZStorymodeStruct, DisplayIcon) == 0x000010, "Member 'FSBZStorymodeStruct::DisplayIcon' has a wrong offset!");
static_assert(offsetof(FSBZStorymodeStruct, ButtonText) == 0x000040, "Member 'FSBZStorymodeStruct::ButtonText' has a wrong offset!");

// ScriptStruct Starbreeze.SBZGasExplosionData
// 0x0010 (0x0010 - 0x0000)
struct FSBZGasExplosionData final
{
public:
	struct FVector_NetQuantize                    ExplosionLocation;                                 // 0x0000(0x000C)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemainingLifeTime;                                 // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZGasExplosionData) == 0x000004, "Wrong alignment on FSBZGasExplosionData");
static_assert(sizeof(FSBZGasExplosionData) == 0x000010, "Wrong size on FSBZGasExplosionData");
static_assert(offsetof(FSBZGasExplosionData, ExplosionLocation) == 0x000000, "Member 'FSBZGasExplosionData::ExplosionLocation' has a wrong offset!");
static_assert(offsetof(FSBZGasExplosionData, RemainingLifeTime) == 0x00000C, "Member 'FSBZGasExplosionData::RemainingLifeTime' has a wrong offset!");

// ScriptStruct Starbreeze.PD3PagerHeistData
// 0x0002 (0x0002 - 0x0000)
struct FPD3PagerHeistData final
{
public:
	uint8                                         MaxAnswerCount;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TimedOutCountIncrease;                             // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPD3PagerHeistData) == 0x000001, "Wrong alignment on FPD3PagerHeistData");
static_assert(sizeof(FPD3PagerHeistData) == 0x000002, "Wrong size on FPD3PagerHeistData");
static_assert(offsetof(FPD3PagerHeistData, MaxAnswerCount) == 0x000000, "Member 'FPD3PagerHeistData::MaxAnswerCount' has a wrong offset!");
static_assert(offsetof(FPD3PagerHeistData, TimedOutCountIncrease) == 0x000001, "Member 'FPD3PagerHeistData::TimedOutCountIncrease' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPlayerUiItemInfo
// 0x0030 (0x0030 - 0x0000)
struct FSBZPlayerUiItemInfo final
{
public:
	bool                                          bIsAvailable;                                      // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InfamyLevel;                                       // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZItemProgressionSource                     ItemProgressionSource;                             // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLockedByDLC;                                    // 0x0009(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FirstPlatformPurchaseUrl;                          // 0x0010(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZSkillLineData*                      SkillLineToUnlock;                                 // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZInventoryBaseData*                  InventoryBaseData;                                 // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPlayerUiItemInfo) == 0x000008, "Wrong alignment on FSBZPlayerUiItemInfo");
static_assert(sizeof(FSBZPlayerUiItemInfo) == 0x000030, "Wrong size on FSBZPlayerUiItemInfo");
static_assert(offsetof(FSBZPlayerUiItemInfo, bIsAvailable) == 0x000000, "Member 'FSBZPlayerUiItemInfo::bIsAvailable' has a wrong offset!");
static_assert(offsetof(FSBZPlayerUiItemInfo, InfamyLevel) == 0x000004, "Member 'FSBZPlayerUiItemInfo::InfamyLevel' has a wrong offset!");
static_assert(offsetof(FSBZPlayerUiItemInfo, ItemProgressionSource) == 0x000008, "Member 'FSBZPlayerUiItemInfo::ItemProgressionSource' has a wrong offset!");
static_assert(offsetof(FSBZPlayerUiItemInfo, bIsLockedByDLC) == 0x000009, "Member 'FSBZPlayerUiItemInfo::bIsLockedByDLC' has a wrong offset!");
static_assert(offsetof(FSBZPlayerUiItemInfo, FirstPlatformPurchaseUrl) == 0x000010, "Member 'FSBZPlayerUiItemInfo::FirstPlatformPurchaseUrl' has a wrong offset!");
static_assert(offsetof(FSBZPlayerUiItemInfo, SkillLineToUnlock) == 0x000020, "Member 'FSBZPlayerUiItemInfo::SkillLineToUnlock' has a wrong offset!");
static_assert(offsetof(FSBZPlayerUiItemInfo, InventoryBaseData) == 0x000028, "Member 'FSBZPlayerUiItemInfo::InventoryBaseData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZECMCountData
// 0x000C (0x000C - 0x0000)
struct FSBZECMCountData final
{
public:
	int32                                         CurrentECMJammerCount;                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastAddedECMTime;                                  // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ElectricInterferenceCount;                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZECMCountData) == 0x000004, "Wrong alignment on FSBZECMCountData");
static_assert(sizeof(FSBZECMCountData) == 0x00000C, "Wrong size on FSBZECMCountData");
static_assert(offsetof(FSBZECMCountData, CurrentECMJammerCount) == 0x000000, "Member 'FSBZECMCountData::CurrentECMJammerCount' has a wrong offset!");
static_assert(offsetof(FSBZECMCountData, LastAddedECMTime) == 0x000004, "Member 'FSBZECMCountData::LastAddedECMTime' has a wrong offset!");
static_assert(offsetof(FSBZECMCountData, ElectricInterferenceCount) == 0x000008, "Member 'FSBZECMCountData::ElectricInterferenceCount' has a wrong offset!");

// ScriptStruct Starbreeze.PD3PawnVariationArray
// 0x0010 (0x0010 - 0x0000)
struct FPD3PawnVariationArray final
{
public:
	TArray<TSubclassOf<class APawn>>              PawnArray;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPD3PawnVariationArray) == 0x000008, "Wrong alignment on FPD3PawnVariationArray");
static_assert(sizeof(FPD3PawnVariationArray) == 0x000010, "Wrong size on FPD3PawnVariationArray");
static_assert(offsetof(FPD3PawnVariationArray, PawnArray) == 0x000000, "Member 'FPD3PawnVariationArray::PawnArray' has a wrong offset!");

// ScriptStruct Starbreeze.PD3PlayerLoadoutMinimalForRootMenu
// 0x00C0 (0x00C0 - 0x0000)
struct FPD3PlayerLoadoutMinimalForRootMenu final
{
public:
	TArray<class USBZPlayerCharacterData*>        PreferredCharacterDataArray;                       // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSBZEquippableConfig>           EquippableConfigArray;                             // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class USBZGloveData*                          GloveData;                                         // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSBZMaskConfig                         MaskConfig;                                        // 0x0028(0x0070)(Edit, NativeAccessSpecifierPublic)
	struct FSBZSuitConfig                         SuitConfig;                                        // 0x0098(0x0028)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPD3PlayerLoadoutMinimalForRootMenu) == 0x000008, "Wrong alignment on FPD3PlayerLoadoutMinimalForRootMenu");
static_assert(sizeof(FPD3PlayerLoadoutMinimalForRootMenu) == 0x0000C0, "Wrong size on FPD3PlayerLoadoutMinimalForRootMenu");
static_assert(offsetof(FPD3PlayerLoadoutMinimalForRootMenu, PreferredCharacterDataArray) == 0x000000, "Member 'FPD3PlayerLoadoutMinimalForRootMenu::PreferredCharacterDataArray' has a wrong offset!");
static_assert(offsetof(FPD3PlayerLoadoutMinimalForRootMenu, EquippableConfigArray) == 0x000010, "Member 'FPD3PlayerLoadoutMinimalForRootMenu::EquippableConfigArray' has a wrong offset!");
static_assert(offsetof(FPD3PlayerLoadoutMinimalForRootMenu, GloveData) == 0x000020, "Member 'FPD3PlayerLoadoutMinimalForRootMenu::GloveData' has a wrong offset!");
static_assert(offsetof(FPD3PlayerLoadoutMinimalForRootMenu, MaskConfig) == 0x000028, "Member 'FPD3PlayerLoadoutMinimalForRootMenu::MaskConfig' has a wrong offset!");
static_assert(offsetof(FPD3PlayerLoadoutMinimalForRootMenu, SuitConfig) == 0x000098, "Member 'FPD3PlayerLoadoutMinimalForRootMenu::SuitConfig' has a wrong offset!");

// ScriptStruct Starbreeze.SBZHoldOutDamageEventFilter
// 0x0048 (0x0048 - 0x0000)
struct FSBZHoldOutDamageEventFilter final
{
public:
	struct FGameplayTagContainer                  AttackerTypes;                                     // 0x0000(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  DamageTypes;                                       // 0x0020(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	int32                                         DefeatStates;                                      // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceFromQuerier;                               // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FSBZHoldOutDamageEventFilter) == 0x000008, "Wrong alignment on FSBZHoldOutDamageEventFilter");
static_assert(sizeof(FSBZHoldOutDamageEventFilter) == 0x000048, "Wrong size on FSBZHoldOutDamageEventFilter");
static_assert(offsetof(FSBZHoldOutDamageEventFilter, AttackerTypes) == 0x000000, "Member 'FSBZHoldOutDamageEventFilter::AttackerTypes' has a wrong offset!");
static_assert(offsetof(FSBZHoldOutDamageEventFilter, DamageTypes) == 0x000020, "Member 'FSBZHoldOutDamageEventFilter::DamageTypes' has a wrong offset!");
static_assert(offsetof(FSBZHoldOutDamageEventFilter, DefeatStates) == 0x000040, "Member 'FSBZHoldOutDamageEventFilter::DefeatStates' has a wrong offset!");
static_assert(offsetof(FSBZHoldOutDamageEventFilter, DistanceFromQuerier) == 0x000044, "Member 'FSBZHoldOutDamageEventFilter::DistanceFromQuerier' has a wrong offset!");

// ScriptStruct Starbreeze.PD3TickerSettings
// 0x0050 (0x0050 - 0x0000)
struct FPD3TickerSettings final
{
public:
	class FText                                   DisplayText;                                       // 0x0000(0x0018)(Transient, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FLinearColor                           TextColor;                                         // 0x0030(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BackgroundColor;                                   // 0x0040(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPD3TickerSettings) == 0x000008, "Wrong alignment on FPD3TickerSettings");
static_assert(sizeof(FPD3TickerSettings) == 0x000050, "Wrong size on FPD3TickerSettings");
static_assert(offsetof(FPD3TickerSettings, DisplayText) == 0x000000, "Member 'FPD3TickerSettings::DisplayText' has a wrong offset!");
static_assert(offsetof(FPD3TickerSettings, Text) == 0x000018, "Member 'FPD3TickerSettings::Text' has a wrong offset!");
static_assert(offsetof(FPD3TickerSettings, TextColor) == 0x000030, "Member 'FPD3TickerSettings::TextColor' has a wrong offset!");
static_assert(offsetof(FPD3TickerSettings, BackgroundColor) == 0x000040, "Member 'FPD3TickerSettings::BackgroundColor' has a wrong offset!");

// ScriptStruct Starbreeze.SBZDebugModularConfigItem
// 0x0018 (0x0018 - 0x0000)
struct FSBZDebugModularConfigItem final
{
public:
	class USBZModularPartSlotBase*                Slot;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZEquippablePartDataAsset*            Part;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZEquippablePartConfig*               Config;                                            // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZDebugModularConfigItem) == 0x000008, "Wrong alignment on FSBZDebugModularConfigItem");
static_assert(sizeof(FSBZDebugModularConfigItem) == 0x000018, "Wrong size on FSBZDebugModularConfigItem");
static_assert(offsetof(FSBZDebugModularConfigItem, Slot) == 0x000000, "Member 'FSBZDebugModularConfigItem::Slot' has a wrong offset!");
static_assert(offsetof(FSBZDebugModularConfigItem, Part) == 0x000008, "Member 'FSBZDebugModularConfigItem::Part' has a wrong offset!");
static_assert(offsetof(FSBZDebugModularConfigItem, Config) == 0x000010, "Member 'FSBZDebugModularConfigItem::Config' has a wrong offset!");

// ScriptStruct Starbreeze.SBZVolumeDamageData
// 0x0098 (0x0098 - 0x0000)
struct FSBZVolumeDamageData final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Owner;                                             // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x88];                                      // 0x0010(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZVolumeDamageData) == 0x000008, "Wrong alignment on FSBZVolumeDamageData");
static_assert(sizeof(FSBZVolumeDamageData) == 0x000098, "Wrong size on FSBZVolumeDamageData");
static_assert(offsetof(FSBZVolumeDamageData, Object) == 0x000000, "Member 'FSBZVolumeDamageData::Object' has a wrong offset!");
static_assert(offsetof(FSBZVolumeDamageData, Owner) == 0x000008, "Member 'FSBZVolumeDamageData::Owner' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMatchmakingSessionResult
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x08) FSBZMatchmakingSessionResult final
{
public:
	uint8                                         Pad_0[0x60];                                       // 0x0000(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZMatchmakingSessionResult) == 0x000008, "Wrong alignment on FSBZMatchmakingSessionResult");
static_assert(sizeof(FSBZMatchmakingSessionResult) == 0x000060, "Wrong size on FSBZMatchmakingSessionResult");

// ScriptStruct Starbreeze.SBZHackableActorReplicatedData
// 0x0008 (0x0008 - 0x0000)
struct FSBZHackableActorReplicatedData final
{
public:
	ESBZHackableActorState                        CurrentState;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CurrentProgress;                                   // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CurrentDisplayTextIndex;                           // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsDisplayTextAdded : 1;                           // 0x0003(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsStartedInStealth : 1;                           // 0x0003(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsResetToGenericScreen : 1;                       // 0x0003(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	float                                         UpdateFrequency;                                   // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZHackableActorReplicatedData) == 0x000004, "Wrong alignment on FSBZHackableActorReplicatedData");
static_assert(sizeof(FSBZHackableActorReplicatedData) == 0x000008, "Wrong size on FSBZHackableActorReplicatedData");
static_assert(offsetof(FSBZHackableActorReplicatedData, CurrentState) == 0x000000, "Member 'FSBZHackableActorReplicatedData::CurrentState' has a wrong offset!");
static_assert(offsetof(FSBZHackableActorReplicatedData, CurrentProgress) == 0x000001, "Member 'FSBZHackableActorReplicatedData::CurrentProgress' has a wrong offset!");
static_assert(offsetof(FSBZHackableActorReplicatedData, CurrentDisplayTextIndex) == 0x000002, "Member 'FSBZHackableActorReplicatedData::CurrentDisplayTextIndex' has a wrong offset!");
static_assert(offsetof(FSBZHackableActorReplicatedData, UpdateFrequency) == 0x000004, "Member 'FSBZHackableActorReplicatedData::UpdateFrequency' has a wrong offset!");

// ScriptStruct Starbreeze.SBZArmadaInfo
// 0x0058 (0x0058 - 0x0000)
struct FSBZArmadaInfo final
{
public:
	class FString                                 IP;                                                // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PortGame;                                          // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PortBeacon;                                        // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MatchID;                                           // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServerVersion;                                     // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Region;                                            // 0x0038(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameSessionCode;                                   // 0x0048(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZArmadaInfo) == 0x000008, "Wrong alignment on FSBZArmadaInfo");
static_assert(sizeof(FSBZArmadaInfo) == 0x000058, "Wrong size on FSBZArmadaInfo");
static_assert(offsetof(FSBZArmadaInfo, IP) == 0x000000, "Member 'FSBZArmadaInfo::IP' has a wrong offset!");
static_assert(offsetof(FSBZArmadaInfo, PortGame) == 0x000010, "Member 'FSBZArmadaInfo::PortGame' has a wrong offset!");
static_assert(offsetof(FSBZArmadaInfo, PortBeacon) == 0x000014, "Member 'FSBZArmadaInfo::PortBeacon' has a wrong offset!");
static_assert(offsetof(FSBZArmadaInfo, MatchID) == 0x000018, "Member 'FSBZArmadaInfo::MatchID' has a wrong offset!");
static_assert(offsetof(FSBZArmadaInfo, ServerVersion) == 0x000028, "Member 'FSBZArmadaInfo::ServerVersion' has a wrong offset!");
static_assert(offsetof(FSBZArmadaInfo, Region) == 0x000038, "Member 'FSBZArmadaInfo::Region' has a wrong offset!");
static_assert(offsetof(FSBZArmadaInfo, GameSessionCode) == 0x000048, "Member 'FSBZArmadaInfo::GameSessionCode' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInputAxisKeyboardBinding
// 0x0050 (0x0050 - 0x0000)
struct FSBZInputAxisKeyboardBinding final
{
public:
	class FName                                   AxisName;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   KeyPrimary;                                        // 0x0010(0x0020)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   KeySecondary;                                      // 0x0030(0x0020)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZInputAxisKeyboardBinding) == 0x000008, "Wrong alignment on FSBZInputAxisKeyboardBinding");
static_assert(sizeof(FSBZInputAxisKeyboardBinding) == 0x000050, "Wrong size on FSBZInputAxisKeyboardBinding");
static_assert(offsetof(FSBZInputAxisKeyboardBinding, AxisName) == 0x000000, "Member 'FSBZInputAxisKeyboardBinding::AxisName' has a wrong offset!");
static_assert(offsetof(FSBZInputAxisKeyboardBinding, Scale) == 0x00000C, "Member 'FSBZInputAxisKeyboardBinding::Scale' has a wrong offset!");
static_assert(offsetof(FSBZInputAxisKeyboardBinding, KeyPrimary) == 0x000010, "Member 'FSBZInputAxisKeyboardBinding::KeyPrimary' has a wrong offset!");
static_assert(offsetof(FSBZInputAxisKeyboardBinding, KeySecondary) == 0x000030, "Member 'FSBZInputAxisKeyboardBinding::KeySecondary' has a wrong offset!");

// ScriptStruct Starbreeze.SBZRegistrationFieldInfo
// 0x0060 (0x0060 - 0x0000)
struct FSBZRegistrationFieldInfo final
{
public:
	class FString                                 Email;                                             // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Password;                                          // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Username;                                          // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Displayname;                                       // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Country;                                           // 0x0040(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DOB;                                               // 0x0050(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZRegistrationFieldInfo) == 0x000008, "Wrong alignment on FSBZRegistrationFieldInfo");
static_assert(sizeof(FSBZRegistrationFieldInfo) == 0x000060, "Wrong size on FSBZRegistrationFieldInfo");
static_assert(offsetof(FSBZRegistrationFieldInfo, Email) == 0x000000, "Member 'FSBZRegistrationFieldInfo::Email' has a wrong offset!");
static_assert(offsetof(FSBZRegistrationFieldInfo, Password) == 0x000010, "Member 'FSBZRegistrationFieldInfo::Password' has a wrong offset!");
static_assert(offsetof(FSBZRegistrationFieldInfo, Username) == 0x000020, "Member 'FSBZRegistrationFieldInfo::Username' has a wrong offset!");
static_assert(offsetof(FSBZRegistrationFieldInfo, Displayname) == 0x000030, "Member 'FSBZRegistrationFieldInfo::Displayname' has a wrong offset!");
static_assert(offsetof(FSBZRegistrationFieldInfo, Country) == 0x000040, "Member 'FSBZRegistrationFieldInfo::Country' has a wrong offset!");
static_assert(offsetof(FSBZRegistrationFieldInfo, DOB) == 0x000050, "Member 'FSBZRegistrationFieldInfo::DOB' has a wrong offset!");

// ScriptStruct Starbreeze.SBZLoginFieldInfo
// 0x0020 (0x0020 - 0x0000)
struct FSBZLoginFieldInfo final
{
public:
	class FString                                 Username;                                          // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Password;                                          // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZLoginFieldInfo) == 0x000008, "Wrong alignment on FSBZLoginFieldInfo");
static_assert(sizeof(FSBZLoginFieldInfo) == 0x000020, "Wrong size on FSBZLoginFieldInfo");
static_assert(offsetof(FSBZLoginFieldInfo, Username) == 0x000000, "Member 'FSBZLoginFieldInfo::Username' has a wrong offset!");
static_assert(offsetof(FSBZLoginFieldInfo, Password) == 0x000010, "Member 'FSBZLoginFieldInfo::Password' has a wrong offset!");

// ScriptStruct Starbreeze.SBZActorFilterDefinition
// 0x0028 (0x0028 - 0x0000)
struct FSBZActorFilterDefinition final
{
public:
	class FName                                   Identifier;                                        // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInt32Range                            DesiredCountRange;                                 // 0x0018(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZActorFilterDefinition) == 0x000008, "Wrong alignment on FSBZActorFilterDefinition");
static_assert(sizeof(FSBZActorFilterDefinition) == 0x000028, "Wrong size on FSBZActorFilterDefinition");
static_assert(offsetof(FSBZActorFilterDefinition, Identifier) == 0x000000, "Member 'FSBZActorFilterDefinition::Identifier' has a wrong offset!");
static_assert(offsetof(FSBZActorFilterDefinition, ActorClass) == 0x000010, "Member 'FSBZActorFilterDefinition::ActorClass' has a wrong offset!");
static_assert(offsetof(FSBZActorFilterDefinition, DesiredCountRange) == 0x000018, "Member 'FSBZActorFilterDefinition::DesiredCountRange' has a wrong offset!");

// ScriptStruct Starbreeze.SBZHostageTradeData
// 0x0010 (0x0010 - 0x0000)
struct FSBZHostageTradeData final
{
public:
	struct FGameplayTag                           PawnType;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TradeCount;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZHostageTradeData) == 0x000004, "Wrong alignment on FSBZHostageTradeData");
static_assert(sizeof(FSBZHostageTradeData) == 0x000010, "Wrong size on FSBZHostageTradeData");
static_assert(offsetof(FSBZHostageTradeData, PawnType) == 0x000000, "Member 'FSBZHostageTradeData::PawnType' has a wrong offset!");
static_assert(offsetof(FSBZHostageTradeData, TradeCount) == 0x00000C, "Member 'FSBZHostageTradeData::TradeCount' has a wrong offset!");

// ScriptStruct Starbreeze.SBZActorPool
// 0x0010 (0x0010 - 0x0000)
struct FSBZActorPool final
{
public:
	TArray<class AActor*>                         Actors;                                            // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZActorPool) == 0x000008, "Wrong alignment on FSBZActorPool");
static_assert(sizeof(FSBZActorPool) == 0x000010, "Wrong size on FSBZActorPool");
static_assert(offsetof(FSBZActorPool, Actors) == 0x000000, "Member 'FSBZActorPool::Actors' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSurfaceImpactLod
// 0x0008 (0x0008 - 0x0000)
struct FSBZSurfaceImpactLod final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FarRange;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSurfaceImpactLod) == 0x000004, "Wrong alignment on FSBZSurfaceImpactLod");
static_assert(sizeof(FSBZSurfaceImpactLod) == 0x000008, "Wrong size on FSBZSurfaceImpactLod");
static_assert(offsetof(FSBZSurfaceImpactLod, Distance) == 0x000000, "Member 'FSBZSurfaceImpactLod::Distance' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceImpactLod, FarRange) == 0x000004, "Member 'FSBZSurfaceImpactLod::FarRange' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSurfaceImpactConfig
// 0x0040 (0x0040 - 0x0000)
struct FSBZSurfaceImpactConfig final
{
public:
	struct FSBZSurfaceImpactLod                   DecalLod;                                          // 0x0000(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         DecalAmount;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DecalInstanceAmount;                               // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalFadeOutDuration;                              // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSBZSurfaceImpactLod                   ParticleLod;                                       // 0x0014(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FSBZSurfaceImpactLod                   SoundLod;                                          // 0x001C(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          SoundEvent;                                        // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          StopSoundEvent;                                    // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkRtpc*                                SoundRtpc;                                         // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSurfaceImpactConfig) == 0x000008, "Wrong alignment on FSBZSurfaceImpactConfig");
static_assert(sizeof(FSBZSurfaceImpactConfig) == 0x000040, "Wrong size on FSBZSurfaceImpactConfig");
static_assert(offsetof(FSBZSurfaceImpactConfig, DecalLod) == 0x000000, "Member 'FSBZSurfaceImpactConfig::DecalLod' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceImpactConfig, DecalAmount) == 0x000008, "Member 'FSBZSurfaceImpactConfig::DecalAmount' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceImpactConfig, DecalInstanceAmount) == 0x00000C, "Member 'FSBZSurfaceImpactConfig::DecalInstanceAmount' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceImpactConfig, DecalFadeOutDuration) == 0x000010, "Member 'FSBZSurfaceImpactConfig::DecalFadeOutDuration' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceImpactConfig, ParticleLod) == 0x000014, "Member 'FSBZSurfaceImpactConfig::ParticleLod' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceImpactConfig, SoundLod) == 0x00001C, "Member 'FSBZSurfaceImpactConfig::SoundLod' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceImpactConfig, SoundEvent) == 0x000028, "Member 'FSBZSurfaceImpactConfig::SoundEvent' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceImpactConfig, StopSoundEvent) == 0x000030, "Member 'FSBZSurfaceImpactConfig::StopSoundEvent' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceImpactConfig, SoundRtpc) == 0x000038, "Member 'FSBZSurfaceImpactConfig::SoundRtpc' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAgentManagerPostPhysicsTickFunction
// 0x0008 (0x0030 - 0x0028)
struct FSBZAgentManagerPostPhysicsTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAgentManagerPostPhysicsTickFunction) == 0x000008, "Wrong alignment on FSBZAgentManagerPostPhysicsTickFunction");
static_assert(sizeof(FSBZAgentManagerPostPhysicsTickFunction) == 0x000030, "Wrong size on FSBZAgentManagerPostPhysicsTickFunction");

// ScriptStruct Starbreeze.SBZAgentState
// 0x0008 (0x0034 - 0x002C)
struct FSBZAgentState final : public FSBZAgentStateBase
{
public:
	float                                         DeltaTime;                                         // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Timestamp;                                         // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FSBZAgentState) == 0x000004, "Wrong alignment on FSBZAgentState");
static_assert(sizeof(FSBZAgentState) == 0x000034, "Wrong size on FSBZAgentState");
static_assert(offsetof(FSBZAgentState, DeltaTime) == 0x00002C, "Member 'FSBZAgentState::DeltaTime' has a wrong offset!");
static_assert(offsetof(FSBZAgentState, Timestamp) == 0x000030, "Member 'FSBZAgentState::Timestamp' has a wrong offset!");

// ScriptStruct Starbreeze.SBZRepMoveQueue
// 0x0010 (0x0010 - 0x0000)
struct FSBZRepMoveQueue final
{
public:
	TArray<struct FSBZAgentState>                 RepMoves;                                          // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZRepMoveQueue) == 0x000008, "Wrong alignment on FSBZRepMoveQueue");
static_assert(sizeof(FSBZRepMoveQueue) == 0x000010, "Wrong size on FSBZRepMoveQueue");
static_assert(offsetof(FSBZRepMoveQueue, RepMoves) == 0x000000, "Member 'FSBZRepMoveQueue::RepMoves' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAgentDataClient
// 0x01B0 (0x01B0 - 0x0000)
struct FSBZAgentDataClient final
{
public:
	TArray<struct FVector>                        ServerPosition;                                    // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 ServerTimestamp;                                   // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 ServerLocalTimestamp;                              // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        PrevServerPosition;                                // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 PrevServerTimestamp;                               // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FQuat>                          ServerRotation;                                    // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        ServerVelocity;                                    // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        ServerAcceleration;                                // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        GoalPosition;                                      // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FQuat>                          GoalRotation;                                      // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FQuat>                          RotationAtLastGoal;                                // 0x00A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 RemoteViewYawAtLastGoal;                           // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 GoalLocalTimestamp;                                // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        PredictedServerPosition;                           // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        PredictedServerVelocity;                           // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 PredictionDuration;                                // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  bClearVelocity;                                    // 0x0100(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 SimulatedPositionWarpTimer;                        // 0x0110(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint32>                                ServerMontageHash;                                 // 0x0120(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 ServerMontagePosition;                             // 0x0130(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        RealServerPosition;                                // 0x0140(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FQuat>                          RealServerRotation;                                // 0x0150(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 RealServerMontagePosition;                         // 0x0160(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 BoostSpeed;                                        // 0x0170(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 ReplicationGroupIndex;                             // 0x0180(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSBZRepMoveQueue>               RepMoveQueue;                                      // 0x0190(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSBZAgentState>                 CurrentRepMove;                                    // 0x01A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAgentDataClient) == 0x000008, "Wrong alignment on FSBZAgentDataClient");
static_assert(sizeof(FSBZAgentDataClient) == 0x0001B0, "Wrong size on FSBZAgentDataClient");
static_assert(offsetof(FSBZAgentDataClient, ServerPosition) == 0x000000, "Member 'FSBZAgentDataClient::ServerPosition' has a wrong offset!");
static_assert(offsetof(FSBZAgentDataClient, ServerTimestamp) == 0x000010, "Member 'FSBZAgentDataClient::ServerTimestamp' has a wrong offset!");
static_assert(offsetof(FSBZAgentDataClient, ServerLocalTimestamp) == 0x000020, "Member 'FSBZAgentDataClient::ServerLocalTimestamp' has a wrong offset!");
static_assert(offsetof(FSBZAgentDataClient, PrevServerPosition) == 0x000030, "Member 'FSBZAgentDataClient::PrevServerPosition' has a wrong offset!");
static_assert(offsetof(FSBZAgentDataClient, PrevServerTimestamp) == 0x000040, "Member 'FSBZAgentDataClient::PrevServerTimestamp' has a wrong offset!");
static_assert(offsetof(FSBZAgentDataClient, ServerRotation) == 0x000050, "Member 'FSBZAgentDataClient::ServerRotation' has a wrong offset!");
static_assert(offsetof(FSBZAgentDataClient, ServerVelocity) == 0x000060, "Member 'FSBZAgentDataClient::ServerVelocity' has a wrong offset!");
static_assert(offsetof(FSBZAgentDataClient, ServerAcceleration) == 0x000070, "Member 'FSBZAgentDataClient::ServerAcceleration' has a wrong offset!");
static_assert(offsetof(FSBZAgentDataClient, GoalPosition) == 0x000080, "Member 'FSBZAgentDataClient::GoalPosition' has a wrong offset!");
static_assert(offsetof(FSBZAgentDataClient, GoalRotation) == 0x000090, "Member 'FSBZAgentDataClient::GoalRotation' has a wrong offset!");
static_assert(offsetof(FSBZAgentDataClient, RotationAtLastGoal) == 0x0000A0, "Member 'FSBZAgentDataClient::RotationAtLastGoal' has a wrong offset!");
static_assert(offsetof(FSBZAgentDataClient, RemoteViewYawAtLastGoal) == 0x0000B0, "Member 'FSBZAgentDataClient::RemoteViewYawAtLastGoal' has a wrong offset!");
static_assert(offsetof(FSBZAgentDataClient, GoalLocalTimestamp) == 0x0000C0, "Member 'FSBZAgentDataClient::GoalLocalTimestamp' has a wrong offset!");
static_assert(offsetof(FSBZAgentDataClient, PredictedServerPosition) == 0x0000D0, "Member 'FSBZAgentDataClient::PredictedServerPosition' has a wrong offset!");
static_assert(offsetof(FSBZAgentDataClient, PredictedServerVelocity) == 0x0000E0, "Member 'FSBZAgentDataClient::PredictedServerVelocity' has a wrong offset!");
static_assert(offsetof(FSBZAgentDataClient, PredictionDuration) == 0x0000F0, "Member 'FSBZAgentDataClient::PredictionDuration' has a wrong offset!");
static_assert(offsetof(FSBZAgentDataClient, bClearVelocity) == 0x000100, "Member 'FSBZAgentDataClient::bClearVelocity' has a wrong offset!");
static_assert(offsetof(FSBZAgentDataClient, SimulatedPositionWarpTimer) == 0x000110, "Member 'FSBZAgentDataClient::SimulatedPositionWarpTimer' has a wrong offset!");
static_assert(offsetof(FSBZAgentDataClient, ServerMontageHash) == 0x000120, "Member 'FSBZAgentDataClient::ServerMontageHash' has a wrong offset!");
static_assert(offsetof(FSBZAgentDataClient, ServerMontagePosition) == 0x000130, "Member 'FSBZAgentDataClient::ServerMontagePosition' has a wrong offset!");
static_assert(offsetof(FSBZAgentDataClient, RealServerPosition) == 0x000140, "Member 'FSBZAgentDataClient::RealServerPosition' has a wrong offset!");
static_assert(offsetof(FSBZAgentDataClient, RealServerRotation) == 0x000150, "Member 'FSBZAgentDataClient::RealServerRotation' has a wrong offset!");
static_assert(offsetof(FSBZAgentDataClient, RealServerMontagePosition) == 0x000160, "Member 'FSBZAgentDataClient::RealServerMontagePosition' has a wrong offset!");
static_assert(offsetof(FSBZAgentDataClient, BoostSpeed) == 0x000170, "Member 'FSBZAgentDataClient::BoostSpeed' has a wrong offset!");
static_assert(offsetof(FSBZAgentDataClient, ReplicationGroupIndex) == 0x000180, "Member 'FSBZAgentDataClient::ReplicationGroupIndex' has a wrong offset!");
static_assert(offsetof(FSBZAgentDataClient, RepMoveQueue) == 0x000190, "Member 'FSBZAgentDataClient::RepMoveQueue' has a wrong offset!");
static_assert(offsetof(FSBZAgentDataClient, CurrentRepMove) == 0x0001A0, "Member 'FSBZAgentDataClient::CurrentRepMove' has a wrong offset!");

// ScriptStruct Starbreeze.SBZHelmetHideInfo
// 0x0002 (0x0002 - 0x0000)
struct FSBZHelmetHideInfo final
{
public:
	uint8                                         CPDIndex;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Bit;                                               // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZHelmetHideInfo) == 0x000001, "Wrong alignment on FSBZHelmetHideInfo");
static_assert(sizeof(FSBZHelmetHideInfo) == 0x000002, "Wrong size on FSBZHelmetHideInfo");
static_assert(offsetof(FSBZHelmetHideInfo, CPDIndex) == 0x000000, "Member 'FSBZHelmetHideInfo::CPDIndex' has a wrong offset!");
static_assert(offsetof(FSBZHelmetHideInfo, Bit) == 0x000001, "Member 'FSBZHelmetHideInfo::Bit' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInstantLootValues
// 0x0078 (0x0078 - 0x0000)
struct FSBZInstantLootValues final
{
public:
	TArray<int32>                                 StealthMaxPayoutArray;                             // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 LoudMaxPayoutArray;                                // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         TotalPoints;                                       // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, int32>                    NameToPointMap;                                    // 0x0028(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZInstantLootValues) == 0x000008, "Wrong alignment on FSBZInstantLootValues");
static_assert(sizeof(FSBZInstantLootValues) == 0x000078, "Wrong size on FSBZInstantLootValues");
static_assert(offsetof(FSBZInstantLootValues, StealthMaxPayoutArray) == 0x000000, "Member 'FSBZInstantLootValues::StealthMaxPayoutArray' has a wrong offset!");
static_assert(offsetof(FSBZInstantLootValues, LoudMaxPayoutArray) == 0x000010, "Member 'FSBZInstantLootValues::LoudMaxPayoutArray' has a wrong offset!");
static_assert(offsetof(FSBZInstantLootValues, TotalPoints) == 0x000020, "Member 'FSBZInstantLootValues::TotalPoints' has a wrong offset!");
static_assert(offsetof(FSBZInstantLootValues, NameToPointMap) == 0x000028, "Member 'FSBZInstantLootValues::NameToPointMap' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAgentDeltaState
// 0x0008 (0x0034 - 0x002C)
struct FSBZAgentDeltaState final : public FSBZAgentStateBase
{
public:
	int32                                         StreamIndex;                                       // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         SourceFrameId;                                     // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAgentDeltaState) == 0x000004, "Wrong alignment on FSBZAgentDeltaState");
static_assert(sizeof(FSBZAgentDeltaState) == 0x000034, "Wrong size on FSBZAgentDeltaState");
static_assert(offsetof(FSBZAgentDeltaState, StreamIndex) == 0x00002C, "Member 'FSBZAgentDeltaState::StreamIndex' has a wrong offset!");
static_assert(offsetof(FSBZAgentDeltaState, SourceFrameId) == 0x000030, "Member 'FSBZAgentDeltaState::SourceFrameId' has a wrong offset!");

// ScriptStruct Starbreeze.SBZProjectileTargetData
// 0x5B98 (0x5BA0 - 0x0008)
struct FSBZProjectileTargetData : public FGameplayAbilityTargetData
{
public:
	uint8                                         Pad_8[0x5B98];                                     // 0x0008(0x5B98)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZProjectileTargetData) == 0x000008, "Wrong alignment on FSBZProjectileTargetData");
static_assert(sizeof(FSBZProjectileTargetData) == 0x005BA0, "Wrong size on FSBZProjectileTargetData");

// ScriptStruct Starbreeze.SBZHET5BlackOverskillTargetData
// 0x0010 (0x5BB0 - 0x5BA0)
struct FSBZHET5BlackOverskillTargetData final : public FSBZProjectileTargetData
{
public:
	uint8                                         Pad_5BA0[0x10];                                    // 0x5BA0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZHET5BlackOverskillTargetData) == 0x000008, "Wrong alignment on FSBZHET5BlackOverskillTargetData");
static_assert(sizeof(FSBZHET5BlackOverskillTargetData) == 0x005BB0, "Wrong size on FSBZHET5BlackOverskillTargetData");

// ScriptStruct Starbreeze.SBZHitResultLite
// 0x0034 (0x0034 - 0x0000)
struct FSBZHitResultLite final
{
public:
	struct FVector                                TraceStart;                                        // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraceEnd;                                          // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactPoint;                                       // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x0024(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bBlockingHit : 1;                                  // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRaycastHit : 1;                                   // 0x0030(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZHitResultLite) == 0x000004, "Wrong alignment on FSBZHitResultLite");
static_assert(sizeof(FSBZHitResultLite) == 0x000034, "Wrong size on FSBZHitResultLite");
static_assert(offsetof(FSBZHitResultLite, TraceStart) == 0x000000, "Member 'FSBZHitResultLite::TraceStart' has a wrong offset!");
static_assert(offsetof(FSBZHitResultLite, TraceEnd) == 0x00000C, "Member 'FSBZHitResultLite::TraceEnd' has a wrong offset!");
static_assert(offsetof(FSBZHitResultLite, ImpactPoint) == 0x000018, "Member 'FSBZHitResultLite::ImpactPoint' has a wrong offset!");
static_assert(offsetof(FSBZHitResultLite, Normal) == 0x000024, "Member 'FSBZHitResultLite::Normal' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAgentNavState
// 0x003C (0x003C - 0x0000)
struct FSBZAgentNavState final
{
public:
	float                                         LastFloorCheckZ;                                   // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectionTimer;                                   // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSBZHitResultLite                      CachedProjectedNavMeshHitResult;                   // 0x0008(0x0034)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAgentNavState) == 0x000004, "Wrong alignment on FSBZAgentNavState");
static_assert(sizeof(FSBZAgentNavState) == 0x00003C, "Wrong size on FSBZAgentNavState");
static_assert(offsetof(FSBZAgentNavState, LastFloorCheckZ) == 0x000000, "Member 'FSBZAgentNavState::LastFloorCheckZ' has a wrong offset!");
static_assert(offsetof(FSBZAgentNavState, ProjectionTimer) == 0x000004, "Member 'FSBZAgentNavState::ProjectionTimer' has a wrong offset!");
static_assert(offsetof(FSBZAgentNavState, CachedProjectedNavMeshHitResult) == 0x000008, "Member 'FSBZAgentNavState::CachedProjectedNavMeshHitResult' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAgentNavRestrict
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x08) FSBZAgentNavRestrict final
{
public:
	uint8                                         Pad_0[0x58];                                       // 0x0000(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bIsCorridorValid : 1;                              // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsRecomputingPath : 1;                            // 0x0058(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAgentNavRestrict) == 0x000008, "Wrong alignment on FSBZAgentNavRestrict");
static_assert(sizeof(FSBZAgentNavRestrict) == 0x000060, "Wrong size on FSBZAgentNavRestrict");

// ScriptStruct Starbreeze.SBZReplicationGroupIndices
// 0x0004 (0x0004 - 0x0000)
struct FSBZReplicationGroupIndices final
{
public:
	uint32                                        ReplicationGroupIndices;                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FSBZReplicationGroupIndices) == 0x000004, "Wrong alignment on FSBZReplicationGroupIndices");
static_assert(sizeof(FSBZReplicationGroupIndices) == 0x000004, "Wrong size on FSBZReplicationGroupIndices");
static_assert(offsetof(FSBZReplicationGroupIndices, ReplicationGroupIndices) == 0x000000, "Member 'FSBZReplicationGroupIndices::ReplicationGroupIndices' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAgentDataServer
// 0x00A0 (0x00A0 - 0x0000)
struct FSBZAgentDataServer final
{
public:
	TArray<float>                                 PreviousYaw;                                       // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 MontagePosition;                                   // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 MontageLength;                                     // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 CollideWithOtherAgentsTimer;                       // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSBZAgentAvoidance>             Avoidance;                                         // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSBZAgentNavState>              NavState;                                          // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSBZAgentNavRestrict>           NavRestrict;                                       // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSBZMesh>                       CorridorDebugMesh;                                 // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  bForceReplication;                                 // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSBZReplicationGroupIndices>    ReplicationGroupIndices;                           // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAgentDataServer) == 0x000008, "Wrong alignment on FSBZAgentDataServer");
static_assert(sizeof(FSBZAgentDataServer) == 0x0000A0, "Wrong size on FSBZAgentDataServer");
static_assert(offsetof(FSBZAgentDataServer, PreviousYaw) == 0x000000, "Member 'FSBZAgentDataServer::PreviousYaw' has a wrong offset!");
static_assert(offsetof(FSBZAgentDataServer, MontagePosition) == 0x000010, "Member 'FSBZAgentDataServer::MontagePosition' has a wrong offset!");
static_assert(offsetof(FSBZAgentDataServer, MontageLength) == 0x000020, "Member 'FSBZAgentDataServer::MontageLength' has a wrong offset!");
static_assert(offsetof(FSBZAgentDataServer, CollideWithOtherAgentsTimer) == 0x000030, "Member 'FSBZAgentDataServer::CollideWithOtherAgentsTimer' has a wrong offset!");
static_assert(offsetof(FSBZAgentDataServer, Avoidance) == 0x000040, "Member 'FSBZAgentDataServer::Avoidance' has a wrong offset!");
static_assert(offsetof(FSBZAgentDataServer, NavState) == 0x000050, "Member 'FSBZAgentDataServer::NavState' has a wrong offset!");
static_assert(offsetof(FSBZAgentDataServer, NavRestrict) == 0x000060, "Member 'FSBZAgentDataServer::NavRestrict' has a wrong offset!");
static_assert(offsetof(FSBZAgentDataServer, CorridorDebugMesh) == 0x000070, "Member 'FSBZAgentDataServer::CorridorDebugMesh' has a wrong offset!");
static_assert(offsetof(FSBZAgentDataServer, bForceReplication) == 0x000080, "Member 'FSBZAgentDataServer::bForceReplication' has a wrong offset!");
static_assert(offsetof(FSBZAgentDataServer, ReplicationGroupIndices) == 0x000090, "Member 'FSBZAgentDataServer::ReplicationGroupIndices' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPlayerDebuggerOptions
// 0x0004 (0x0004 - 0x0000)
struct FSBZPlayerDebuggerOptions final
{
public:
	bool                                          bIsGod;                                            // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInfiniteAmmo;                                   // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInvisible;                                      // 0x0002(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInaudible;                                      // 0x0003(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPlayerDebuggerOptions) == 0x000001, "Wrong alignment on FSBZPlayerDebuggerOptions");
static_assert(sizeof(FSBZPlayerDebuggerOptions) == 0x000004, "Wrong size on FSBZPlayerDebuggerOptions");
static_assert(offsetof(FSBZPlayerDebuggerOptions, bIsGod) == 0x000000, "Member 'FSBZPlayerDebuggerOptions::bIsGod' has a wrong offset!");
static_assert(offsetof(FSBZPlayerDebuggerOptions, bIsInfiniteAmmo) == 0x000001, "Member 'FSBZPlayerDebuggerOptions::bIsInfiniteAmmo' has a wrong offset!");
static_assert(offsetof(FSBZPlayerDebuggerOptions, bIsInvisible) == 0x000002, "Member 'FSBZPlayerDebuggerOptions::bIsInvisible' has a wrong offset!");
static_assert(offsetof(FSBZPlayerDebuggerOptions, bIsInaudible) == 0x000003, "Member 'FSBZPlayerDebuggerOptions::bIsInaudible' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAgentSettings
// 0x004C (0x004C - 0x0000)
struct FSBZAgentSettings final
{
public:
	float                                         MaxAcceleration;                                   // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngularSpeed;                                   // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Friction;                                          // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceRadius;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NeighbourDetectionRange;                           // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bNavProjection : 1;                                // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NavMeshProjectionInterval;                         // 0x0020(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavMeshProjectionHeightScaleUp;                    // 0x0024(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavMeshProjectionHeightScaleDown;                  // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinNavMeshProjectionHeightUp;                      // 0x002C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavMeshProjectionInterpSpeed;                      // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RVOGroupMask;                                      // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RVOGroupsToAvoid;                                  // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RVOGroupsToIgnore;                                 // 0x003C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RVOWeight;                                         // 0x0040(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RVOTestRadius;                                     // 0x0044(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JogSpeed;                                          // 0x0048(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAgentSettings) == 0x000004, "Wrong alignment on FSBZAgentSettings");
static_assert(sizeof(FSBZAgentSettings) == 0x00004C, "Wrong size on FSBZAgentSettings");
static_assert(offsetof(FSBZAgentSettings, MaxAcceleration) == 0x000000, "Member 'FSBZAgentSettings::MaxAcceleration' has a wrong offset!");
static_assert(offsetof(FSBZAgentSettings, MaxAngularSpeed) == 0x000004, "Member 'FSBZAgentSettings::MaxAngularSpeed' has a wrong offset!");
static_assert(offsetof(FSBZAgentSettings, Friction) == 0x000008, "Member 'FSBZAgentSettings::Friction' has a wrong offset!");
static_assert(offsetof(FSBZAgentSettings, Radius) == 0x00000C, "Member 'FSBZAgentSettings::Radius' has a wrong offset!");
static_assert(offsetof(FSBZAgentSettings, TraceRadius) == 0x000010, "Member 'FSBZAgentSettings::TraceRadius' has a wrong offset!");
static_assert(offsetof(FSBZAgentSettings, Height) == 0x000014, "Member 'FSBZAgentSettings::Height' has a wrong offset!");
static_assert(offsetof(FSBZAgentSettings, NeighbourDetectionRange) == 0x000018, "Member 'FSBZAgentSettings::NeighbourDetectionRange' has a wrong offset!");
static_assert(offsetof(FSBZAgentSettings, NavMeshProjectionInterval) == 0x000020, "Member 'FSBZAgentSettings::NavMeshProjectionInterval' has a wrong offset!");
static_assert(offsetof(FSBZAgentSettings, NavMeshProjectionHeightScaleUp) == 0x000024, "Member 'FSBZAgentSettings::NavMeshProjectionHeightScaleUp' has a wrong offset!");
static_assert(offsetof(FSBZAgentSettings, NavMeshProjectionHeightScaleDown) == 0x000028, "Member 'FSBZAgentSettings::NavMeshProjectionHeightScaleDown' has a wrong offset!");
static_assert(offsetof(FSBZAgentSettings, MinNavMeshProjectionHeightUp) == 0x00002C, "Member 'FSBZAgentSettings::MinNavMeshProjectionHeightUp' has a wrong offset!");
static_assert(offsetof(FSBZAgentSettings, NavMeshProjectionInterpSpeed) == 0x000030, "Member 'FSBZAgentSettings::NavMeshProjectionInterpSpeed' has a wrong offset!");
static_assert(offsetof(FSBZAgentSettings, RVOGroupMask) == 0x000034, "Member 'FSBZAgentSettings::RVOGroupMask' has a wrong offset!");
static_assert(offsetof(FSBZAgentSettings, RVOGroupsToAvoid) == 0x000038, "Member 'FSBZAgentSettings::RVOGroupsToAvoid' has a wrong offset!");
static_assert(offsetof(FSBZAgentSettings, RVOGroupsToIgnore) == 0x00003C, "Member 'FSBZAgentSettings::RVOGroupsToIgnore' has a wrong offset!");
static_assert(offsetof(FSBZAgentSettings, RVOWeight) == 0x000040, "Member 'FSBZAgentSettings::RVOWeight' has a wrong offset!");
static_assert(offsetof(FSBZAgentSettings, RVOTestRadius) == 0x000044, "Member 'FSBZAgentSettings::RVOTestRadius' has a wrong offset!");
static_assert(offsetof(FSBZAgentSettings, JogSpeed) == 0x000048, "Member 'FSBZAgentSettings::JogSpeed' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSkeletalMeshInfos
// 0x0070 (0x0070 - 0x0000)
struct FSBZSkeletalMeshInfos final
{
public:
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldTransform;                                    // 0x0010(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     BoneSpaceTransforms;                               // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCustomPrimitiveData                   CustomPrimitiveData;                               // 0x0050(0x0010)(NativeAccessSpecifierPublic)
	int32                                         LODIndex;                                          // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0xC];                                       // 0x0064(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZSkeletalMeshInfos) == 0x000010, "Wrong alignment on FSBZSkeletalMeshInfos");
static_assert(sizeof(FSBZSkeletalMeshInfos) == 0x000070, "Wrong size on FSBZSkeletalMeshInfos");
static_assert(offsetof(FSBZSkeletalMeshInfos, SkeletalMesh) == 0x000000, "Member 'FSBZSkeletalMeshInfos::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(FSBZSkeletalMeshInfos, WorldTransform) == 0x000010, "Member 'FSBZSkeletalMeshInfos::WorldTransform' has a wrong offset!");
static_assert(offsetof(FSBZSkeletalMeshInfos, BoneSpaceTransforms) == 0x000040, "Member 'FSBZSkeletalMeshInfos::BoneSpaceTransforms' has a wrong offset!");
static_assert(offsetof(FSBZSkeletalMeshInfos, CustomPrimitiveData) == 0x000050, "Member 'FSBZSkeletalMeshInfos::CustomPrimitiveData' has a wrong offset!");
static_assert(offsetof(FSBZSkeletalMeshInfos, LODIndex) == 0x000060, "Member 'FSBZSkeletalMeshInfos::LODIndex' has a wrong offset!");

// ScriptStruct Starbreeze.SBZShape
// 0x0030 (0x0030 - 0x0000)
struct FSBZShape final
{
public:
	struct FQuat                                  Rotation;                                          // 0x0000(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                Center;                                            // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESBZShapeType                                 Type;                                              // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D[0x13];                                      // 0x001D(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZShape) == 0x000010, "Wrong alignment on FSBZShape");
static_assert(sizeof(FSBZShape) == 0x000030, "Wrong size on FSBZShape");
static_assert(offsetof(FSBZShape, Rotation) == 0x000000, "Member 'FSBZShape::Rotation' has a wrong offset!");
static_assert(offsetof(FSBZShape, Center) == 0x000010, "Member 'FSBZShape::Center' has a wrong offset!");
static_assert(offsetof(FSBZShape, Type) == 0x00001C, "Member 'FSBZShape::Type' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAgentMeshCollision
// 0x0068 (0x0068 - 0x0000)
struct FSBZAgentMeshCollision final
{
public:
	TArray<int16>                                 BodyIndex;                                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int16>                                 BoneIndex;                                         // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           BoneNames;                                         // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     Transform;                                         // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UPhysicalMaterial*>              PhysicalMaterial;                                  // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSBZShape>                      Shapes;                                            // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bTransformsUpToDate : 1;                           // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAgentMeshCollision) == 0x000008, "Wrong alignment on FSBZAgentMeshCollision");
static_assert(sizeof(FSBZAgentMeshCollision) == 0x000068, "Wrong size on FSBZAgentMeshCollision");
static_assert(offsetof(FSBZAgentMeshCollision, BodyIndex) == 0x000000, "Member 'FSBZAgentMeshCollision::BodyIndex' has a wrong offset!");
static_assert(offsetof(FSBZAgentMeshCollision, BoneIndex) == 0x000010, "Member 'FSBZAgentMeshCollision::BoneIndex' has a wrong offset!");
static_assert(offsetof(FSBZAgentMeshCollision, BoneNames) == 0x000020, "Member 'FSBZAgentMeshCollision::BoneNames' has a wrong offset!");
static_assert(offsetof(FSBZAgentMeshCollision, Transform) == 0x000030, "Member 'FSBZAgentMeshCollision::Transform' has a wrong offset!");
static_assert(offsetof(FSBZAgentMeshCollision, PhysicalMaterial) == 0x000040, "Member 'FSBZAgentMeshCollision::PhysicalMaterial' has a wrong offset!");
static_assert(offsetof(FSBZAgentMeshCollision, Shapes) == 0x000050, "Member 'FSBZAgentMeshCollision::Shapes' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCapsuleInfos
// 0x0040 (0x0040 - 0x0000)
struct FSBZCapsuleInfos final
{
public:
	struct FTransform                             WorldTransform;                                    // 0x0000(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CapsuleHalfHeight;                                 // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleRadius;                                     // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZCapsuleInfos) == 0x000010, "Wrong alignment on FSBZCapsuleInfos");
static_assert(sizeof(FSBZCapsuleInfos) == 0x000040, "Wrong size on FSBZCapsuleInfos");
static_assert(offsetof(FSBZCapsuleInfos, WorldTransform) == 0x000000, "Member 'FSBZCapsuleInfos::WorldTransform' has a wrong offset!");
static_assert(offsetof(FSBZCapsuleInfos, CapsuleHalfHeight) == 0x000030, "Member 'FSBZCapsuleInfos::CapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(FSBZCapsuleInfos, CapsuleRadius) == 0x000034, "Member 'FSBZCapsuleInfos::CapsuleRadius' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAgentData
// 0x01D0 (0x01D0 - 0x0000)
struct FSBZAgentData final
{
public:
	TArray<uint32>                                Id;                                                // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class APawn*>                          Pawn;                                              // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 PawnUniqueId;                                      // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class USkeletalMeshComponent*>         Mesh;                                              // 0x0030(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USBZAICharacterMovementComponent*> Movement;                                        // 0x0040(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FSBZAgentSettings>              Settings;                                          // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Position;                                          // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        SimulatedPosition;                                 // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FQuat>                          Rotation;                                          // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FQuat>                          SimulatedRotation;                                 // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FQuat>                          TargetRotation;                                    // 0x00A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 RemoteViewYaw;                                     // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 RemoteDesiredViewYaw;                              // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Velocity;                                          // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  bVelocityIsRequested;                              // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        ActualVelocity;                                    // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        DesiredAcceleration;                               // 0x0100(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint16>                                MaxSpeed;                                          // 0x0110(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Extent;                                            // 0x0120(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<ESBZMovementMode>                      MovementMode;                                      // 0x0130(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<ESBZCharacterMovementState>            CharacterMovementState;                            // 0x0140(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<ESBZTurnDirection>                     TurnDirection;                                     // 0x0150(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 OverlapTimer;                                      // 0x0160(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 Flags;                                             // 0x0170(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSBZAgentMeshCollision>         Collision;                                         // 0x0180(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint32>                                MontageHash;                                       // 0x0190(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        RMTargetWorldWS;                                   // 0x01A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSBZSkeletalMeshInfos>          SkeletalMeshInfos;                                 // 0x01B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSBZCapsuleInfos>               CapsuleInfos;                                      // 0x01C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAgentData) == 0x000008, "Wrong alignment on FSBZAgentData");
static_assert(sizeof(FSBZAgentData) == 0x0001D0, "Wrong size on FSBZAgentData");
static_assert(offsetof(FSBZAgentData, Id) == 0x000000, "Member 'FSBZAgentData::Id' has a wrong offset!");
static_assert(offsetof(FSBZAgentData, Pawn) == 0x000010, "Member 'FSBZAgentData::Pawn' has a wrong offset!");
static_assert(offsetof(FSBZAgentData, PawnUniqueId) == 0x000020, "Member 'FSBZAgentData::PawnUniqueId' has a wrong offset!");
static_assert(offsetof(FSBZAgentData, Mesh) == 0x000030, "Member 'FSBZAgentData::Mesh' has a wrong offset!");
static_assert(offsetof(FSBZAgentData, Movement) == 0x000040, "Member 'FSBZAgentData::Movement' has a wrong offset!");
static_assert(offsetof(FSBZAgentData, Settings) == 0x000050, "Member 'FSBZAgentData::Settings' has a wrong offset!");
static_assert(offsetof(FSBZAgentData, Position) == 0x000060, "Member 'FSBZAgentData::Position' has a wrong offset!");
static_assert(offsetof(FSBZAgentData, SimulatedPosition) == 0x000070, "Member 'FSBZAgentData::SimulatedPosition' has a wrong offset!");
static_assert(offsetof(FSBZAgentData, Rotation) == 0x000080, "Member 'FSBZAgentData::Rotation' has a wrong offset!");
static_assert(offsetof(FSBZAgentData, SimulatedRotation) == 0x000090, "Member 'FSBZAgentData::SimulatedRotation' has a wrong offset!");
static_assert(offsetof(FSBZAgentData, TargetRotation) == 0x0000A0, "Member 'FSBZAgentData::TargetRotation' has a wrong offset!");
static_assert(offsetof(FSBZAgentData, RemoteViewYaw) == 0x0000B0, "Member 'FSBZAgentData::RemoteViewYaw' has a wrong offset!");
static_assert(offsetof(FSBZAgentData, RemoteDesiredViewYaw) == 0x0000C0, "Member 'FSBZAgentData::RemoteDesiredViewYaw' has a wrong offset!");
static_assert(offsetof(FSBZAgentData, Velocity) == 0x0000D0, "Member 'FSBZAgentData::Velocity' has a wrong offset!");
static_assert(offsetof(FSBZAgentData, bVelocityIsRequested) == 0x0000E0, "Member 'FSBZAgentData::bVelocityIsRequested' has a wrong offset!");
static_assert(offsetof(FSBZAgentData, ActualVelocity) == 0x0000F0, "Member 'FSBZAgentData::ActualVelocity' has a wrong offset!");
static_assert(offsetof(FSBZAgentData, DesiredAcceleration) == 0x000100, "Member 'FSBZAgentData::DesiredAcceleration' has a wrong offset!");
static_assert(offsetof(FSBZAgentData, MaxSpeed) == 0x000110, "Member 'FSBZAgentData::MaxSpeed' has a wrong offset!");
static_assert(offsetof(FSBZAgentData, Extent) == 0x000120, "Member 'FSBZAgentData::Extent' has a wrong offset!");
static_assert(offsetof(FSBZAgentData, MovementMode) == 0x000130, "Member 'FSBZAgentData::MovementMode' has a wrong offset!");
static_assert(offsetof(FSBZAgentData, CharacterMovementState) == 0x000140, "Member 'FSBZAgentData::CharacterMovementState' has a wrong offset!");
static_assert(offsetof(FSBZAgentData, TurnDirection) == 0x000150, "Member 'FSBZAgentData::TurnDirection' has a wrong offset!");
static_assert(offsetof(FSBZAgentData, OverlapTimer) == 0x000160, "Member 'FSBZAgentData::OverlapTimer' has a wrong offset!");
static_assert(offsetof(FSBZAgentData, Flags) == 0x000170, "Member 'FSBZAgentData::Flags' has a wrong offset!");
static_assert(offsetof(FSBZAgentData, Collision) == 0x000180, "Member 'FSBZAgentData::Collision' has a wrong offset!");
static_assert(offsetof(FSBZAgentData, MontageHash) == 0x000190, "Member 'FSBZAgentData::MontageHash' has a wrong offset!");
static_assert(offsetof(FSBZAgentData, RMTargetWorldWS) == 0x0001A0, "Member 'FSBZAgentData::RMTargetWorldWS' has a wrong offset!");
static_assert(offsetof(FSBZAgentData, SkeletalMeshInfos) == 0x0001B0, "Member 'FSBZAgentData::SkeletalMeshInfos' has a wrong offset!");
static_assert(offsetof(FSBZAgentData, CapsuleInfos) == 0x0001C0, "Member 'FSBZAgentData::CapsuleInfos' has a wrong offset!");

// ScriptStruct Starbreeze.SBZDronePathUpVectorComputationSettings
// 0x0014 (0x0014 - 0x0000)
struct FSBZDronePathUpVectorComputationSettings final
{
public:
	float                                         RollAheadDistance;                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRollAngle;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RollStepDistance;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchAheadDistance;                                // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPitchAngle;                                     // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZDronePathUpVectorComputationSettings) == 0x000004, "Wrong alignment on FSBZDronePathUpVectorComputationSettings");
static_assert(sizeof(FSBZDronePathUpVectorComputationSettings) == 0x000014, "Wrong size on FSBZDronePathUpVectorComputationSettings");
static_assert(offsetof(FSBZDronePathUpVectorComputationSettings, RollAheadDistance) == 0x000000, "Member 'FSBZDronePathUpVectorComputationSettings::RollAheadDistance' has a wrong offset!");
static_assert(offsetof(FSBZDronePathUpVectorComputationSettings, MaxRollAngle) == 0x000004, "Member 'FSBZDronePathUpVectorComputationSettings::MaxRollAngle' has a wrong offset!");
static_assert(offsetof(FSBZDronePathUpVectorComputationSettings, RollStepDistance) == 0x000008, "Member 'FSBZDronePathUpVectorComputationSettings::RollStepDistance' has a wrong offset!");
static_assert(offsetof(FSBZDronePathUpVectorComputationSettings, PitchAheadDistance) == 0x00000C, "Member 'FSBZDronePathUpVectorComputationSettings::PitchAheadDistance' has a wrong offset!");
static_assert(offsetof(FSBZDronePathUpVectorComputationSettings, MaxPitchAngle) == 0x000010, "Member 'FSBZDronePathUpVectorComputationSettings::MaxPitchAngle' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeaponPartProgressionData
// 0x0018 (0x0018 - 0x0000)
struct FSBZWeaponPartProgressionData final
{
public:
	class USBZWeaponPartDataAsset*                WeaponPart;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AttachmentItemSku;                                 // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWeaponPartProgressionData) == 0x000008, "Wrong alignment on FSBZWeaponPartProgressionData");
static_assert(sizeof(FSBZWeaponPartProgressionData) == 0x000018, "Wrong size on FSBZWeaponPartProgressionData");
static_assert(offsetof(FSBZWeaponPartProgressionData, WeaponPart) == 0x000000, "Member 'FSBZWeaponPartProgressionData::WeaponPart' has a wrong offset!");
static_assert(offsetof(FSBZWeaponPartProgressionData, AttachmentItemSku) == 0x000008, "Member 'FSBZWeaponPartProgressionData::AttachmentItemSku' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAgilitySweepParams
// 0x0108 (0x0108 - 0x0000)
struct FSBZAgilitySweepParams final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorld*                                 World;                                             // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0xF0];                                      // 0x0018(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAgilitySweepParams) == 0x000008, "Wrong alignment on FSBZAgilitySweepParams");
static_assert(sizeof(FSBZAgilitySweepParams) == 0x000108, "Wrong size on FSBZAgilitySweepParams");
static_assert(offsetof(FSBZAgilitySweepParams, World) == 0x000010, "Member 'FSBZAgilitySweepParams::World' has a wrong offset!");

// ScriptStruct Starbreeze.SBZBaseControlReference
// 0x0020 (0x0020 - 0x0000)
struct FSBZBaseControlReference
{
public:
	class FText                                   DisplayText;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsAction;                                         // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInputRegistered;                                // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputEvent                                   EventType;                                         // 0x001A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInputConsumed;                                  // 0x001B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZBaseControlReference) == 0x000008, "Wrong alignment on FSBZBaseControlReference");
static_assert(sizeof(FSBZBaseControlReference) == 0x000020, "Wrong size on FSBZBaseControlReference");
static_assert(offsetof(FSBZBaseControlReference, DisplayText) == 0x000000, "Member 'FSBZBaseControlReference::DisplayText' has a wrong offset!");
static_assert(offsetof(FSBZBaseControlReference, bIsAction) == 0x000018, "Member 'FSBZBaseControlReference::bIsAction' has a wrong offset!");
static_assert(offsetof(FSBZBaseControlReference, bIsInputRegistered) == 0x000019, "Member 'FSBZBaseControlReference::bIsInputRegistered' has a wrong offset!");
static_assert(offsetof(FSBZBaseControlReference, EventType) == 0x00001A, "Member 'FSBZBaseControlReference::EventType' has a wrong offset!");
static_assert(offsetof(FSBZBaseControlReference, bIsInputConsumed) == 0x00001B, "Member 'FSBZBaseControlReference::bIsInputConsumed' has a wrong offset!");

// ScriptStruct Starbreeze.SBZButtonControlReference
// 0x0010 (0x0030 - 0x0020)
struct FSBZButtonControlReference final : public FSBZBaseControlReference
{
public:
	class FName                                   ButtonAction;                                      // 0x0020(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZButtonControlReference) == 0x000008, "Wrong alignment on FSBZButtonControlReference");
static_assert(sizeof(FSBZButtonControlReference) == 0x000030, "Wrong size on FSBZButtonControlReference");
static_assert(offsetof(FSBZButtonControlReference, ButtonAction) == 0x000020, "Member 'FSBZButtonControlReference::ButtonAction' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAgilityAnimationQueryFilter
// 0x0010 (0x0010 - 0x0000)
struct FSBZAgilityAnimationQueryFilter final
{
public:
	ESBZAgilityPointType                          StartAgilityType;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZAgilityPointType                          EndAgilityType;                                    // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatInterval                         DistanceRange;                                     // 0x0004(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZAgilitySegmentAxis                        DistanceRangeAxis;                                 // 0x000C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAgilityAnimationQueryFilter) == 0x000004, "Wrong alignment on FSBZAgilityAnimationQueryFilter");
static_assert(sizeof(FSBZAgilityAnimationQueryFilter) == 0x000010, "Wrong size on FSBZAgilityAnimationQueryFilter");
static_assert(offsetof(FSBZAgilityAnimationQueryFilter, StartAgilityType) == 0x000000, "Member 'FSBZAgilityAnimationQueryFilter::StartAgilityType' has a wrong offset!");
static_assert(offsetof(FSBZAgilityAnimationQueryFilter, EndAgilityType) == 0x000001, "Member 'FSBZAgilityAnimationQueryFilter::EndAgilityType' has a wrong offset!");
static_assert(offsetof(FSBZAgilityAnimationQueryFilter, DistanceRange) == 0x000004, "Member 'FSBZAgilityAnimationQueryFilter::DistanceRange' has a wrong offset!");
static_assert(offsetof(FSBZAgilityAnimationQueryFilter, DistanceRangeAxis) == 0x00000C, "Member 'FSBZAgilityAnimationQueryFilter::DistanceRangeAxis' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAgilityMontage
// 0x0038 (0x0038 - 0x0000)
struct FSBZAgilityMontage final
{
public:
	TSoftClassPtr<class UClass>                   CharacterClass;                                    // 0x0000(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Montage;                                           // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAgilityMontage) == 0x000008, "Wrong alignment on FSBZAgilityMontage");
static_assert(sizeof(FSBZAgilityMontage) == 0x000038, "Wrong size on FSBZAgilityMontage");
static_assert(offsetof(FSBZAgilityMontage, CharacterClass) == 0x000000, "Member 'FSBZAgilityMontage::CharacterClass' has a wrong offset!");
static_assert(offsetof(FSBZAgilityMontage, Montage) == 0x000030, "Member 'FSBZAgilityMontage::Montage' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAgilityAnimationQueryParam
// 0x0050 (0x0050 - 0x0000)
struct FSBZAgilityAnimationQueryParam final
{
public:
	class FName                                   AnimationName;                                     // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         EntrySpeed;                                        // 0x000C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         EntryRotationDiff;                                 // 0x0014(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         AlignmentAngle;                                    // 0x001C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavAreaBase>               AreaClass;                                         // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSBZAgilityAnimationQueryFilter> AnimationFilters;                                 // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSBZAgilityMontage>             AgilityMontages;                                   // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAgilityAnimationQueryParam) == 0x000008, "Wrong alignment on FSBZAgilityAnimationQueryParam");
static_assert(sizeof(FSBZAgilityAnimationQueryParam) == 0x000050, "Wrong size on FSBZAgilityAnimationQueryParam");
static_assert(offsetof(FSBZAgilityAnimationQueryParam, AnimationName) == 0x000000, "Member 'FSBZAgilityAnimationQueryParam::AnimationName' has a wrong offset!");
static_assert(offsetof(FSBZAgilityAnimationQueryParam, EntrySpeed) == 0x00000C, "Member 'FSBZAgilityAnimationQueryParam::EntrySpeed' has a wrong offset!");
static_assert(offsetof(FSBZAgilityAnimationQueryParam, EntryRotationDiff) == 0x000014, "Member 'FSBZAgilityAnimationQueryParam::EntryRotationDiff' has a wrong offset!");
static_assert(offsetof(FSBZAgilityAnimationQueryParam, AlignmentAngle) == 0x00001C, "Member 'FSBZAgilityAnimationQueryParam::AlignmentAngle' has a wrong offset!");
static_assert(offsetof(FSBZAgilityAnimationQueryParam, AreaClass) == 0x000028, "Member 'FSBZAgilityAnimationQueryParam::AreaClass' has a wrong offset!");
static_assert(offsetof(FSBZAgilityAnimationQueryParam, AnimationFilters) == 0x000030, "Member 'FSBZAgilityAnimationQueryParam::AnimationFilters' has a wrong offset!");
static_assert(offsetof(FSBZAgilityAnimationQueryParam, AgilityMontages) == 0x000040, "Member 'FSBZAgilityAnimationQueryParam::AgilityMontages' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAgilityRowQueryParam
// 0x0020 (0x0020 - 0x0000)
struct FSBZAgilityRowQueryParam final
{
public:
	class FName                                   AgilityTypeName;                                   // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZAgilityType                               AgilityType;                                       // 0x000C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSBZAgilityAnimationQueryParam> AnimationQueryParams;                              // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAgilityRowQueryParam) == 0x000008, "Wrong alignment on FSBZAgilityRowQueryParam");
static_assert(sizeof(FSBZAgilityRowQueryParam) == 0x000020, "Wrong size on FSBZAgilityRowQueryParam");
static_assert(offsetof(FSBZAgilityRowQueryParam, AgilityTypeName) == 0x000000, "Member 'FSBZAgilityRowQueryParam::AgilityTypeName' has a wrong offset!");
static_assert(offsetof(FSBZAgilityRowQueryParam, AgilityType) == 0x00000C, "Member 'FSBZAgilityRowQueryParam::AgilityType' has a wrong offset!");
static_assert(offsetof(FSBZAgilityRowQueryParam, AnimationQueryParams) == 0x000010, "Member 'FSBZAgilityRowQueryParam::AnimationQueryParams' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeaponPartProgression
// 0x0018 (0x0018 - 0x0000)
struct FSBZWeaponPartProgression final
{
public:
	uint32                                        ProgressionLevel;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSBZWeaponPartProgressionData>  WeaponPartData;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWeaponPartProgression) == 0x000008, "Wrong alignment on FSBZWeaponPartProgression");
static_assert(sizeof(FSBZWeaponPartProgression) == 0x000018, "Wrong size on FSBZWeaponPartProgression");
static_assert(offsetof(FSBZWeaponPartProgression, ProgressionLevel) == 0x000000, "Member 'FSBZWeaponPartProgression::ProgressionLevel' has a wrong offset!");
static_assert(offsetof(FSBZWeaponPartProgression, WeaponPartData) == 0x000008, "Member 'FSBZWeaponPartProgression::WeaponPartData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeaponPartProgressionArray
// 0x0018 (0x0018 - 0x0000)
struct FSBZWeaponPartProgressionArray final
{
public:
	class USBZBaseWeaponData*                     BaseWeapon;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSBZWeaponPartProgression>      WeaponPartProgressionArray;                        // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWeaponPartProgressionArray) == 0x000008, "Wrong alignment on FSBZWeaponPartProgressionArray");
static_assert(sizeof(FSBZWeaponPartProgressionArray) == 0x000018, "Wrong size on FSBZWeaponPartProgressionArray");
static_assert(offsetof(FSBZWeaponPartProgressionArray, BaseWeapon) == 0x000000, "Member 'FSBZWeaponPartProgressionArray::BaseWeapon' has a wrong offset!");
static_assert(offsetof(FSBZWeaponPartProgressionArray, WeaponPartProgressionArray) == 0x000008, "Member 'FSBZWeaponPartProgressionArray::WeaponPartProgressionArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAgilityAnimationQueryData
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FSBZAgilityAnimationQueryData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAgilityAnimationQueryData) == 0x000004, "Wrong alignment on FSBZAgilityAnimationQueryData");
static_assert(sizeof(FSBZAgilityAnimationQueryData) == 0x000008, "Wrong size on FSBZAgilityAnimationQueryData");

// ScriptStruct Starbreeze.SBZLookFocusHandler
// 0x0098 (0x0098 - 0x0000)
struct FSBZLookFocusHandler final
{
public:
	uint8                                         Pad_0[0x48];                                       // 0x0000(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class ASBZCharacter*                          Goal;                                              // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Animation;                                         // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x40];                                      // 0x0058(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZLookFocusHandler) == 0x000008, "Wrong alignment on FSBZLookFocusHandler");
static_assert(sizeof(FSBZLookFocusHandler) == 0x000098, "Wrong size on FSBZLookFocusHandler");
static_assert(offsetof(FSBZLookFocusHandler, Goal) == 0x000048, "Member 'FSBZLookFocusHandler::Goal' has a wrong offset!");
static_assert(offsetof(FSBZLookFocusHandler, Animation) == 0x000050, "Member 'FSBZLookFocusHandler::Animation' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAgilityTrajectory
// 0x0038 (0x0038 - 0x0000)
struct FSBZAgilityTrajectory final
{
public:
	ESBZAgilityType                               AgilityType;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSBZAgilityTrajectoryPoint>     Points;                                            // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	bool                                          bValid;                                            // 0x0018(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           ForcedMontage;                                     // 0x0020(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecomputeEndUsingAnimation;                       // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavAreaBase>               AreaClass;                                         // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FSBZAgilityTrajectory) == 0x000008, "Wrong alignment on FSBZAgilityTrajectory");
static_assert(sizeof(FSBZAgilityTrajectory) == 0x000038, "Wrong size on FSBZAgilityTrajectory");
static_assert(offsetof(FSBZAgilityTrajectory, AgilityType) == 0x000000, "Member 'FSBZAgilityTrajectory::AgilityType' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTrajectory, Points) == 0x000008, "Member 'FSBZAgilityTrajectory::Points' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTrajectory, bValid) == 0x000018, "Member 'FSBZAgilityTrajectory::bValid' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTrajectory, ForcedMontage) == 0x000020, "Member 'FSBZAgilityTrajectory::ForcedMontage' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTrajectory, bRecomputeEndUsingAnimation) == 0x000028, "Member 'FSBZAgilityTrajectory::bRecomputeEndUsingAnimation' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTrajectory, AreaClass) == 0x000030, "Member 'FSBZAgilityTrajectory::AreaClass' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAgilityTrajectoryDebugSettings
// 0x0006 (0x0006 - 0x0000)
struct FSBZAgilityTrajectoryDebugSettings final
{
public:
	bool                                          bDrawTrajectory;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawDebug;                                        // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         DrawStep;                                          // 0x0002(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawOnlyCurrentStep;                              // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x1];                                        // 0x0005(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAgilityTrajectoryDebugSettings) == 0x000002, "Wrong alignment on FSBZAgilityTrajectoryDebugSettings");
static_assert(sizeof(FSBZAgilityTrajectoryDebugSettings) == 0x000006, "Wrong size on FSBZAgilityTrajectoryDebugSettings");
static_assert(offsetof(FSBZAgilityTrajectoryDebugSettings, bDrawTrajectory) == 0x000000, "Member 'FSBZAgilityTrajectoryDebugSettings::bDrawTrajectory' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTrajectoryDebugSettings, bDrawDebug) == 0x000001, "Member 'FSBZAgilityTrajectoryDebugSettings::bDrawDebug' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTrajectoryDebugSettings, DrawStep) == 0x000002, "Member 'FSBZAgilityTrajectoryDebugSettings::DrawStep' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTrajectoryDebugSettings, bDrawOnlyCurrentStep) == 0x000004, "Member 'FSBZAgilityTrajectoryDebugSettings::bDrawOnlyCurrentStep' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCuttableTargetData
// 0x0010 (0x0018 - 0x0008)
struct FSBZCuttableTargetData final : public FGameplayAbilityTargetData
{
public:
	class AActor*                                 CuttableActor;                                     // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZCuttableTargetData) == 0x000008, "Wrong alignment on FSBZCuttableTargetData");
static_assert(sizeof(FSBZCuttableTargetData) == 0x000018, "Wrong size on FSBZCuttableTargetData");
static_assert(offsetof(FSBZCuttableTargetData, CuttableActor) == 0x000008, "Member 'FSBZCuttableTargetData::CuttableActor' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeaponGunKickMultiplierData
// 0x0010 (0x0010 - 0x0000)
struct FSBZWeaponGunKickMultiplierData final
{
public:
	float                                         Start;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Increment;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Threshold;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWeaponGunKickMultiplierData) == 0x000004, "Wrong alignment on FSBZWeaponGunKickMultiplierData");
static_assert(sizeof(FSBZWeaponGunKickMultiplierData) == 0x000010, "Wrong size on FSBZWeaponGunKickMultiplierData");
static_assert(offsetof(FSBZWeaponGunKickMultiplierData, Start) == 0x000000, "Member 'FSBZWeaponGunKickMultiplierData::Start' has a wrong offset!");
static_assert(offsetof(FSBZWeaponGunKickMultiplierData, Increment) == 0x000004, "Member 'FSBZWeaponGunKickMultiplierData::Increment' has a wrong offset!");
static_assert(offsetof(FSBZWeaponGunKickMultiplierData, Max) == 0x000008, "Member 'FSBZWeaponGunKickMultiplierData::Max' has a wrong offset!");
static_assert(offsetof(FSBZWeaponGunKickMultiplierData, Threshold) == 0x00000C, "Member 'FSBZWeaponGunKickMultiplierData::Threshold' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeaponGunKickData
// 0x0158 (0x0158 - 0x0000)
struct FSBZWeaponGunKickData final
{
public:
	float                                         SpeedDeflect;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedRecover;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     DeflectCurve;                                      // 0x0008(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     RecoverCurve;                                      // 0x0090(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FFloatInterval                         VerticalTop;                                       // 0x0118(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         VerticalBottom;                                    // 0x0120(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSBZWeaponGunKickMultiplierData        VerticalMultiplier;                                // 0x0128(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FFloatInterval                         HorizontalRight;                                   // 0x0138(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         HorizontalLeft;                                    // 0x0140(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSBZWeaponGunKickMultiplierData        HorizontalMultiplier;                              // 0x0148(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWeaponGunKickData) == 0x000008, "Wrong alignment on FSBZWeaponGunKickData");
static_assert(sizeof(FSBZWeaponGunKickData) == 0x000158, "Wrong size on FSBZWeaponGunKickData");
static_assert(offsetof(FSBZWeaponGunKickData, SpeedDeflect) == 0x000000, "Member 'FSBZWeaponGunKickData::SpeedDeflect' has a wrong offset!");
static_assert(offsetof(FSBZWeaponGunKickData, SpeedRecover) == 0x000004, "Member 'FSBZWeaponGunKickData::SpeedRecover' has a wrong offset!");
static_assert(offsetof(FSBZWeaponGunKickData, DeflectCurve) == 0x000008, "Member 'FSBZWeaponGunKickData::DeflectCurve' has a wrong offset!");
static_assert(offsetof(FSBZWeaponGunKickData, RecoverCurve) == 0x000090, "Member 'FSBZWeaponGunKickData::RecoverCurve' has a wrong offset!");
static_assert(offsetof(FSBZWeaponGunKickData, VerticalTop) == 0x000118, "Member 'FSBZWeaponGunKickData::VerticalTop' has a wrong offset!");
static_assert(offsetof(FSBZWeaponGunKickData, VerticalBottom) == 0x000120, "Member 'FSBZWeaponGunKickData::VerticalBottom' has a wrong offset!");
static_assert(offsetof(FSBZWeaponGunKickData, VerticalMultiplier) == 0x000128, "Member 'FSBZWeaponGunKickData::VerticalMultiplier' has a wrong offset!");
static_assert(offsetof(FSBZWeaponGunKickData, HorizontalRight) == 0x000138, "Member 'FSBZWeaponGunKickData::HorizontalRight' has a wrong offset!");
static_assert(offsetof(FSBZWeaponGunKickData, HorizontalLeft) == 0x000140, "Member 'FSBZWeaponGunKickData::HorizontalLeft' has a wrong offset!");
static_assert(offsetof(FSBZWeaponGunKickData, HorizontalMultiplier) == 0x000148, "Member 'FSBZWeaponGunKickData::HorizontalMultiplier' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAgilityTraversalQueryParamsRow
// 0x0240 (0x0240 - 0x0000)
struct FSBZAgilityTraversalQueryParamsRow final
{
public:
	ESBZAgilityTraversalType                      AgilityType;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPerformSprintCheck;                               // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMustWantToSprint;                                 // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRange                            ObstacleHeight;                                    // 0x0004(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSBZFloatLimit                         SpeedLimit;                                        // 0x0014(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FFloatRange                            TraverseDistancePerSpeed;                          // 0x001C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            TriggerDistancePerSpeed;                           // 0x002C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            DistAfterObstaclePerSpeed;                         // 0x003C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinFallHeight;                                     // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     JumpSpeedCurve;                                    // 0x0050(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bEntrySpeedOverridesJumpCurve;                     // 0x00D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     TraversalSpeedCurve;                               // 0x00E0(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bEntrySpeedOverridesTraversalCurve;                // 0x0168(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_169[0x7];                                      // 0x0169(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     LandingSpeedCurve;                                 // 0x0170(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bEntrySpeedOverridesLandCurve;                     // 0x01F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x3];                                      // 0x01F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EyeHeight;                                         // 0x01FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSBZLockCameraData                     LockCameraData;                                    // 0x0200(0x003C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FColor                                 DebugColor;                                        // 0x023C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAgilityTraversalQueryParamsRow) == 0x000008, "Wrong alignment on FSBZAgilityTraversalQueryParamsRow");
static_assert(sizeof(FSBZAgilityTraversalQueryParamsRow) == 0x000240, "Wrong size on FSBZAgilityTraversalQueryParamsRow");
static_assert(offsetof(FSBZAgilityTraversalQueryParamsRow, AgilityType) == 0x000000, "Member 'FSBZAgilityTraversalQueryParamsRow::AgilityType' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTraversalQueryParamsRow, bPerformSprintCheck) == 0x000001, "Member 'FSBZAgilityTraversalQueryParamsRow::bPerformSprintCheck' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTraversalQueryParamsRow, bMustWantToSprint) == 0x000002, "Member 'FSBZAgilityTraversalQueryParamsRow::bMustWantToSprint' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTraversalQueryParamsRow, ObstacleHeight) == 0x000004, "Member 'FSBZAgilityTraversalQueryParamsRow::ObstacleHeight' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTraversalQueryParamsRow, SpeedLimit) == 0x000014, "Member 'FSBZAgilityTraversalQueryParamsRow::SpeedLimit' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTraversalQueryParamsRow, TraverseDistancePerSpeed) == 0x00001C, "Member 'FSBZAgilityTraversalQueryParamsRow::TraverseDistancePerSpeed' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTraversalQueryParamsRow, TriggerDistancePerSpeed) == 0x00002C, "Member 'FSBZAgilityTraversalQueryParamsRow::TriggerDistancePerSpeed' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTraversalQueryParamsRow, DistAfterObstaclePerSpeed) == 0x00003C, "Member 'FSBZAgilityTraversalQueryParamsRow::DistAfterObstaclePerSpeed' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTraversalQueryParamsRow, MinFallHeight) == 0x00004C, "Member 'FSBZAgilityTraversalQueryParamsRow::MinFallHeight' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTraversalQueryParamsRow, JumpSpeedCurve) == 0x000050, "Member 'FSBZAgilityTraversalQueryParamsRow::JumpSpeedCurve' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTraversalQueryParamsRow, bEntrySpeedOverridesJumpCurve) == 0x0000D8, "Member 'FSBZAgilityTraversalQueryParamsRow::bEntrySpeedOverridesJumpCurve' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTraversalQueryParamsRow, TraversalSpeedCurve) == 0x0000E0, "Member 'FSBZAgilityTraversalQueryParamsRow::TraversalSpeedCurve' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTraversalQueryParamsRow, bEntrySpeedOverridesTraversalCurve) == 0x000168, "Member 'FSBZAgilityTraversalQueryParamsRow::bEntrySpeedOverridesTraversalCurve' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTraversalQueryParamsRow, LandingSpeedCurve) == 0x000170, "Member 'FSBZAgilityTraversalQueryParamsRow::LandingSpeedCurve' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTraversalQueryParamsRow, bEntrySpeedOverridesLandCurve) == 0x0001F8, "Member 'FSBZAgilityTraversalQueryParamsRow::bEntrySpeedOverridesLandCurve' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTraversalQueryParamsRow, EyeHeight) == 0x0001FC, "Member 'FSBZAgilityTraversalQueryParamsRow::EyeHeight' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTraversalQueryParamsRow, LockCameraData) == 0x000200, "Member 'FSBZAgilityTraversalQueryParamsRow::LockCameraData' has a wrong offset!");
static_assert(offsetof(FSBZAgilityTraversalQueryParamsRow, DebugColor) == 0x00023C, "Member 'FSBZAgilityTraversalQueryParamsRow::DebugColor' has a wrong offset!");

// ScriptStruct Starbreeze.SBZActionMetaData
// 0x0078 (0x0078 - 0x0000)
struct FSBZActionMetaData final
{
public:
	class FName                                   ItemName;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USBZAIAction*                           Action;                                            // 0x0010(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMaxAge;                                        // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxAge;                                            // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMinAge;                                        // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinAge;                                            // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USBZAttractorPredicate*>         AttractorPredicates;                               // 0x0028(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, NoClear, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  RequiredTags;                                      // 0x0038(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ExecutorRequiredTags;                              // 0x0058(0x0020)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZActionMetaData) == 0x000008, "Wrong alignment on FSBZActionMetaData");
static_assert(sizeof(FSBZActionMetaData) == 0x000078, "Wrong size on FSBZActionMetaData");
static_assert(offsetof(FSBZActionMetaData, ItemName) == 0x000000, "Member 'FSBZActionMetaData::ItemName' has a wrong offset!");
static_assert(offsetof(FSBZActionMetaData, Action) == 0x000010, "Member 'FSBZActionMetaData::Action' has a wrong offset!");
static_assert(offsetof(FSBZActionMetaData, bUseMaxAge) == 0x000018, "Member 'FSBZActionMetaData::bUseMaxAge' has a wrong offset!");
static_assert(offsetof(FSBZActionMetaData, MaxAge) == 0x00001C, "Member 'FSBZActionMetaData::MaxAge' has a wrong offset!");
static_assert(offsetof(FSBZActionMetaData, bUseMinAge) == 0x000020, "Member 'FSBZActionMetaData::bUseMinAge' has a wrong offset!");
static_assert(offsetof(FSBZActionMetaData, MinAge) == 0x000024, "Member 'FSBZActionMetaData::MinAge' has a wrong offset!");
static_assert(offsetof(FSBZActionMetaData, AttractorPredicates) == 0x000028, "Member 'FSBZActionMetaData::AttractorPredicates' has a wrong offset!");
static_assert(offsetof(FSBZActionMetaData, RequiredTags) == 0x000038, "Member 'FSBZActionMetaData::RequiredTags' has a wrong offset!");
static_assert(offsetof(FSBZActionMetaData, ExecutorRequiredTags) == 0x000058, "Member 'FSBZActionMetaData::ExecutorRequiredTags' has a wrong offset!");

// ScriptStruct Starbreeze.SBZKilledContextData
// 0x0018 (0x0018 - 0x0000)
struct FSBZKilledContextData final
{
public:
	class ASBZPlayerCharacter*                    PlayerCharacter;                                   // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZEquippableData*                     EquippableData;                                    // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZKilledContextData) == 0x000008, "Wrong alignment on FSBZKilledContextData");
static_assert(sizeof(FSBZKilledContextData) == 0x000018, "Wrong size on FSBZKilledContextData");
static_assert(offsetof(FSBZKilledContextData, PlayerCharacter) == 0x000000, "Member 'FSBZKilledContextData::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(FSBZKilledContextData, EquippableData) == 0x000008, "Member 'FSBZKilledContextData::EquippableData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZHackingZoneData
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FSBZHackingZoneData final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZHackingZoneData) == 0x000004, "Wrong alignment on FSBZHackingZoneData");
static_assert(sizeof(FSBZHackingZoneData) == 0x00000C, "Wrong size on FSBZHackingZoneData");

// ScriptStruct Starbreeze.SBZTagStanceMapping
// 0x0028 (0x0028 - 0x0000)
struct FSBZTagStanceMapping final
{
public:
	struct FGameplayTagContainer                  Tags;                                              // 0x0000(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	ESBZCharacterStance                           Stance;                                            // 0x0020(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZTagStanceMapping) == 0x000008, "Wrong alignment on FSBZTagStanceMapping");
static_assert(sizeof(FSBZTagStanceMapping) == 0x000028, "Wrong size on FSBZTagStanceMapping");
static_assert(offsetof(FSBZTagStanceMapping, Tags) == 0x000000, "Member 'FSBZTagStanceMapping::Tags' has a wrong offset!");
static_assert(offsetof(FSBZTagStanceMapping, Stance) == 0x000020, "Member 'FSBZTagStanceMapping::Stance' has a wrong offset!");

// ScriptStruct Starbreeze.SBZTranslucentTimer
// 0x0010 (0x0010 - 0x0000)
struct FSBZTranslucentTimer final
{
public:
	class UPrimitiveComponent*                    PrimitiveComponent;                                // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           TimerHandle;                                       // 0x0008(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZTranslucentTimer) == 0x000008, "Wrong alignment on FSBZTranslucentTimer");
static_assert(sizeof(FSBZTranslucentTimer) == 0x000010, "Wrong size on FSBZTranslucentTimer");
static_assert(offsetof(FSBZTranslucentTimer, PrimitiveComponent) == 0x000000, "Member 'FSBZTranslucentTimer::PrimitiveComponent' has a wrong offset!");
static_assert(offsetof(FSBZTranslucentTimer, TimerHandle) == 0x000008, "Member 'FSBZTranslucentTimer::TimerHandle' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAirPathConfig
// 0x0018 (0x0018 - 0x0000)
struct FSBZAirPathConfig final
{
public:
	int32                                         MaxNumSimultaneousQueries;                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SliceTime;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumNodesExpandedPerSliceCheck;                     // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNumNodes;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinNodeHalfSize;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirNavLinkModifier;                                // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAirPathConfig) == 0x000004, "Wrong alignment on FSBZAirPathConfig");
static_assert(sizeof(FSBZAirPathConfig) == 0x000018, "Wrong size on FSBZAirPathConfig");
static_assert(offsetof(FSBZAirPathConfig, MaxNumSimultaneousQueries) == 0x000000, "Member 'FSBZAirPathConfig::MaxNumSimultaneousQueries' has a wrong offset!");
static_assert(offsetof(FSBZAirPathConfig, SliceTime) == 0x000004, "Member 'FSBZAirPathConfig::SliceTime' has a wrong offset!");
static_assert(offsetof(FSBZAirPathConfig, NumNodesExpandedPerSliceCheck) == 0x000008, "Member 'FSBZAirPathConfig::NumNodesExpandedPerSliceCheck' has a wrong offset!");
static_assert(offsetof(FSBZAirPathConfig, MaxNumNodes) == 0x00000C, "Member 'FSBZAirPathConfig::MaxNumNodes' has a wrong offset!");
static_assert(offsetof(FSBZAirPathConfig, MinNodeHalfSize) == 0x000010, "Member 'FSBZAirPathConfig::MinNodeHalfSize' has a wrong offset!");
static_assert(offsetof(FSBZAirPathConfig, AirNavLinkModifier) == 0x000014, "Member 'FSBZAirPathConfig::AirNavLinkModifier' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAIConfigEvade
// 0x002C (0x002C - 0x0000)
struct FSBZAIConfigEvade final
{
public:
	float                                         MaxTimeSinceUnderFireToEvade;                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTimeAfterUnderFireToEvade;                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FastEvadeCoolDown;                                 // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlowEvadeCoolDown;                                 // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinFireDist;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSlowEvadeDist;                                  // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinFastEvadeDist;                                  // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngleToStopSlowEvade;                           // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngleToStartSlowEvade;                          // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxMovingSpeed;                                    // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTimeSinceDamage;                                // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAIConfigEvade) == 0x000004, "Wrong alignment on FSBZAIConfigEvade");
static_assert(sizeof(FSBZAIConfigEvade) == 0x00002C, "Wrong size on FSBZAIConfigEvade");
static_assert(offsetof(FSBZAIConfigEvade, MaxTimeSinceUnderFireToEvade) == 0x000000, "Member 'FSBZAIConfigEvade::MaxTimeSinceUnderFireToEvade' has a wrong offset!");
static_assert(offsetof(FSBZAIConfigEvade, MaxTimeAfterUnderFireToEvade) == 0x000004, "Member 'FSBZAIConfigEvade::MaxTimeAfterUnderFireToEvade' has a wrong offset!");
static_assert(offsetof(FSBZAIConfigEvade, FastEvadeCoolDown) == 0x000008, "Member 'FSBZAIConfigEvade::FastEvadeCoolDown' has a wrong offset!");
static_assert(offsetof(FSBZAIConfigEvade, SlowEvadeCoolDown) == 0x00000C, "Member 'FSBZAIConfigEvade::SlowEvadeCoolDown' has a wrong offset!");
static_assert(offsetof(FSBZAIConfigEvade, MinFireDist) == 0x000010, "Member 'FSBZAIConfigEvade::MinFireDist' has a wrong offset!");
static_assert(offsetof(FSBZAIConfigEvade, MinSlowEvadeDist) == 0x000014, "Member 'FSBZAIConfigEvade::MinSlowEvadeDist' has a wrong offset!");
static_assert(offsetof(FSBZAIConfigEvade, MinFastEvadeDist) == 0x000018, "Member 'FSBZAIConfigEvade::MinFastEvadeDist' has a wrong offset!");
static_assert(offsetof(FSBZAIConfigEvade, MaxAngleToStopSlowEvade) == 0x00001C, "Member 'FSBZAIConfigEvade::MaxAngleToStopSlowEvade' has a wrong offset!");
static_assert(offsetof(FSBZAIConfigEvade, MaxAngleToStartSlowEvade) == 0x000020, "Member 'FSBZAIConfigEvade::MaxAngleToStartSlowEvade' has a wrong offset!");
static_assert(offsetof(FSBZAIConfigEvade, MaxMovingSpeed) == 0x000024, "Member 'FSBZAIConfigEvade::MaxMovingSpeed' has a wrong offset!");
static_assert(offsetof(FSBZAIConfigEvade, MinTimeSinceDamage) == 0x000028, "Member 'FSBZAIConfigEvade::MinTimeSinceDamage' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMergePartyStatus
// 0x0018 (0x0018 - 0x0000)
struct FSBZMergePartyStatus final
{
public:
	bool                                          bIsSelected;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLeader;                                         // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PartyCode;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZMergePartyStatus) == 0x000008, "Wrong alignment on FSBZMergePartyStatus");
static_assert(sizeof(FSBZMergePartyStatus) == 0x000018, "Wrong size on FSBZMergePartyStatus");
static_assert(offsetof(FSBZMergePartyStatus, bIsSelected) == 0x000000, "Member 'FSBZMergePartyStatus::bIsSelected' has a wrong offset!");
static_assert(offsetof(FSBZMergePartyStatus, bIsLeader) == 0x000001, "Member 'FSBZMergePartyStatus::bIsLeader' has a wrong offset!");
static_assert(offsetof(FSBZMergePartyStatus, PartyCode) == 0x000008, "Member 'FSBZMergePartyStatus::PartyCode' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAIConfigDPSData
// 0x0008 (0x0008 - 0x0000)
struct FSBZAIConfigDPSData final
{
public:
	float                                         Damage;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Interval;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAIConfigDPSData) == 0x000004, "Wrong alignment on FSBZAIConfigDPSData");
static_assert(sizeof(FSBZAIConfigDPSData) == 0x000008, "Wrong size on FSBZAIConfigDPSData");
static_assert(offsetof(FSBZAIConfigDPSData, Damage) == 0x000000, "Member 'FSBZAIConfigDPSData::Damage' has a wrong offset!");
static_assert(offsetof(FSBZAIConfigDPSData, Interval) == 0x000004, "Member 'FSBZAIConfigDPSData::Interval' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAIDataProvider_NavQueryFilter
// 0x0008 (0x0040 - 0x0038)
struct FSBZAIDataProvider_NavQueryFilter final : public FAIDataProviderTypedValue
{
public:
	TSubclassOf<class UNavigationQueryFilter>     DefaultValue;                                      // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAIDataProvider_NavQueryFilter) == 0x000008, "Wrong alignment on FSBZAIDataProvider_NavQueryFilter");
static_assert(sizeof(FSBZAIDataProvider_NavQueryFilter) == 0x000040, "Wrong size on FSBZAIDataProvider_NavQueryFilter");
static_assert(offsetof(FSBZAIDataProvider_NavQueryFilter, DefaultValue) == 0x000038, "Member 'FSBZAIDataProvider_NavQueryFilter::DefaultValue' has a wrong offset!");

// ScriptStruct Starbreeze.SBZActorMultiHitResult
// 0x02F4 (0x02F4 - 0x0000)
struct FSBZActorMultiHitResult final
{
public:
	TWeakObjectPtr<class AActor>                  ActorPtr;                                          // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x2EC];                                      // 0x0008(0x02EC)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZActorMultiHitResult) == 0x000004, "Wrong alignment on FSBZActorMultiHitResult");
static_assert(sizeof(FSBZActorMultiHitResult) == 0x0002F4, "Wrong size on FSBZActorMultiHitResult");
static_assert(offsetof(FSBZActorMultiHitResult, ActorPtr) == 0x000000, "Member 'FSBZActorMultiHitResult::ActorPtr' has a wrong offset!");

// ScriptStruct Starbreeze.SBZDownedByTypeVO
// 0x0018 (0x0018 - 0x0000)
struct FSBZDownedByTypeVO final
{
public:
	class USBZVoiceCommentDataAsset*              DownedByVO;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TypeTag;                                           // 0x0008(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZDownedByTypeVO) == 0x000008, "Wrong alignment on FSBZDownedByTypeVO");
static_assert(sizeof(FSBZDownedByTypeVO) == 0x000018, "Wrong size on FSBZDownedByTypeVO");
static_assert(offsetof(FSBZDownedByTypeVO, DownedByVO) == 0x000000, "Member 'FSBZDownedByTypeVO::DownedByVO' has a wrong offset!");
static_assert(offsetof(FSBZDownedByTypeVO, TypeTag) == 0x000008, "Member 'FSBZDownedByTypeVO::TypeTag' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInvestigateData
// 0x0018 (0x0018 - 0x0000)
struct FSBZInvestigateData final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Target;                                            // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZInvestigateData) == 0x000008, "Wrong alignment on FSBZInvestigateData");
static_assert(sizeof(FSBZInvestigateData) == 0x000018, "Wrong size on FSBZInvestigateData");
static_assert(offsetof(FSBZInvestigateData, Location) == 0x000000, "Member 'FSBZInvestigateData::Location' has a wrong offset!");
static_assert(offsetof(FSBZInvestigateData, Target) == 0x000010, "Member 'FSBZInvestigateData::Target' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAirNavLinkData
// 0x0028 (0x0028 - 0x0000)
struct FSBZAirNavLinkData final
{
public:
	uint32                                        LeftAirNodeIndex;                                  // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        RightAirNodeIndex;                                 // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        NavLinkID;                                         // 0x0008(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        Points;                                            // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsOpen;                                           // 0x0020(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAirNavLinkData) == 0x000008, "Wrong alignment on FSBZAirNavLinkData");
static_assert(sizeof(FSBZAirNavLinkData) == 0x000028, "Wrong size on FSBZAirNavLinkData");
static_assert(offsetof(FSBZAirNavLinkData, LeftAirNodeIndex) == 0x000000, "Member 'FSBZAirNavLinkData::LeftAirNodeIndex' has a wrong offset!");
static_assert(offsetof(FSBZAirNavLinkData, RightAirNodeIndex) == 0x000004, "Member 'FSBZAirNavLinkData::RightAirNodeIndex' has a wrong offset!");
static_assert(offsetof(FSBZAirNavLinkData, NavLinkID) == 0x000008, "Member 'FSBZAirNavLinkData::NavLinkID' has a wrong offset!");
static_assert(offsetof(FSBZAirNavLinkData, Points) == 0x000010, "Member 'FSBZAirNavLinkData::Points' has a wrong offset!");
static_assert(offsetof(FSBZAirNavLinkData, bIsOpen) == 0x000020, "Member 'FSBZAirNavLinkData::bIsOpen' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAirPath
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x08) FSBZAirPath final
{
public:
	uint8                                         Pad_0[0x60];                                       // 0x0000(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAirPath) == 0x000008, "Wrong alignment on FSBZAirPath");
static_assert(sizeof(FSBZAirPath) == 0x000060, "Wrong size on FSBZAirPath");

// ScriptStruct Starbreeze.SBZInvestigationData
// 0x0038 (0x0038 - 0x0000)
struct FSBZInvestigationData final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  Investigator;                                      // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZAIOrder_Investigate*                OrderInstance;                                     // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZActionNotificationAsset*            Escalation;                                        // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZInvestigationData) == 0x000008, "Wrong alignment on FSBZInvestigationData");
static_assert(sizeof(FSBZInvestigationData) == 0x000038, "Wrong size on FSBZInvestigationData");
static_assert(offsetof(FSBZInvestigationData, Target) == 0x000000, "Member 'FSBZInvestigationData::Target' has a wrong offset!");
static_assert(offsetof(FSBZInvestigationData, Instigator) == 0x000008, "Member 'FSBZInvestigationData::Instigator' has a wrong offset!");
static_assert(offsetof(FSBZInvestigationData, Investigator) == 0x000010, "Member 'FSBZInvestigationData::Investigator' has a wrong offset!");
static_assert(offsetof(FSBZInvestigationData, OrderInstance) == 0x000018, "Member 'FSBZInvestigationData::OrderInstance' has a wrong offset!");
static_assert(offsetof(FSBZInvestigationData, Escalation) == 0x000020, "Member 'FSBZInvestigationData::Escalation' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCoverShootingPointAiVisibilityInfo
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FSBZCoverShootingPointAiVisibilityInfo final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZCoverShootingPointAiVisibilityInfo) == 0x000004, "Wrong alignment on FSBZCoverShootingPointAiVisibilityInfo");
static_assert(sizeof(FSBZCoverShootingPointAiVisibilityInfo) == 0x000014, "Wrong size on FSBZCoverShootingPointAiVisibilityInfo");

// ScriptStruct Starbreeze.SBZInvestigationRequest
// 0x0038 (0x0038 - 0x0000)
struct FSBZInvestigationRequest final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASBZRoomVolume*                         Room;                                              // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0018(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZInvestigationMode                         Mode;                                              // 0x0024(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USBZActionNotificationAsset*            EscalationReason;                                  // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUrgent;                                         // 0x0030(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZInvestigationRequest) == 0x000008, "Wrong alignment on FSBZInvestigationRequest");
static_assert(sizeof(FSBZInvestigationRequest) == 0x000038, "Wrong size on FSBZInvestigationRequest");
static_assert(offsetof(FSBZInvestigationRequest, Target) == 0x000000, "Member 'FSBZInvestigationRequest::Target' has a wrong offset!");
static_assert(offsetof(FSBZInvestigationRequest, Instigator) == 0x000008, "Member 'FSBZInvestigationRequest::Instigator' has a wrong offset!");
static_assert(offsetof(FSBZInvestigationRequest, Room) == 0x000010, "Member 'FSBZInvestigationRequest::Room' has a wrong offset!");
static_assert(offsetof(FSBZInvestigationRequest, Location) == 0x000018, "Member 'FSBZInvestigationRequest::Location' has a wrong offset!");
static_assert(offsetof(FSBZInvestigationRequest, Mode) == 0x000024, "Member 'FSBZInvestigationRequest::Mode' has a wrong offset!");
static_assert(offsetof(FSBZInvestigationRequest, EscalationReason) == 0x000028, "Member 'FSBZInvestigationRequest::EscalationReason' has a wrong offset!");
static_assert(offsetof(FSBZInvestigationRequest, bIsUrgent) == 0x000030, "Member 'FSBZInvestigationRequest::bIsUrgent' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSuitInventorySlot
// 0x0060 (0x0088 - 0x0028)
struct FSBZSuitInventorySlot final : public FSBZInventorySlot
{
public:
	struct FGuid                                  SuitInSlotEntitlementId;                           // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SuitInSlotAccelByteItemSku;                        // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZItemInventorySlotType                     SuitInventorySlotType;                             // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSBZSuitConfig                         SuitConfig;                                        // 0x0050(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FSBZSuitPresetConfig                   SuitPresetConfig;                                  // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSuitInventorySlot) == 0x000008, "Wrong alignment on FSBZSuitInventorySlot");
static_assert(sizeof(FSBZSuitInventorySlot) == 0x000088, "Wrong size on FSBZSuitInventorySlot");
static_assert(offsetof(FSBZSuitInventorySlot, SuitInSlotEntitlementId) == 0x000028, "Member 'FSBZSuitInventorySlot::SuitInSlotEntitlementId' has a wrong offset!");
static_assert(offsetof(FSBZSuitInventorySlot, SuitInSlotAccelByteItemSku) == 0x000038, "Member 'FSBZSuitInventorySlot::SuitInSlotAccelByteItemSku' has a wrong offset!");
static_assert(offsetof(FSBZSuitInventorySlot, SuitInventorySlotType) == 0x000048, "Member 'FSBZSuitInventorySlot::SuitInventorySlotType' has a wrong offset!");
static_assert(offsetof(FSBZSuitInventorySlot, SuitConfig) == 0x000050, "Member 'FSBZSuitInventorySlot::SuitConfig' has a wrong offset!");
static_assert(offsetof(FSBZSuitInventorySlot, SuitPresetConfig) == 0x000078, "Member 'FSBZSuitInventorySlot::SuitPresetConfig' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAITeamStimulusEvent
// 0x0040 (0x0040 - 0x0000)
struct FSBZAITeamStimulusEvent final
{
public:
	class AActor*                                 Enemy;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x20];                                       // 0x0008(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Broadcaster;                                       // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAITeamStimulusEvent) == 0x000008, "Wrong alignment on FSBZAITeamStimulusEvent");
static_assert(sizeof(FSBZAITeamStimulusEvent) == 0x000040, "Wrong size on FSBZAITeamStimulusEvent");
static_assert(offsetof(FSBZAITeamStimulusEvent, Enemy) == 0x000000, "Member 'FSBZAITeamStimulusEvent::Enemy' has a wrong offset!");
static_assert(offsetof(FSBZAITeamStimulusEvent, Broadcaster) == 0x000028, "Member 'FSBZAITeamStimulusEvent::Broadcaster' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAITouchEvent
// 0x0028 (0x0028 - 0x0000)
struct FSBZAITouchEvent final
{
public:
	class AAIController*                          TouchReceiver;                                     // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x18];                                      // 0x0010(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAITouchEvent) == 0x000008, "Wrong alignment on FSBZAITouchEvent");
static_assert(sizeof(FSBZAITouchEvent) == 0x000028, "Wrong size on FSBZAITouchEvent");
static_assert(offsetof(FSBZAITouchEvent, TouchReceiver) == 0x000000, "Member 'FSBZAITouchEvent::TouchReceiver' has a wrong offset!");
static_assert(offsetof(FSBZAITouchEvent, OtherActor) == 0x000008, "Member 'FSBZAITouchEvent::OtherActor' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCreditsRow
// 0x0060 (0x0068 - 0x0008)
struct FSBZCreditsRow final : public FTableRowBase
{
public:
	ESBZCreditsType                               Type;                                              // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Text;                                              // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FString                                 String;                                            // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TextSecond;                                        // 0x0038(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FString                                 StringSecond;                                      // 0x0050(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Texture;                                           // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZCreditsRow) == 0x000008, "Wrong alignment on FSBZCreditsRow");
static_assert(sizeof(FSBZCreditsRow) == 0x000068, "Wrong size on FSBZCreditsRow");
static_assert(offsetof(FSBZCreditsRow, Type) == 0x000008, "Member 'FSBZCreditsRow::Type' has a wrong offset!");
static_assert(offsetof(FSBZCreditsRow, Text) == 0x000010, "Member 'FSBZCreditsRow::Text' has a wrong offset!");
static_assert(offsetof(FSBZCreditsRow, String) == 0x000028, "Member 'FSBZCreditsRow::String' has a wrong offset!");
static_assert(offsetof(FSBZCreditsRow, TextSecond) == 0x000038, "Member 'FSBZCreditsRow::TextSecond' has a wrong offset!");
static_assert(offsetof(FSBZCreditsRow, StringSecond) == 0x000050, "Member 'FSBZCreditsRow::StringSecond' has a wrong offset!");
static_assert(offsetof(FSBZCreditsRow, Texture) == 0x000060, "Member 'FSBZCreditsRow::Texture' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCosmeticDamageDistance
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FSBZCosmeticDamageDistance final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZCosmeticDamageDistance) == 0x000004, "Wrong alignment on FSBZCosmeticDamageDistance");
static_assert(sizeof(FSBZCosmeticDamageDistance) == 0x000008, "Wrong size on FSBZCosmeticDamageDistance");

// ScriptStruct Starbreeze.SBZLocationInformation
// 0x0048 (0x0048 - 0x0000)
struct FSBZLocationInformation final
{
public:
	class FText                                   MainInformation;                                   // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   SecondaryInformation;                              // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   AdditionalInformation;                             // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZLocationInformation) == 0x000008, "Wrong alignment on FSBZLocationInformation");
static_assert(sizeof(FSBZLocationInformation) == 0x000048, "Wrong size on FSBZLocationInformation");
static_assert(offsetof(FSBZLocationInformation, MainInformation) == 0x000000, "Member 'FSBZLocationInformation::MainInformation' has a wrong offset!");
static_assert(offsetof(FSBZLocationInformation, SecondaryInformation) == 0x000018, "Member 'FSBZLocationInformation::SecondaryInformation' has a wrong offset!");
static_assert(offsetof(FSBZLocationInformation, AdditionalInformation) == 0x000030, "Member 'FSBZLocationInformation::AdditionalInformation' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAISquadOrderData
// 0x0010 (0x0010 - 0x0000)
struct FSBZAISquadOrderData final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAISquadOrderData) == 0x000008, "Wrong alignment on FSBZAISquadOrderData");
static_assert(sizeof(FSBZAISquadOrderData) == 0x000010, "Wrong size on FSBZAISquadOrderData");
static_assert(offsetof(FSBZAISquadOrderData, TargetActor) == 0x000000, "Member 'FSBZAISquadOrderData::TargetActor' has a wrong offset!");

// ScriptStruct Starbreeze.SBZStimuliReaction
// 0x0068 (0x0068 - 0x0000)
struct FSBZStimuliReaction final
{
public:
	class FText                                   Description;                                       // 0x0000(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint16                                        AllowedStates;                                     // 0x0018(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AllowedBehaviors;                                  // 0x001A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x5];                                       // 0x001B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  Tags;                                              // 0x0020(0x0020)(Edit, NativeAccessSpecifierPublic)
	class USBZAIAction*                           Action;                                            // 0x0040(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldSetToIsAlert;                               // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USBZReactionPredicate*                  Predicate;                                         // 0x0050(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USBZReactionPredicate*>          Predicates;                                        // 0x0058(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZStimuliReaction) == 0x000008, "Wrong alignment on FSBZStimuliReaction");
static_assert(sizeof(FSBZStimuliReaction) == 0x000068, "Wrong size on FSBZStimuliReaction");
static_assert(offsetof(FSBZStimuliReaction, Description) == 0x000000, "Member 'FSBZStimuliReaction::Description' has a wrong offset!");
static_assert(offsetof(FSBZStimuliReaction, AllowedStates) == 0x000018, "Member 'FSBZStimuliReaction::AllowedStates' has a wrong offset!");
static_assert(offsetof(FSBZStimuliReaction, AllowedBehaviors) == 0x00001A, "Member 'FSBZStimuliReaction::AllowedBehaviors' has a wrong offset!");
static_assert(offsetof(FSBZStimuliReaction, Tags) == 0x000020, "Member 'FSBZStimuliReaction::Tags' has a wrong offset!");
static_assert(offsetof(FSBZStimuliReaction, Action) == 0x000040, "Member 'FSBZStimuliReaction::Action' has a wrong offset!");
static_assert(offsetof(FSBZStimuliReaction, bShouldSetToIsAlert) == 0x000048, "Member 'FSBZStimuliReaction::bShouldSetToIsAlert' has a wrong offset!");
static_assert(offsetof(FSBZStimuliReaction, Predicate) == 0x000050, "Member 'FSBZStimuliReaction::Predicate' has a wrong offset!");
static_assert(offsetof(FSBZStimuliReaction, Predicates) == 0x000058, "Member 'FSBZStimuliReaction::Predicates' has a wrong offset!");

// ScriptStruct Starbreeze.SBZLaserPointConnection
// 0x0040 (0x0040 - 0x0000)
struct FSBZLaserPointConnection final
{
public:
	struct FSBZComponentSelector                  PointA;                                            // 0x0000(0x0020)(Edit, DisableEditOnTemplate, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FSBZComponentSelector                  PointB;                                            // 0x0020(0x0020)(Edit, DisableEditOnTemplate, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZLaserPointConnection) == 0x000008, "Wrong alignment on FSBZLaserPointConnection");
static_assert(sizeof(FSBZLaserPointConnection) == 0x000040, "Wrong size on FSBZLaserPointConnection");
static_assert(offsetof(FSBZLaserPointConnection, PointA) == 0x000000, "Member 'FSBZLaserPointConnection::PointA' has a wrong offset!");
static_assert(offsetof(FSBZLaserPointConnection, PointB) == 0x000020, "Member 'FSBZLaserPointConnection::PointB' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAIMontageMoveRequest
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FSBZAIMontageMoveRequest final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAIMontageMoveRequest) == 0x000008, "Wrong alignment on FSBZAIMontageMoveRequest");
static_assert(sizeof(FSBZAIMontageMoveRequest) == 0x000038, "Wrong size on FSBZAIMontageMoveRequest");

// ScriptStruct Starbreeze.SBZChallengeDailySlot
// 0x0001 (0x0001 - 0x0000)
struct FSBZChallengeDailySlot final
{
public:
	ESBZChallengeDailyCompletionTimeType          ChallengeDailyCompletionTimeType;                  // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZChallengeDailySlot) == 0x000001, "Wrong alignment on FSBZChallengeDailySlot");
static_assert(sizeof(FSBZChallengeDailySlot) == 0x000001, "Wrong size on FSBZChallengeDailySlot");
static_assert(offsetof(FSBZChallengeDailySlot, ChallengeDailyCompletionTimeType) == 0x000000, "Member 'FSBZChallengeDailySlot::ChallengeDailyCompletionTimeType' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSuspectData
// 0x0018 (0x0018 - 0x0000)
struct FSBZSuspectData final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZSuspectData) == 0x000008, "Wrong alignment on FSBZSuspectData");
static_assert(sizeof(FSBZSuspectData) == 0x000018, "Wrong size on FSBZSuspectData");
static_assert(offsetof(FSBZSuspectData, Target) == 0x000000, "Member 'FSBZSuspectData::Target' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeaponAimAssistMagnetismData
// 0x0010 (0x0010 - 0x0000)
struct FSBZWeaponAimAssistMagnetismData final
{
public:
	float                                         MaxDistance;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BulletDeviationDistance;                           // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BulletMagnetismSpread;                             // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSpread;                                     // 0x000C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZWeaponAimAssistMagnetismData) == 0x000004, "Wrong alignment on FSBZWeaponAimAssistMagnetismData");
static_assert(sizeof(FSBZWeaponAimAssistMagnetismData) == 0x000010, "Wrong size on FSBZWeaponAimAssistMagnetismData");
static_assert(offsetof(FSBZWeaponAimAssistMagnetismData, MaxDistance) == 0x000000, "Member 'FSBZWeaponAimAssistMagnetismData::MaxDistance' has a wrong offset!");
static_assert(offsetof(FSBZWeaponAimAssistMagnetismData, BulletDeviationDistance) == 0x000004, "Member 'FSBZWeaponAimAssistMagnetismData::BulletDeviationDistance' has a wrong offset!");
static_assert(offsetof(FSBZWeaponAimAssistMagnetismData, BulletMagnetismSpread) == 0x000008, "Member 'FSBZWeaponAimAssistMagnetismData::BulletMagnetismSpread' has a wrong offset!");
static_assert(offsetof(FSBZWeaponAimAssistMagnetismData, bIgnoreSpread) == 0x00000C, "Member 'FSBZWeaponAimAssistMagnetismData::bIgnoreSpread' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeaponAimAssistData
// 0x0048 (0x0048 - 0x0000)
struct FSBZWeaponAimAssistData final
{
public:
	float                                         DetectionSideDistance;                             // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DetectionDistancePriority;                         // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTargetSelectionDuration;                        // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDuration;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDuration;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTriggeredByWeaponFire;                          // 0x0014(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StickyAimDurationOnWeaponFire;                     // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EscapeSpeedIn;                                     // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EscapeSpeedOut;                                    // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimAssistSpeed;                                    // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistance;                                       // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SensitivityModifier;                               // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSBZWeaponAimAssistMagnetismData> MagnetismDistanceDataArray;                      // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bUseAllSockets;                                    // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZWeaponAimAssistData) == 0x000008, "Wrong alignment on FSBZWeaponAimAssistData");
static_assert(sizeof(FSBZWeaponAimAssistData) == 0x000048, "Wrong size on FSBZWeaponAimAssistData");
static_assert(offsetof(FSBZWeaponAimAssistData, DetectionSideDistance) == 0x000000, "Member 'FSBZWeaponAimAssistData::DetectionSideDistance' has a wrong offset!");
static_assert(offsetof(FSBZWeaponAimAssistData, DetectionDistancePriority) == 0x000004, "Member 'FSBZWeaponAimAssistData::DetectionDistancePriority' has a wrong offset!");
static_assert(offsetof(FSBZWeaponAimAssistData, MinTargetSelectionDuration) == 0x000008, "Member 'FSBZWeaponAimAssistData::MinTargetSelectionDuration' has a wrong offset!");
static_assert(offsetof(FSBZWeaponAimAssistData, MinDuration) == 0x00000C, "Member 'FSBZWeaponAimAssistData::MinDuration' has a wrong offset!");
static_assert(offsetof(FSBZWeaponAimAssistData, MaxDuration) == 0x000010, "Member 'FSBZWeaponAimAssistData::MaxDuration' has a wrong offset!");
static_assert(offsetof(FSBZWeaponAimAssistData, bIsTriggeredByWeaponFire) == 0x000014, "Member 'FSBZWeaponAimAssistData::bIsTriggeredByWeaponFire' has a wrong offset!");
static_assert(offsetof(FSBZWeaponAimAssistData, StickyAimDurationOnWeaponFire) == 0x000018, "Member 'FSBZWeaponAimAssistData::StickyAimDurationOnWeaponFire' has a wrong offset!");
static_assert(offsetof(FSBZWeaponAimAssistData, EscapeSpeedIn) == 0x00001C, "Member 'FSBZWeaponAimAssistData::EscapeSpeedIn' has a wrong offset!");
static_assert(offsetof(FSBZWeaponAimAssistData, EscapeSpeedOut) == 0x000020, "Member 'FSBZWeaponAimAssistData::EscapeSpeedOut' has a wrong offset!");
static_assert(offsetof(FSBZWeaponAimAssistData, AimAssistSpeed) == 0x000024, "Member 'FSBZWeaponAimAssistData::AimAssistSpeed' has a wrong offset!");
static_assert(offsetof(FSBZWeaponAimAssistData, MinDistance) == 0x000028, "Member 'FSBZWeaponAimAssistData::MinDistance' has a wrong offset!");
static_assert(offsetof(FSBZWeaponAimAssistData, SensitivityModifier) == 0x00002C, "Member 'FSBZWeaponAimAssistData::SensitivityModifier' has a wrong offset!");
static_assert(offsetof(FSBZWeaponAimAssistData, MagnetismDistanceDataArray) == 0x000030, "Member 'FSBZWeaponAimAssistData::MagnetismDistanceDataArray' has a wrong offset!");
static_assert(offsetof(FSBZWeaponAimAssistData, bUseAllSockets) == 0x000040, "Member 'FSBZWeaponAimAssistData::bUseAllSockets' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAIEscortStateData
// 0x0018 (0x0018 - 0x0000)
struct FSBZAIEscortStateData final
{
public:
	class UBehaviorTree*                          EscortStateBehavior;                               // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Priority;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     NavQueryFilterOverride;                            // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAIEscortStateData) == 0x000008, "Wrong alignment on FSBZAIEscortStateData");
static_assert(sizeof(FSBZAIEscortStateData) == 0x000018, "Wrong size on FSBZAIEscortStateData");
static_assert(offsetof(FSBZAIEscortStateData, EscortStateBehavior) == 0x000000, "Member 'FSBZAIEscortStateData::EscortStateBehavior' has a wrong offset!");
static_assert(offsetof(FSBZAIEscortStateData, Priority) == 0x000008, "Member 'FSBZAIEscortStateData::Priority' has a wrong offset!");
static_assert(offsetof(FSBZAIEscortStateData, NavQueryFilterOverride) == 0x000010, "Member 'FSBZAIEscortStateData::NavQueryFilterOverride' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAIUtilityDeciderDebugData
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FSBZAIUtilityDeciderDebugData final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAIUtilityDeciderDebugData) == 0x000008, "Wrong alignment on FSBZAIUtilityDeciderDebugData");
static_assert(sizeof(FSBZAIUtilityDeciderDebugData) == 0x000028, "Wrong size on FSBZAIUtilityDeciderDebugData");

// ScriptStruct Starbreeze.SBZGlobalVoiceCommentPermission
// 0x0008 (0x0008 - 0x0000)
struct FSBZGlobalVoiceCommentPermission final
{
public:
	float                                         CoolDown;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZGlobalVoiceCommentPermission) == 0x000004, "Wrong alignment on FSBZGlobalVoiceCommentPermission");
static_assert(sizeof(FSBZGlobalVoiceCommentPermission) == 0x000008, "Wrong size on FSBZGlobalVoiceCommentPermission");
static_assert(offsetof(FSBZGlobalVoiceCommentPermission, CoolDown) == 0x000000, "Member 'FSBZGlobalVoiceCommentPermission::CoolDown' has a wrong offset!");
static_assert(offsetof(FSBZGlobalVoiceCommentPermission, Radius) == 0x000004, "Member 'FSBZGlobalVoiceCommentPermission::Radius' has a wrong offset!");

// ScriptStruct Starbreeze.SBZVoiceSwitchPerPerformer
// 0x0018 (0x0018 - 0x0000)
struct FSBZVoiceSwitchPerPerformer final
{
public:
	ESBZDialogPerformer                           Performer;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         AllowedVoiceSwitches;                              // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZVoiceSwitchPerPerformer) == 0x000008, "Wrong alignment on FSBZVoiceSwitchPerPerformer");
static_assert(sizeof(FSBZVoiceSwitchPerPerformer) == 0x000018, "Wrong size on FSBZVoiceSwitchPerPerformer");
static_assert(offsetof(FSBZVoiceSwitchPerPerformer, Performer) == 0x000000, "Member 'FSBZVoiceSwitchPerPerformer::Performer' has a wrong offset!");
static_assert(offsetof(FSBZVoiceSwitchPerPerformer, AllowedVoiceSwitches) == 0x000008, "Member 'FSBZVoiceSwitchPerPerformer::AllowedVoiceSwitches' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAIVisibilitySerializablePayload
// 0x0070 (0x0070 - 0x0000)
struct FSBZAIVisibilitySerializablePayload final
{
public:
	TArray<uint16>                                CrouchDistances;                                   // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint16>                                StandDistances;                                    // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint16>                                UpAzymut15Distances;                               // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint16>                                UpAzymut30Distances;                               // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint16>                                UpAzymut45Distances;                               // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint16>                                UpAzymut60Distances;                               // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FIntVector                             Center;                                            // 0x0060(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAIVisibilitySerializablePayload) == 0x000008, "Wrong alignment on FSBZAIVisibilitySerializablePayload");
static_assert(sizeof(FSBZAIVisibilitySerializablePayload) == 0x000070, "Wrong size on FSBZAIVisibilitySerializablePayload");
static_assert(offsetof(FSBZAIVisibilitySerializablePayload, CrouchDistances) == 0x000000, "Member 'FSBZAIVisibilitySerializablePayload::CrouchDistances' has a wrong offset!");
static_assert(offsetof(FSBZAIVisibilitySerializablePayload, StandDistances) == 0x000010, "Member 'FSBZAIVisibilitySerializablePayload::StandDistances' has a wrong offset!");
static_assert(offsetof(FSBZAIVisibilitySerializablePayload, UpAzymut15Distances) == 0x000020, "Member 'FSBZAIVisibilitySerializablePayload::UpAzymut15Distances' has a wrong offset!");
static_assert(offsetof(FSBZAIVisibilitySerializablePayload, UpAzymut30Distances) == 0x000030, "Member 'FSBZAIVisibilitySerializablePayload::UpAzymut30Distances' has a wrong offset!");
static_assert(offsetof(FSBZAIVisibilitySerializablePayload, UpAzymut45Distances) == 0x000040, "Member 'FSBZAIVisibilitySerializablePayload::UpAzymut45Distances' has a wrong offset!");
static_assert(offsetof(FSBZAIVisibilitySerializablePayload, UpAzymut60Distances) == 0x000050, "Member 'FSBZAIVisibilitySerializablePayload::UpAzymut60Distances' has a wrong offset!");
static_assert(offsetof(FSBZAIVisibilitySerializablePayload, Center) == 0x000060, "Member 'FSBZAIVisibilitySerializablePayload::Center' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeaponPatternDataSingleColorAreaList
// 0x0010 (0x0010 - 0x0000)
struct FSBZWeaponPatternDataSingleColorAreaList final
{
public:
	TArray<class USBZWeaponPatternAreaData*>      AreaList;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWeaponPatternDataSingleColorAreaList) == 0x000008, "Wrong alignment on FSBZWeaponPatternDataSingleColorAreaList");
static_assert(sizeof(FSBZWeaponPatternDataSingleColorAreaList) == 0x000010, "Wrong size on FSBZWeaponPatternDataSingleColorAreaList");
static_assert(offsetof(FSBZWeaponPatternDataSingleColorAreaList, AreaList) == 0x000000, "Member 'FSBZWeaponPatternDataSingleColorAreaList::AreaList' has a wrong offset!");

// ScriptStruct Starbreeze.SBZRandomRoomDynData
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FSBZRandomRoomDynData final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZRandomRoomDynData) == 0x000008, "Wrong alignment on FSBZRandomRoomDynData");
static_assert(sizeof(FSBZRandomRoomDynData) == 0x000050, "Wrong size on FSBZRandomRoomDynData");

// ScriptStruct Starbreeze.SBZCoverPointVisibilityCheckData
// 0x0020 (0x0020 - 0x0000)
struct FSBZCoverPointVisibilityCheckData final
{
public:
	class ASBZCoverPoint*                         CoverPoint;                                        // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         Enemies;                                           // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZCoverPointVisibilityCheckData) == 0x000008, "Wrong alignment on FSBZCoverPointVisibilityCheckData");
static_assert(sizeof(FSBZCoverPointVisibilityCheckData) == 0x000020, "Wrong size on FSBZCoverPointVisibilityCheckData");
static_assert(offsetof(FSBZCoverPointVisibilityCheckData, CoverPoint) == 0x000000, "Member 'FSBZCoverPointVisibilityCheckData::CoverPoint' has a wrong offset!");
static_assert(offsetof(FSBZCoverPointVisibilityCheckData, Enemies) == 0x000010, "Member 'FSBZCoverPointVisibilityCheckData::Enemies' has a wrong offset!");

// ScriptStruct Starbreeze.SBZTrackedDamageData
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FSBZTrackedDamageData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZTrackedDamageData) == 0x000004, "Wrong alignment on FSBZTrackedDamageData");
static_assert(sizeof(FSBZTrackedDamageData) == 0x000008, "Wrong size on FSBZTrackedDamageData");

// ScriptStruct Starbreeze.SBZVotingMsgArgToLocalize
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FSBZVotingMsgArgToLocalize final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZVotingMsgArgToLocalize) == 0x000008, "Wrong alignment on FSBZVotingMsgArgToLocalize");
static_assert(sizeof(FSBZVotingMsgArgToLocalize) == 0x000030, "Wrong size on FSBZVotingMsgArgToLocalize");

// ScriptStruct Starbreeze.SBZAIVisibilityLeafNode
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FSBZAIVisibilityLeafNode final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAIVisibilityLeafNode) == 0x000004, "Wrong alignment on FSBZAIVisibilityLeafNode");
static_assert(sizeof(FSBZAIVisibilityLeafNode) == 0x000010, "Wrong size on FSBZAIVisibilityLeafNode");

// ScriptStruct Starbreeze.SBZInfamyRewardConfiguration
// 0x0010 (0x0010 - 0x0000)
struct FSBZInfamyRewardConfiguration final
{
public:
	TArray<struct FSBZRewardCategory>             RewardCategoryArray;                               // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZInfamyRewardConfiguration) == 0x000008, "Wrong alignment on FSBZInfamyRewardConfiguration");
static_assert(sizeof(FSBZInfamyRewardConfiguration) == 0x000010, "Wrong size on FSBZInfamyRewardConfiguration");
static_assert(offsetof(FSBZInfamyRewardConfiguration, RewardCategoryArray) == 0x000000, "Member 'FSBZInfamyRewardConfiguration::RewardCategoryArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZVisualDetectionValues
// 0x0030 (0x0030 - 0x0000)
struct FSBZVisualDetectionValues final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x28];                                       // 0x0008(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZVisualDetectionValues) == 0x000008, "Wrong alignment on FSBZVisualDetectionValues");
static_assert(sizeof(FSBZVisualDetectionValues) == 0x000030, "Wrong size on FSBZVisualDetectionValues");
static_assert(offsetof(FSBZVisualDetectionValues, Target) == 0x000000, "Member 'FSBZVisualDetectionValues::Target' has a wrong offset!");

// ScriptStruct Starbreeze.SBZOverrideConfigWeaponMaterials
// 0x0010 (0x0010 - 0x0000)
struct FSBZOverrideConfigWeaponMaterials final
{
public:
	TArray<class UMaterialInterface*>             WeaponMaterialPerMesh;                             // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZOverrideConfigWeaponMaterials) == 0x000008, "Wrong alignment on FSBZOverrideConfigWeaponMaterials");
static_assert(sizeof(FSBZOverrideConfigWeaponMaterials) == 0x000010, "Wrong size on FSBZOverrideConfigWeaponMaterials");
static_assert(offsetof(FSBZOverrideConfigWeaponMaterials, WeaponMaterialPerMesh) == 0x000000, "Member 'FSBZOverrideConfigWeaponMaterials::WeaponMaterialPerMesh' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeaponMaterialsPerMesh
// 0x0050 (0x0050 - 0x0000)
struct FSBZWeaponMaterialsPerMesh final
{
public:
	TMap<class USkeletalMesh*, struct FSBZOverrideConfigWeaponMaterials> WeaponMaterialPerMesh;      // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWeaponMaterialsPerMesh) == 0x000008, "Wrong alignment on FSBZWeaponMaterialsPerMesh");
static_assert(sizeof(FSBZWeaponMaterialsPerMesh) == 0x000050, "Wrong size on FSBZWeaponMaterialsPerMesh");
static_assert(offsetof(FSBZWeaponMaterialsPerMesh, WeaponMaterialPerMesh) == 0x000000, "Member 'FSBZWeaponMaterialsPerMesh::WeaponMaterialPerMesh' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeakpointHideInfo
// 0x0002 (0x0002 - 0x0000)
struct FSBZWeakpointHideInfo final
{
public:
	uint8                                         CPDIndex;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Bit;                                               // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWeakpointHideInfo) == 0x000001, "Wrong alignment on FSBZWeakpointHideInfo");
static_assert(sizeof(FSBZWeakpointHideInfo) == 0x000002, "Wrong size on FSBZWeakpointHideInfo");
static_assert(offsetof(FSBZWeakpointHideInfo, CPDIndex) == 0x000000, "Member 'FSBZWeakpointHideInfo::CPDIndex' has a wrong offset!");
static_assert(offsetof(FSBZWeakpointHideInfo, Bit) == 0x000001, "Member 'FSBZWeakpointHideInfo::Bit' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAmmoPickupLookup
// 0x0018 (0x0018 - 0x0000)
struct FSBZAmmoPickupLookup final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ASBZAmmoPickup*                         Actor;                                             // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASBZPlayerState*                        KillerPlayerState;                                 // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAmmoPickupLookup) == 0x000008, "Wrong alignment on FSBZAmmoPickupLookup");
static_assert(sizeof(FSBZAmmoPickupLookup) == 0x000018, "Wrong size on FSBZAmmoPickupLookup");
static_assert(offsetof(FSBZAmmoPickupLookup, Actor) == 0x000008, "Member 'FSBZAmmoPickupLookup::Actor' has a wrong offset!");
static_assert(offsetof(FSBZAmmoPickupLookup, KillerPlayerState) == 0x000010, "Member 'FSBZAmmoPickupLookup::KillerPlayerState' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCombinedBagType
// 0x0010 (0x0010 - 0x0000)
struct FSBZCombinedBagType final
{
public:
	class USBZBagType*                            InBagType;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZBagType*                            OutBagType;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZCombinedBagType) == 0x000008, "Wrong alignment on FSBZCombinedBagType");
static_assert(sizeof(FSBZCombinedBagType) == 0x000010, "Wrong size on FSBZCombinedBagType");
static_assert(offsetof(FSBZCombinedBagType, InBagType) == 0x000000, "Member 'FSBZCombinedBagType::InBagType' has a wrong offset!");
static_assert(offsetof(FSBZCombinedBagType, OutBagType) == 0x000008, "Member 'FSBZCombinedBagType::OutBagType' has a wrong offset!");

// ScriptStruct Starbreeze.SBZShotgunSpreadPattern
// 0x0010 (0x0010 - 0x0000)
struct FSBZShotgunSpreadPattern final
{
public:
	TArray<struct FVector2D>                      PelletSpreadAngles;                                // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZShotgunSpreadPattern) == 0x000008, "Wrong alignment on FSBZShotgunSpreadPattern");
static_assert(sizeof(FSBZShotgunSpreadPattern) == 0x000010, "Wrong size on FSBZShotgunSpreadPattern");
static_assert(offsetof(FSBZShotgunSpreadPattern, PelletSpreadAngles) == 0x000000, "Member 'FSBZShotgunSpreadPattern::PelletSpreadAngles' has a wrong offset!");

// ScriptStruct Starbreeze.SBZEntitlementTelemetryData
// 0x0050 (0x0050 - 0x0000)
struct FSBZEntitlementTelemetryData final
{
public:
	class FString                                 Id;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Sku;                                               // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemId;                                            // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAccelByteEntitlementSource                   Source;                                            // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              GrantedAt;                                         // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              CreatedAt;                                         // 0x0040(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              UpdatedAt;                                         // 0x0048(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZEntitlementTelemetryData) == 0x000008, "Wrong alignment on FSBZEntitlementTelemetryData");
static_assert(sizeof(FSBZEntitlementTelemetryData) == 0x000050, "Wrong size on FSBZEntitlementTelemetryData");
static_assert(offsetof(FSBZEntitlementTelemetryData, Id) == 0x000000, "Member 'FSBZEntitlementTelemetryData::Id' has a wrong offset!");
static_assert(offsetof(FSBZEntitlementTelemetryData, Sku) == 0x000010, "Member 'FSBZEntitlementTelemetryData::Sku' has a wrong offset!");
static_assert(offsetof(FSBZEntitlementTelemetryData, ItemId) == 0x000020, "Member 'FSBZEntitlementTelemetryData::ItemId' has a wrong offset!");
static_assert(offsetof(FSBZEntitlementTelemetryData, Source) == 0x000030, "Member 'FSBZEntitlementTelemetryData::Source' has a wrong offset!");
static_assert(offsetof(FSBZEntitlementTelemetryData, GrantedAt) == 0x000038, "Member 'FSBZEntitlementTelemetryData::GrantedAt' has a wrong offset!");
static_assert(offsetof(FSBZEntitlementTelemetryData, CreatedAt) == 0x000040, "Member 'FSBZEntitlementTelemetryData::CreatedAt' has a wrong offset!");
static_assert(offsetof(FSBZEntitlementTelemetryData, UpdatedAt) == 0x000048, "Member 'FSBZEntitlementTelemetryData::UpdatedAt' has a wrong offset!");

// ScriptStruct Starbreeze.SBZEntitlementsTelemetryPayload
// 0x0010 (0x0010 - 0x0000)
struct FSBZEntitlementsTelemetryPayload final
{
public:
	TArray<struct FSBZEntitlementTelemetryData>   Items;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZEntitlementsTelemetryPayload) == 0x000008, "Wrong alignment on FSBZEntitlementsTelemetryPayload");
static_assert(sizeof(FSBZEntitlementsTelemetryPayload) == 0x000010, "Wrong size on FSBZEntitlementsTelemetryPayload");
static_assert(offsetof(FSBZEntitlementsTelemetryPayload, Items) == 0x000000, "Member 'FSBZEntitlementsTelemetryPayload::Items' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPivotSwitchHandler
// 0x001C (0x001C - 0x0000)
struct FSBZPivotSwitchHandler final
{
public:
	bool                                          bActive;                                           // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Angle;                                             // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimOffsetAngle;                                    // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurValue;                                          // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0xC];                                       // 0x0010(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZPivotSwitchHandler) == 0x000004, "Wrong alignment on FSBZPivotSwitchHandler");
static_assert(sizeof(FSBZPivotSwitchHandler) == 0x00001C, "Wrong size on FSBZPivotSwitchHandler");
static_assert(offsetof(FSBZPivotSwitchHandler, bActive) == 0x000000, "Member 'FSBZPivotSwitchHandler::bActive' has a wrong offset!");
static_assert(offsetof(FSBZPivotSwitchHandler, Angle) == 0x000004, "Member 'FSBZPivotSwitchHandler::Angle' has a wrong offset!");
static_assert(offsetof(FSBZPivotSwitchHandler, AimOffsetAngle) == 0x000008, "Member 'FSBZPivotSwitchHandler::AimOffsetAngle' has a wrong offset!");
static_assert(offsetof(FSBZPivotSwitchHandler, CurValue) == 0x00000C, "Member 'FSBZPivotSwitchHandler::CurValue' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeaponGunKickBackData
// 0x0120 (0x0120 - 0x0000)
struct FSBZWeaponGunKickBackData
{
public:
	float                                         SpeedDeflect;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedRecover;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     DeflectCurve;                                      // 0x0008(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     RecoverCurve;                                      // 0x0090(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0118(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x011C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWeaponGunKickBackData) == 0x000008, "Wrong alignment on FSBZWeaponGunKickBackData");
static_assert(sizeof(FSBZWeaponGunKickBackData) == 0x000120, "Wrong size on FSBZWeaponGunKickBackData");
static_assert(offsetof(FSBZWeaponGunKickBackData, SpeedDeflect) == 0x000000, "Member 'FSBZWeaponGunKickBackData::SpeedDeflect' has a wrong offset!");
static_assert(offsetof(FSBZWeaponGunKickBackData, SpeedRecover) == 0x000004, "Member 'FSBZWeaponGunKickBackData::SpeedRecover' has a wrong offset!");
static_assert(offsetof(FSBZWeaponGunKickBackData, DeflectCurve) == 0x000008, "Member 'FSBZWeaponGunKickBackData::DeflectCurve' has a wrong offset!");
static_assert(offsetof(FSBZWeaponGunKickBackData, RecoverCurve) == 0x000090, "Member 'FSBZWeaponGunKickBackData::RecoverCurve' has a wrong offset!");
static_assert(offsetof(FSBZWeaponGunKickBackData, Distance) == 0x000118, "Member 'FSBZWeaponGunKickBackData::Distance' has a wrong offset!");
static_assert(offsetof(FSBZWeaponGunKickBackData, MaxDistance) == 0x00011C, "Member 'FSBZWeaponGunKickBackData::MaxDistance' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAnimatedInteractionTagPerDuration
// 0x0014 (0x0014 - 0x0000)
struct FSBZAnimatedInteractionTagPerDuration final
{
public:
	struct FGameplayTag                           AnimationTag;                                      // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         DurationInterval;                                  // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAnimatedInteractionTagPerDuration) == 0x000004, "Wrong alignment on FSBZAnimatedInteractionTagPerDuration");
static_assert(sizeof(FSBZAnimatedInteractionTagPerDuration) == 0x000014, "Wrong size on FSBZAnimatedInteractionTagPerDuration");
static_assert(offsetof(FSBZAnimatedInteractionTagPerDuration, AnimationTag) == 0x000000, "Member 'FSBZAnimatedInteractionTagPerDuration::AnimationTag' has a wrong offset!");
static_assert(offsetof(FSBZAnimatedInteractionTagPerDuration, DurationInterval) == 0x00000C, "Member 'FSBZAnimatedInteractionTagPerDuration::DurationInterval' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAnimationSpawnedActorCPD
// 0x0008 (0x0008 - 0x0000)
struct FSBZAnimationSpawnedActorCPD final
{
public:
	int32                                         CPDIndex;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CPDValue;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAnimationSpawnedActorCPD) == 0x000004, "Wrong alignment on FSBZAnimationSpawnedActorCPD");
static_assert(sizeof(FSBZAnimationSpawnedActorCPD) == 0x000008, "Wrong size on FSBZAnimationSpawnedActorCPD");
static_assert(offsetof(FSBZAnimationSpawnedActorCPD, CPDIndex) == 0x000000, "Member 'FSBZAnimationSpawnedActorCPD::CPDIndex' has a wrong offset!");
static_assert(offsetof(FSBZAnimationSpawnedActorCPD, CPDValue) == 0x000004, "Member 'FSBZAnimationSpawnedActorCPD::CPDValue' has a wrong offset!");

// ScriptStruct Starbreeze.SBZDelegateHandle
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FSBZDelegateHandle final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZDelegateHandle) == 0x000008, "Wrong alignment on FSBZDelegateHandle");
static_assert(sizeof(FSBZDelegateHandle) == 0x000008, "Wrong size on FSBZDelegateHandle");

// ScriptStruct Starbreeze.SBZWeaponModificationUIData
// 0x0018 (0x0018 - 0x0000)
struct FSBZWeaponModificationUIData final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWeaponModificationUIData) == 0x000008, "Wrong alignment on FSBZWeaponModificationUIData");
static_assert(sizeof(FSBZWeaponModificationUIData) == 0x000018, "Wrong size on FSBZWeaponModificationUIData");
static_assert(offsetof(FSBZWeaponModificationUIData, DisplayName) == 0x000000, "Member 'FSBZWeaponModificationUIData::DisplayName' has a wrong offset!");

// ScriptStruct Starbreeze.SBZEquippablePartUIData
// 0x0020 (0x0020 - 0x0000)
struct FSBZEquippablePartUIData final
{
public:
	TArray<struct FSBZWeaponModificationUIData>   PositiveModifications;                             // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSBZWeaponModificationUIData>   NegativeModifications;                             // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZEquippablePartUIData) == 0x000008, "Wrong alignment on FSBZEquippablePartUIData");
static_assert(sizeof(FSBZEquippablePartUIData) == 0x000020, "Wrong size on FSBZEquippablePartUIData");
static_assert(offsetof(FSBZEquippablePartUIData, PositiveModifications) == 0x000000, "Member 'FSBZEquippablePartUIData::PositiveModifications' has a wrong offset!");
static_assert(offsetof(FSBZEquippablePartUIData, NegativeModifications) == 0x000010, "Member 'FSBZEquippablePartUIData::NegativeModifications' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAnimNode_ApplyAdditiveLayeredOneBone
// 0x00E0 (0x0100 - 0x0020)
struct FSBZAnimNode_ApplyAdditiveLayeredOneBone final : public FAnimNode_Base
{
public:
	struct FPoseLink                              Base;                                              // 0x0020(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPoseLink                              Additive;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlphaLayerOne;                                     // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlphaOthers;                                       // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LayerOneBoneName;                                  // 0x004C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputScaleBias                        AlphaScaleBias;                                    // 0x0058(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         LODThreshold;                                      // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LODInterpolateTime;                                // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LODInterpolateTimer;                               // 0x0068(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInputAlphaBoolBlend                   AlphaBoolBlend;                                    // 0x0070(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   AlphaCurveName;                                    // 0x00B8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputScaleBiasClamp                   AlphaScaleBiasClamp;                               // 0x00C4(0x0030)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	EAnimAlphaInputType                           AlphaInputType;                                    // 0x00F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlphaBoolEnabled;                                 // 0x00F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAdditiveAnimationType                        Space;                                             // 0x00FA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FB[0x5];                                       // 0x00FB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAnimNode_ApplyAdditiveLayeredOneBone) == 0x000008, "Wrong alignment on FSBZAnimNode_ApplyAdditiveLayeredOneBone");
static_assert(sizeof(FSBZAnimNode_ApplyAdditiveLayeredOneBone) == 0x000100, "Wrong size on FSBZAnimNode_ApplyAdditiveLayeredOneBone");
static_assert(offsetof(FSBZAnimNode_ApplyAdditiveLayeredOneBone, Base) == 0x000020, "Member 'FSBZAnimNode_ApplyAdditiveLayeredOneBone::Base' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ApplyAdditiveLayeredOneBone, Additive) == 0x000030, "Member 'FSBZAnimNode_ApplyAdditiveLayeredOneBone::Additive' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ApplyAdditiveLayeredOneBone, Alpha) == 0x000040, "Member 'FSBZAnimNode_ApplyAdditiveLayeredOneBone::Alpha' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ApplyAdditiveLayeredOneBone, AlphaLayerOne) == 0x000044, "Member 'FSBZAnimNode_ApplyAdditiveLayeredOneBone::AlphaLayerOne' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ApplyAdditiveLayeredOneBone, AlphaOthers) == 0x000048, "Member 'FSBZAnimNode_ApplyAdditiveLayeredOneBone::AlphaOthers' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ApplyAdditiveLayeredOneBone, LayerOneBoneName) == 0x00004C, "Member 'FSBZAnimNode_ApplyAdditiveLayeredOneBone::LayerOneBoneName' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ApplyAdditiveLayeredOneBone, AlphaScaleBias) == 0x000058, "Member 'FSBZAnimNode_ApplyAdditiveLayeredOneBone::AlphaScaleBias' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ApplyAdditiveLayeredOneBone, LODThreshold) == 0x000060, "Member 'FSBZAnimNode_ApplyAdditiveLayeredOneBone::LODThreshold' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ApplyAdditiveLayeredOneBone, LODInterpolateTime) == 0x000064, "Member 'FSBZAnimNode_ApplyAdditiveLayeredOneBone::LODInterpolateTime' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ApplyAdditiveLayeredOneBone, LODInterpolateTimer) == 0x000068, "Member 'FSBZAnimNode_ApplyAdditiveLayeredOneBone::LODInterpolateTimer' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ApplyAdditiveLayeredOneBone, AlphaBoolBlend) == 0x000070, "Member 'FSBZAnimNode_ApplyAdditiveLayeredOneBone::AlphaBoolBlend' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ApplyAdditiveLayeredOneBone, AlphaCurveName) == 0x0000B8, "Member 'FSBZAnimNode_ApplyAdditiveLayeredOneBone::AlphaCurveName' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ApplyAdditiveLayeredOneBone, AlphaScaleBiasClamp) == 0x0000C4, "Member 'FSBZAnimNode_ApplyAdditiveLayeredOneBone::AlphaScaleBiasClamp' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ApplyAdditiveLayeredOneBone, AlphaInputType) == 0x0000F8, "Member 'FSBZAnimNode_ApplyAdditiveLayeredOneBone::AlphaInputType' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ApplyAdditiveLayeredOneBone, bAlphaBoolEnabled) == 0x0000F9, "Member 'FSBZAnimNode_ApplyAdditiveLayeredOneBone::bAlphaBoolEnabled' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ApplyAdditiveLayeredOneBone, Space) == 0x0000FA, "Member 'FSBZAnimNode_ApplyAdditiveLayeredOneBone::Space' has a wrong offset!");

// ScriptStruct Starbreeze.SBZNewsPlatformLink
// 0x0018 (0x0018 - 0x0000)
struct FSBZNewsPlatformLink final
{
public:
	ESBZFirstPartyPlatform                        FirstPartyPlatform;                                // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Link;                                              // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZNewsPlatformLink) == 0x000008, "Wrong alignment on FSBZNewsPlatformLink");
static_assert(sizeof(FSBZNewsPlatformLink) == 0x000018, "Wrong size on FSBZNewsPlatformLink");
static_assert(offsetof(FSBZNewsPlatformLink, FirstPartyPlatform) == 0x000000, "Member 'FSBZNewsPlatformLink::FirstPartyPlatform' has a wrong offset!");
static_assert(offsetof(FSBZNewsPlatformLink, Link) == 0x000008, "Member 'FSBZNewsPlatformLink::Link' has a wrong offset!");

// ScriptStruct Starbreeze.SBZNewsFeedEntry
// 0x0090 (0x0090 - 0x0000)
struct FSBZNewsFeedEntry final
{
public:
	class FString                                 NewsId;                                            // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DefaultLink;                                       // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSBZNewsPlatformLink>           NewsPlatformLinkArray;                             // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            ParameterValues;                                   // 0x0030(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 EventId;                                           // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZNewsFeedEntry) == 0x000008, "Wrong alignment on FSBZNewsFeedEntry");
static_assert(sizeof(FSBZNewsFeedEntry) == 0x000090, "Wrong size on FSBZNewsFeedEntry");
static_assert(offsetof(FSBZNewsFeedEntry, NewsId) == 0x000000, "Member 'FSBZNewsFeedEntry::NewsId' has a wrong offset!");
static_assert(offsetof(FSBZNewsFeedEntry, DefaultLink) == 0x000010, "Member 'FSBZNewsFeedEntry::DefaultLink' has a wrong offset!");
static_assert(offsetof(FSBZNewsFeedEntry, NewsPlatformLinkArray) == 0x000020, "Member 'FSBZNewsFeedEntry::NewsPlatformLinkArray' has a wrong offset!");
static_assert(offsetof(FSBZNewsFeedEntry, ParameterValues) == 0x000030, "Member 'FSBZNewsFeedEntry::ParameterValues' has a wrong offset!");
static_assert(offsetof(FSBZNewsFeedEntry, EventId) == 0x000080, "Member 'FSBZNewsFeedEntry::EventId' has a wrong offset!");

// ScriptStruct Starbreeze.SBZNewsFeedList
// 0x0010 (0x0010 - 0x0000)
struct FSBZNewsFeedList final
{
public:
	TArray<struct FSBZNewsFeedEntry>              NewsList;                                          // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZNewsFeedList) == 0x000008, "Wrong alignment on FSBZNewsFeedList");
static_assert(sizeof(FSBZNewsFeedList) == 0x000010, "Wrong size on FSBZNewsFeedList");
static_assert(offsetof(FSBZNewsFeedList, NewsList) == 0x000000, "Member 'FSBZNewsFeedList::NewsList' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAnimNode_ApplyBoneOffsetFromPose
// 0x0048 (0x0068 - 0x0020)
struct FSBZAnimNode_ApplyBoneOffsetFromPose final : public FAnimNode_Base
{
public:
	struct FPoseLink                              BasePose;                                          // 0x0020(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPoseLink                              RefPose;                                           // 0x0030(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         Bone;                                              // 0x0040(0x0014)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FBoneReference                         RefBone;                                           // 0x0054(0x0014)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FSBZAnimNode_ApplyBoneOffsetFromPose) == 0x000008, "Wrong alignment on FSBZAnimNode_ApplyBoneOffsetFromPose");
static_assert(sizeof(FSBZAnimNode_ApplyBoneOffsetFromPose) == 0x000068, "Wrong size on FSBZAnimNode_ApplyBoneOffsetFromPose");
static_assert(offsetof(FSBZAnimNode_ApplyBoneOffsetFromPose, BasePose) == 0x000020, "Member 'FSBZAnimNode_ApplyBoneOffsetFromPose::BasePose' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ApplyBoneOffsetFromPose, RefPose) == 0x000030, "Member 'FSBZAnimNode_ApplyBoneOffsetFromPose::RefPose' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ApplyBoneOffsetFromPose, Bone) == 0x000040, "Member 'FSBZAnimNode_ApplyBoneOffsetFromPose::Bone' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ApplyBoneOffsetFromPose, RefBone) == 0x000054, "Member 'FSBZAnimNode_ApplyBoneOffsetFromPose::RefBone' has a wrong offset!");

// ScriptStruct Starbreeze.SBZBoneRefArrayParam
// 0x0010 (0x0010 - 0x0000)
struct FSBZBoneRefArrayParam final
{
public:
	TArray<struct FBoneReference>                 BoneRefArray;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZBoneRefArrayParam) == 0x000008, "Wrong alignment on FSBZBoneRefArrayParam");
static_assert(sizeof(FSBZBoneRefArrayParam) == 0x000010, "Wrong size on FSBZBoneRefArrayParam");
static_assert(offsetof(FSBZBoneRefArrayParam, BoneRefArray) == 0x000000, "Member 'FSBZBoneRefArrayParam::BoneRefArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAnimNode_BoneKeepRefPose
// 0x0020 (0x0108 - 0x00E8)
struct FSBZAnimNode_BoneKeepRefPose final : public FAnimNode_SkeletalControlBase
{
public:
	struct FSBZBoneRefArrayParam                  BonesToConstrain;                                  // 0x00E8(0x0010)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x10];                                      // 0x00F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAnimNode_BoneKeepRefPose) == 0x000008, "Wrong alignment on FSBZAnimNode_BoneKeepRefPose");
static_assert(sizeof(FSBZAnimNode_BoneKeepRefPose) == 0x000108, "Wrong size on FSBZAnimNode_BoneKeepRefPose");
static_assert(offsetof(FSBZAnimNode_BoneKeepRefPose, BonesToConstrain) == 0x0000E8, "Member 'FSBZAnimNode_BoneKeepRefPose::BonesToConstrain' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMaskOfTheWeekBlock
// 0x0020 (0x0020 - 0x0000)
struct FSBZMaskOfTheWeekBlock final
{
public:
	TArray<class FString>                         MaskOfTheWeekSkuArray;                             // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDateTime                              StartDate;                                         // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              StopDate;                                          // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZMaskOfTheWeekBlock) == 0x000008, "Wrong alignment on FSBZMaskOfTheWeekBlock");
static_assert(sizeof(FSBZMaskOfTheWeekBlock) == 0x000020, "Wrong size on FSBZMaskOfTheWeekBlock");
static_assert(offsetof(FSBZMaskOfTheWeekBlock, MaskOfTheWeekSkuArray) == 0x000000, "Member 'FSBZMaskOfTheWeekBlock::MaskOfTheWeekSkuArray' has a wrong offset!");
static_assert(offsetof(FSBZMaskOfTheWeekBlock, StartDate) == 0x000010, "Member 'FSBZMaskOfTheWeekBlock::StartDate' has a wrong offset!");
static_assert(offsetof(FSBZMaskOfTheWeekBlock, StopDate) == 0x000018, "Member 'FSBZMaskOfTheWeekBlock::StopDate' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMaskOfTheWeek
// 0x0010 (0x0010 - 0x0000)
struct FSBZMaskOfTheWeek final
{
public:
	TArray<struct FSBZMaskOfTheWeekBlock>         MaskOfTheWeekBlockArray;                           // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZMaskOfTheWeek) == 0x000008, "Wrong alignment on FSBZMaskOfTheWeek");
static_assert(sizeof(FSBZMaskOfTheWeek) == 0x000010, "Wrong size on FSBZMaskOfTheWeek");
static_assert(offsetof(FSBZMaskOfTheWeek, MaskOfTheWeekBlockArray) == 0x000000, "Member 'FSBZMaskOfTheWeek::MaskOfTheWeekBlockArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZTimeBasedPlayerContent
// 0x0010 (0x0010 - 0x0000)
struct FSBZTimeBasedPlayerContent final
{
public:
	struct FSBZMaskOfTheWeek                      MaskOfTheWeek;                                     // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZTimeBasedPlayerContent) == 0x000008, "Wrong alignment on FSBZTimeBasedPlayerContent");
static_assert(sizeof(FSBZTimeBasedPlayerContent) == 0x000010, "Wrong size on FSBZTimeBasedPlayerContent");
static_assert(offsetof(FSBZTimeBasedPlayerContent, MaskOfTheWeek) == 0x000000, "Member 'FSBZTimeBasedPlayerContent::MaskOfTheWeek' has a wrong offset!");

// ScriptStruct Starbreeze.SBZVehicleReplicatedMovementBase
// 0x0040 (0x0040 - 0x0000)
#pragma pack(push, 0x1)
struct alignas(0x10) FSBZVehicleReplicatedMovementBase
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize10                  Location;                                          // 0x0010(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rotation;                                          // 0x0020(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ServerTimestamp;                                   // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PredictionCorrectionTimer;                         // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
#pragma pack(pop)
static_assert(alignof(FSBZVehicleReplicatedMovementBase) == 0x000010, "Wrong alignment on FSBZVehicleReplicatedMovementBase");
static_assert(sizeof(FSBZVehicleReplicatedMovementBase) == 0x000040, "Wrong size on FSBZVehicleReplicatedMovementBase");
static_assert(offsetof(FSBZVehicleReplicatedMovementBase, Location) == 0x000010, "Member 'FSBZVehicleReplicatedMovementBase::Location' has a wrong offset!");
static_assert(offsetof(FSBZVehicleReplicatedMovementBase, Rotation) == 0x000020, "Member 'FSBZVehicleReplicatedMovementBase::Rotation' has a wrong offset!");
static_assert(offsetof(FSBZVehicleReplicatedMovementBase, ServerTimestamp) == 0x000030, "Member 'FSBZVehicleReplicatedMovementBase::ServerTimestamp' has a wrong offset!");
static_assert(offsetof(FSBZVehicleReplicatedMovementBase, PredictionCorrectionTimer) == 0x000034, "Member 'FSBZVehicleReplicatedMovementBase::PredictionCorrectionTimer' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWheeledVehicleReplicatedMovement
// 0x0000 (0x0040 - 0x0040)
struct FSBZWheeledVehicleReplicatedMovement final : public FSBZVehicleReplicatedMovementBase
{
public:
	int8                                          Steering;                                          // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZWheeledVehicleReplicatedMovement) == 0x000010, "Wrong alignment on FSBZWheeledVehicleReplicatedMovement");
static_assert(sizeof(FSBZWheeledVehicleReplicatedMovement) == 0x000040, "Wrong size on FSBZWheeledVehicleReplicatedMovement");
static_assert(offsetof(FSBZWheeledVehicleReplicatedMovement, Steering) == 0x000038, "Member 'FSBZWheeledVehicleReplicatedMovement::Steering' has a wrong offset!");

// ScriptStruct Starbreeze.SBZRefPoseConstraint
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x10) FSBZRefPoseConstraint final
{
public:
	struct FBoneReference                         TargetBone;                                        // 0x0000(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x3C];                                      // 0x0014(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZRefPoseConstraint) == 0x000010, "Wrong alignment on FSBZRefPoseConstraint");
static_assert(sizeof(FSBZRefPoseConstraint) == 0x000050, "Wrong size on FSBZRefPoseConstraint");
static_assert(offsetof(FSBZRefPoseConstraint, TargetBone) == 0x000000, "Member 'FSBZRefPoseConstraint::TargetBone' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCharacterEffectRuntime
// 0x0028 (0x0028 - 0x0000)
struct FSBZCharacterEffectRuntime final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USBZCharacterEffectDataAsset*           CharacterEffectData;                               // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentProgress;                                   // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterEffectValue;                              // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownAnimationTime;                             // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownTimer;                                     // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHidesWhenActive;                                  // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAutoRemove;                                     // 0x0021(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZCharacterEffectRuntime) == 0x000008, "Wrong alignment on FSBZCharacterEffectRuntime");
static_assert(sizeof(FSBZCharacterEffectRuntime) == 0x000028, "Wrong size on FSBZCharacterEffectRuntime");
static_assert(offsetof(FSBZCharacterEffectRuntime, CharacterEffectData) == 0x000008, "Member 'FSBZCharacterEffectRuntime::CharacterEffectData' has a wrong offset!");
static_assert(offsetof(FSBZCharacterEffectRuntime, CurrentProgress) == 0x000010, "Member 'FSBZCharacterEffectRuntime::CurrentProgress' has a wrong offset!");
static_assert(offsetof(FSBZCharacterEffectRuntime, CharacterEffectValue) == 0x000014, "Member 'FSBZCharacterEffectRuntime::CharacterEffectValue' has a wrong offset!");
static_assert(offsetof(FSBZCharacterEffectRuntime, CooldownAnimationTime) == 0x000018, "Member 'FSBZCharacterEffectRuntime::CooldownAnimationTime' has a wrong offset!");
static_assert(offsetof(FSBZCharacterEffectRuntime, CooldownTimer) == 0x00001C, "Member 'FSBZCharacterEffectRuntime::CooldownTimer' has a wrong offset!");
static_assert(offsetof(FSBZCharacterEffectRuntime, bHidesWhenActive) == 0x000020, "Member 'FSBZCharacterEffectRuntime::bHidesWhenActive' has a wrong offset!");
static_assert(offsetof(FSBZCharacterEffectRuntime, bIsAutoRemove) == 0x000021, "Member 'FSBZCharacterEffectRuntime::bIsAutoRemove' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAnimNode_BoneLocker
// 0x0018 (0x0100 - 0x00E8)
struct FSBZAnimNode_BoneLocker final : public FAnimNode_SkeletalControlBase
{
public:
	TArray<struct FSBZBoneLocker>                 BoneLockers;                                       // 0x00E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bComponentSpace;                                   // 0x00F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAnimNode_BoneLocker) == 0x000008, "Wrong alignment on FSBZAnimNode_BoneLocker");
static_assert(sizeof(FSBZAnimNode_BoneLocker) == 0x000100, "Wrong size on FSBZAnimNode_BoneLocker");
static_assert(offsetof(FSBZAnimNode_BoneLocker, BoneLockers) == 0x0000E8, "Member 'FSBZAnimNode_BoneLocker::BoneLockers' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_BoneLocker, bComponentSpace) == 0x0000F8, "Member 'FSBZAnimNode_BoneLocker::bComponentSpace' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeaponSpreadStanceMultipliers
// 0x0020 (0x0020 - 0x0000)
struct FSBZWeaponSpreadStanceMultipliers final
{
public:
	float                                         Spread;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TasedSpread;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Start;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinCap;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cap;                                               // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Increment;                                         // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResetTime;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecayRate;                                         // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWeaponSpreadStanceMultipliers) == 0x000004, "Wrong alignment on FSBZWeaponSpreadStanceMultipliers");
static_assert(sizeof(FSBZWeaponSpreadStanceMultipliers) == 0x000020, "Wrong size on FSBZWeaponSpreadStanceMultipliers");
static_assert(offsetof(FSBZWeaponSpreadStanceMultipliers, Spread) == 0x000000, "Member 'FSBZWeaponSpreadStanceMultipliers::Spread' has a wrong offset!");
static_assert(offsetof(FSBZWeaponSpreadStanceMultipliers, TasedSpread) == 0x000004, "Member 'FSBZWeaponSpreadStanceMultipliers::TasedSpread' has a wrong offset!");
static_assert(offsetof(FSBZWeaponSpreadStanceMultipliers, Start) == 0x000008, "Member 'FSBZWeaponSpreadStanceMultipliers::Start' has a wrong offset!");
static_assert(offsetof(FSBZWeaponSpreadStanceMultipliers, MinCap) == 0x00000C, "Member 'FSBZWeaponSpreadStanceMultipliers::MinCap' has a wrong offset!");
static_assert(offsetof(FSBZWeaponSpreadStanceMultipliers, Cap) == 0x000010, "Member 'FSBZWeaponSpreadStanceMultipliers::Cap' has a wrong offset!");
static_assert(offsetof(FSBZWeaponSpreadStanceMultipliers, Increment) == 0x000014, "Member 'FSBZWeaponSpreadStanceMultipliers::Increment' has a wrong offset!");
static_assert(offsetof(FSBZWeaponSpreadStanceMultipliers, ResetTime) == 0x000018, "Member 'FSBZWeaponSpreadStanceMultipliers::ResetTime' has a wrong offset!");
static_assert(offsetof(FSBZWeaponSpreadStanceMultipliers, DecayRate) == 0x00001C, "Member 'FSBZWeaponSpreadStanceMultipliers::DecayRate' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAnimNode_BuiltInAnimMontagePlayer
// 0x0018 (0x0100 - 0x00E8)
struct FSBZAnimNode_BuiltInAnimMontagePlayer final : public FAnimNode_SkeletalControlBase
{
public:
	TArray<struct FBoneReference>                 BonesToModify;                                     // 0x00E8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class USBZBuiltInAnimMontagesHandler*         AnimMontagesHandler;                               // 0x00F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAnimNode_BuiltInAnimMontagePlayer) == 0x000008, "Wrong alignment on FSBZAnimNode_BuiltInAnimMontagePlayer");
static_assert(sizeof(FSBZAnimNode_BuiltInAnimMontagePlayer) == 0x000100, "Wrong size on FSBZAnimNode_BuiltInAnimMontagePlayer");
static_assert(offsetof(FSBZAnimNode_BuiltInAnimMontagePlayer, BonesToModify) == 0x0000E8, "Member 'FSBZAnimNode_BuiltInAnimMontagePlayer::BonesToModify' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_BuiltInAnimMontagePlayer, AnimMontagesHandler) == 0x0000F8, "Member 'FSBZAnimNode_BuiltInAnimMontagePlayer::AnimMontagesHandler' has a wrong offset!");

// ScriptStruct Starbreeze.SBZQuat_NetQuantizeNormal
// 0x0000 (0x0010 - 0x0010)
struct FSBZQuat_NetQuantizeNormal final : public FQuat
{
};
static_assert(alignof(FSBZQuat_NetQuantizeNormal) == 0x000010, "Wrong alignment on FSBZQuat_NetQuantizeNormal");
static_assert(sizeof(FSBZQuat_NetQuantizeNormal) == 0x000010, "Wrong size on FSBZQuat_NetQuantizeNormal");

// ScriptStruct Starbreeze.SBZAnimNode_ChangeChamberAnimatedBullet
// 0x0158 (0x0240 - 0x00E8)
struct alignas(0x10) FSBZAnimNode_ChangeChamberAnimatedBullet final : public FAnimNode_SkeletalControlBase
{
public:
	class FName                                   BoneToAnimateName;                                 // 0x00E8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AnimatedBoneName;                                  // 0x00F4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_100[0x140];                                    // 0x0100(0x0140)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAnimNode_ChangeChamberAnimatedBullet) == 0x000010, "Wrong alignment on FSBZAnimNode_ChangeChamberAnimatedBullet");
static_assert(sizeof(FSBZAnimNode_ChangeChamberAnimatedBullet) == 0x000240, "Wrong size on FSBZAnimNode_ChangeChamberAnimatedBullet");
static_assert(offsetof(FSBZAnimNode_ChangeChamberAnimatedBullet, BoneToAnimateName) == 0x0000E8, "Member 'FSBZAnimNode_ChangeChamberAnimatedBullet::BoneToAnimateName' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_ChangeChamberAnimatedBullet, AnimatedBoneName) == 0x0000F4, "Member 'FSBZAnimNode_ChangeChamberAnimatedBullet::AnimatedBoneName' has a wrong offset!");

// ScriptStruct Starbreeze.SBZBonusExpMapEntry
// 0x0018 (0x0018 - 0x0000)
struct FSBZBonusExpMapEntry final
{
public:
	class FString                                 PerformanceObjective;                              // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GainedExp;                                         // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZBonusExpMapEntry) == 0x000008, "Wrong alignment on FSBZBonusExpMapEntry");
static_assert(sizeof(FSBZBonusExpMapEntry) == 0x000018, "Wrong size on FSBZBonusExpMapEntry");
static_assert(offsetof(FSBZBonusExpMapEntry, PerformanceObjective) == 0x000000, "Member 'FSBZBonusExpMapEntry::PerformanceObjective' has a wrong offset!");
static_assert(offsetof(FSBZBonusExpMapEntry, GainedExp) == 0x000010, "Member 'FSBZBonusExpMapEntry::GainedExp' has a wrong offset!");

// ScriptStruct Starbreeze.SBZBoneRefParam
// 0x0014 (0x0014 - 0x0000)
struct FSBZBoneRefParam final
{
public:
	struct FBoneReference                         BoneRef;                                           // 0x0000(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZBoneRefParam) == 0x000004, "Wrong alignment on FSBZBoneRefParam");
static_assert(sizeof(FSBZBoneRefParam) == 0x000014, "Wrong size on FSBZBoneRefParam");
static_assert(offsetof(FSBZBoneRefParam, BoneRef) == 0x000000, "Member 'FSBZBoneRefParam::BoneRef' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAnimNode_CopyBoneDeltaMultiTargets
// 0x0038 (0x0120 - 0x00E8)
struct FSBZAnimNode_CopyBoneDeltaMultiTargets final : public FAnimNode_SkeletalControlBase
{
public:
	struct FSBZBoneRefParam                       SourceBone;                                        // 0x00E8(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSBZBoneRefArrayParam                  TargetBones;                                       // 0x0100(0x0010)(Edit, NativeAccessSpecifierPublic)
	bool                                          bCopyTranslation;                                  // 0x0110(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCopyRotation;                                     // 0x0111(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCopyScale;                                        // 0x0112(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECopyBoneDeltaMode                            CopyMode;                                          // 0x0113(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TranslationMultiplier;                             // 0x0114(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationMultiplier;                                // 0x0118(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleMultiplier;                                   // 0x011C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAnimNode_CopyBoneDeltaMultiTargets) == 0x000008, "Wrong alignment on FSBZAnimNode_CopyBoneDeltaMultiTargets");
static_assert(sizeof(FSBZAnimNode_CopyBoneDeltaMultiTargets) == 0x000120, "Wrong size on FSBZAnimNode_CopyBoneDeltaMultiTargets");
static_assert(offsetof(FSBZAnimNode_CopyBoneDeltaMultiTargets, SourceBone) == 0x0000E8, "Member 'FSBZAnimNode_CopyBoneDeltaMultiTargets::SourceBone' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_CopyBoneDeltaMultiTargets, TargetBones) == 0x000100, "Member 'FSBZAnimNode_CopyBoneDeltaMultiTargets::TargetBones' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_CopyBoneDeltaMultiTargets, bCopyTranslation) == 0x000110, "Member 'FSBZAnimNode_CopyBoneDeltaMultiTargets::bCopyTranslation' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_CopyBoneDeltaMultiTargets, bCopyRotation) == 0x000111, "Member 'FSBZAnimNode_CopyBoneDeltaMultiTargets::bCopyRotation' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_CopyBoneDeltaMultiTargets, bCopyScale) == 0x000112, "Member 'FSBZAnimNode_CopyBoneDeltaMultiTargets::bCopyScale' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_CopyBoneDeltaMultiTargets, CopyMode) == 0x000113, "Member 'FSBZAnimNode_CopyBoneDeltaMultiTargets::CopyMode' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_CopyBoneDeltaMultiTargets, TranslationMultiplier) == 0x000114, "Member 'FSBZAnimNode_CopyBoneDeltaMultiTargets::TranslationMultiplier' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_CopyBoneDeltaMultiTargets, RotationMultiplier) == 0x000118, "Member 'FSBZAnimNode_CopyBoneDeltaMultiTargets::RotationMultiplier' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_CopyBoneDeltaMultiTargets, ScaleMultiplier) == 0x00011C, "Member 'FSBZAnimNode_CopyBoneDeltaMultiTargets::ScaleMultiplier' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAnimNode_CurveMatchedBlendSpacePlayer
// 0x00D0 (0x0118 - 0x0048)
struct FSBZAnimNode_CurveMatchedBlendSpacePlayer final : public FAnimNode_AssetPlayerBase
{
public:
	float                                         X;                                                 // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpaceBase*                        BlendSpace;                                        // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CurveName;                                         // 0x0060(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurveTarget;                                       // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlendFilter                           BlendFilter;                                       // 0x0078(0x0078)(Protected, NativeAccessSpecifierProtected)
	TArray<struct FBlendSampleData>               BlendSampleDataCache;                              // 0x00F0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UBlendSpaceBase*                        PreviousBlendSpace;                                // 0x0100(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_108[0x10];                                     // 0x0108(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAnimNode_CurveMatchedBlendSpacePlayer) == 0x000008, "Wrong alignment on FSBZAnimNode_CurveMatchedBlendSpacePlayer");
static_assert(sizeof(FSBZAnimNode_CurveMatchedBlendSpacePlayer) == 0x000118, "Wrong size on FSBZAnimNode_CurveMatchedBlendSpacePlayer");
static_assert(offsetof(FSBZAnimNode_CurveMatchedBlendSpacePlayer, X) == 0x000048, "Member 'FSBZAnimNode_CurveMatchedBlendSpacePlayer::X' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_CurveMatchedBlendSpacePlayer, Y) == 0x00004C, "Member 'FSBZAnimNode_CurveMatchedBlendSpacePlayer::Y' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_CurveMatchedBlendSpacePlayer, Z) == 0x000050, "Member 'FSBZAnimNode_CurveMatchedBlendSpacePlayer::Z' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_CurveMatchedBlendSpacePlayer, BlendSpace) == 0x000058, "Member 'FSBZAnimNode_CurveMatchedBlendSpacePlayer::BlendSpace' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_CurveMatchedBlendSpacePlayer, CurveName) == 0x000060, "Member 'FSBZAnimNode_CurveMatchedBlendSpacePlayer::CurveName' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_CurveMatchedBlendSpacePlayer, CurveTarget) == 0x00006C, "Member 'FSBZAnimNode_CurveMatchedBlendSpacePlayer::CurveTarget' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_CurveMatchedBlendSpacePlayer, PlayRate) == 0x000070, "Member 'FSBZAnimNode_CurveMatchedBlendSpacePlayer::PlayRate' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_CurveMatchedBlendSpacePlayer, BlendFilter) == 0x000078, "Member 'FSBZAnimNode_CurveMatchedBlendSpacePlayer::BlendFilter' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_CurveMatchedBlendSpacePlayer, BlendSampleDataCache) == 0x0000F0, "Member 'FSBZAnimNode_CurveMatchedBlendSpacePlayer::BlendSampleDataCache' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_CurveMatchedBlendSpacePlayer, PreviousBlendSpace) == 0x000100, "Member 'FSBZAnimNode_CurveMatchedBlendSpacePlayer::PreviousBlendSpace' has a wrong offset!");

// ScriptStruct Starbreeze.SBZChallengeDailyBlock
// 0x0010 (0x0010 - 0x0000)
struct FSBZChallengeDailyBlock final
{
public:
	TArray<struct FSBZChallengeDailySlot>         SlotArray;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZChallengeDailyBlock) == 0x000008, "Wrong alignment on FSBZChallengeDailyBlock");
static_assert(sizeof(FSBZChallengeDailyBlock) == 0x000010, "Wrong size on FSBZChallengeDailyBlock");
static_assert(offsetof(FSBZChallengeDailyBlock, SlotArray) == 0x000000, "Member 'FSBZChallengeDailyBlock::SlotArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZChallengeDailySettings
// 0x0010 (0x0010 - 0x0000)
struct FSBZChallengeDailySettings final
{
public:
	struct FSBZChallengeDailyBlock                BlockArray;                                        // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZChallengeDailySettings) == 0x000008, "Wrong alignment on FSBZChallengeDailySettings");
static_assert(sizeof(FSBZChallengeDailySettings) == 0x000010, "Wrong size on FSBZChallengeDailySettings");
static_assert(offsetof(FSBZChallengeDailySettings, BlockArray) == 0x000000, "Member 'FSBZChallengeDailySettings::BlockArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZStageMiscDebugData
// 0x0060 (0x0060 - 0x0000)
struct FSBZStageMiscDebugData final
{
public:
	int32                                         ElementId;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 String;                                            // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                V0;                                                // 0x0024(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                V1;                                                // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Q;                                                 // 0x0040(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ESBZStageMiscDebugDataType                    Type;                                              // 0x0050(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0xE];                                       // 0x0052(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZStageMiscDebugData) == 0x000010, "Wrong alignment on FSBZStageMiscDebugData");
static_assert(sizeof(FSBZStageMiscDebugData) == 0x000060, "Wrong size on FSBZStageMiscDebugData");
static_assert(offsetof(FSBZStageMiscDebugData, ElementId) == 0x000000, "Member 'FSBZStageMiscDebugData::ElementId' has a wrong offset!");
static_assert(offsetof(FSBZStageMiscDebugData, Name) == 0x000004, "Member 'FSBZStageMiscDebugData::Name' has a wrong offset!");
static_assert(offsetof(FSBZStageMiscDebugData, String) == 0x000010, "Member 'FSBZStageMiscDebugData::String' has a wrong offset!");
static_assert(offsetof(FSBZStageMiscDebugData, Color) == 0x000020, "Member 'FSBZStageMiscDebugData::Color' has a wrong offset!");
static_assert(offsetof(FSBZStageMiscDebugData, V0) == 0x000024, "Member 'FSBZStageMiscDebugData::V0' has a wrong offset!");
static_assert(offsetof(FSBZStageMiscDebugData, V1) == 0x000030, "Member 'FSBZStageMiscDebugData::V1' has a wrong offset!");
static_assert(offsetof(FSBZStageMiscDebugData, Q) == 0x000040, "Member 'FSBZStageMiscDebugData::Q' has a wrong offset!");
static_assert(offsetof(FSBZStageMiscDebugData, Type) == 0x000050, "Member 'FSBZStageMiscDebugData::Type' has a wrong offset!");

// ScriptStruct Starbreeze.SBZVariableValue
// 0x0018 (0x0018 - 0x0000)
struct FSBZVariableValue final
{
public:
	TArray<uint8>                                 Value;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZVariableValue) == 0x000008, "Wrong alignment on FSBZVariableValue");
static_assert(sizeof(FSBZVariableValue) == 0x000018, "Wrong size on FSBZVariableValue");
static_assert(offsetof(FSBZVariableValue, Value) == 0x000000, "Member 'FSBZVariableValue::Value' has a wrong offset!");

// ScriptStruct Starbreeze.SBZStageDebugData
// 0x0060 (0x0060 - 0x0000)
struct FSBZStageDebugData
{
public:
	class FName                                   StageName;                                         // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSBZStageMiscDebugData>         MiscDebugData;                                     // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSBZVariableValue>              InputVariableValues;                               // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSBZVariableValue>              OutputVariableValues;                              // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x20];                                      // 0x0040(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZStageDebugData) == 0x000008, "Wrong alignment on FSBZStageDebugData");
static_assert(sizeof(FSBZStageDebugData) == 0x000060, "Wrong size on FSBZStageDebugData");
static_assert(offsetof(FSBZStageDebugData, StageName) == 0x000000, "Member 'FSBZStageDebugData::StageName' has a wrong offset!");
static_assert(offsetof(FSBZStageDebugData, MiscDebugData) == 0x000010, "Member 'FSBZStageDebugData::MiscDebugData' has a wrong offset!");
static_assert(offsetof(FSBZStageDebugData, InputVariableValues) == 0x000020, "Member 'FSBZStageDebugData::InputVariableValues' has a wrong offset!");
static_assert(offsetof(FSBZStageDebugData, OutputVariableValues) == 0x000030, "Member 'FSBZStageDebugData::OutputVariableValues' has a wrong offset!");

// ScriptStruct Starbreeze.SBZFrameDebugData
// 0x0018 (0x0078 - 0x0060)
struct FSBZFrameDebugData final : public FSBZStageDebugData
{
public:
	int32                                         FrameId;                                           // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x10];                                      // 0x0068(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZFrameDebugData) == 0x000008, "Wrong alignment on FSBZFrameDebugData");
static_assert(sizeof(FSBZFrameDebugData) == 0x000078, "Wrong size on FSBZFrameDebugData");
static_assert(offsetof(FSBZFrameDebugData, FrameId) == 0x000060, "Member 'FSBZFrameDebugData::FrameId' has a wrong offset!");
static_assert(offsetof(FSBZFrameDebugData, DeltaTime) == 0x000064, "Member 'FSBZFrameDebugData::DeltaTime' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAnimNode_CurveMatchedSequencePlayer
// 0x0038 (0x0080 - 0x0048)
struct FSBZAnimNode_CurveMatchedSequencePlayer final : public FAnimNode_AssetPlayerBase
{
public:
	class UAnimSequenceBase*                      Sequence;                                          // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CurveName;                                         // 0x0050(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurveTarget;                                       // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoPlay;                                         // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      PreviousSequence;                                  // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAnimNode_CurveMatchedSequencePlayer) == 0x000008, "Wrong alignment on FSBZAnimNode_CurveMatchedSequencePlayer");
static_assert(sizeof(FSBZAnimNode_CurveMatchedSequencePlayer) == 0x000080, "Wrong size on FSBZAnimNode_CurveMatchedSequencePlayer");
static_assert(offsetof(FSBZAnimNode_CurveMatchedSequencePlayer, Sequence) == 0x000048, "Member 'FSBZAnimNode_CurveMatchedSequencePlayer::Sequence' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_CurveMatchedSequencePlayer, CurveName) == 0x000050, "Member 'FSBZAnimNode_CurveMatchedSequencePlayer::CurveName' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_CurveMatchedSequencePlayer, CurveTarget) == 0x00005C, "Member 'FSBZAnimNode_CurveMatchedSequencePlayer::CurveTarget' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_CurveMatchedSequencePlayer, bAutoPlay) == 0x000060, "Member 'FSBZAnimNode_CurveMatchedSequencePlayer::bAutoPlay' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_CurveMatchedSequencePlayer, PreviousSequence) == 0x000068, "Member 'FSBZAnimNode_CurveMatchedSequencePlayer::PreviousSequence' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAIAlertnessDialogRules
// 0x0002 (0x0002 - 0x0000)
struct FSBZAIAlertnessDialogRules final
{
public:
	bool                                          bBlock;                                            // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterrupt;                                        // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAIAlertnessDialogRules) == 0x000001, "Wrong alignment on FSBZAIAlertnessDialogRules");
static_assert(sizeof(FSBZAIAlertnessDialogRules) == 0x000002, "Wrong size on FSBZAIAlertnessDialogRules");
static_assert(offsetof(FSBZAIAlertnessDialogRules, bBlock) == 0x000000, "Member 'FSBZAIAlertnessDialogRules::bBlock' has a wrong offset!");
static_assert(offsetof(FSBZAIAlertnessDialogRules, bInterrupt) == 0x000001, "Member 'FSBZAIAlertnessDialogRules::bInterrupt' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAnimNode_HipsZBlending
// 0x0038 (0x0120 - 0x00E8)
struct FSBZAnimNode_HipsZBlending final : public FAnimNode_SkeletalControlBase
{
public:
	struct FBoneReference                         HipsBoneRef;                                       // 0x00E8(0x0014)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bCanStartNewBlending;                              // 0x00FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReset;                                            // 0x00FD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FE[0x2];                                       // 0x00FE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendDuration;                                     // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlendEaseExp;                                      // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_108[0x18];                                     // 0x0108(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAnimNode_HipsZBlending) == 0x000008, "Wrong alignment on FSBZAnimNode_HipsZBlending");
static_assert(sizeof(FSBZAnimNode_HipsZBlending) == 0x000120, "Wrong size on FSBZAnimNode_HipsZBlending");
static_assert(offsetof(FSBZAnimNode_HipsZBlending, HipsBoneRef) == 0x0000E8, "Member 'FSBZAnimNode_HipsZBlending::HipsBoneRef' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_HipsZBlending, bCanStartNewBlending) == 0x0000FC, "Member 'FSBZAnimNode_HipsZBlending::bCanStartNewBlending' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_HipsZBlending, bReset) == 0x0000FD, "Member 'FSBZAnimNode_HipsZBlending::bReset' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_HipsZBlending, BlendDuration) == 0x000100, "Member 'FSBZAnimNode_HipsZBlending::BlendDuration' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_HipsZBlending, BlendEaseExp) == 0x000104, "Member 'FSBZAnimNode_HipsZBlending::BlendEaseExp' has a wrong offset!");

// ScriptStruct Starbreeze.AsyncLoadLevelParams
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FAsyncLoadLevelParams final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAsyncLoadLevelParams) == 0x000008, "Wrong alignment on FAsyncLoadLevelParams");
static_assert(sizeof(FAsyncLoadLevelParams) == 0x000010, "Wrong size on FAsyncLoadLevelParams");

// ScriptStruct Starbreeze.SBZDialogAnimDataWrapper
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FSBZDialogAnimDataWrapper final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZDialogAnimDataWrapper) == 0x000008, "Wrong alignment on FSBZDialogAnimDataWrapper");
static_assert(sizeof(FSBZDialogAnimDataWrapper) == 0x000008, "Wrong size on FSBZDialogAnimDataWrapper");

// ScriptStruct Starbreeze.SBZAnimMode_LipSync
// 0x00E8 (0x0108 - 0x0020)
struct FSBZAnimMode_LipSync final : public FAnimNode_Base
{
public:
	struct FPoseLink                              SourcePose;                                        // 0x0020(0x0010)(Edit, BlueprintVisible, EditFixedSize, NoDestructor, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             PhonemeBlendInType;                                // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             PhonemeBlendOutType;                               // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PhonemeStrength;                                   // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSBZDialogAnimDataWrapper              DialogAnimDataWrapper;                             // 0x0038(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         DialogStartTime;                                   // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInputAlphaBoolBlend                   AlphaBoolBlend;                                    // 0x0050(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   AlphaCurveName;                                    // 0x0098(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputScaleBiasClamp                   AlphaScaleBiasClamp;                               // 0x00A4(0x0030)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	EAnimAlphaInputType                           AlphaInputType;                                    // 0x00D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlphaBoolEnabled;                                 // 0x00D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA[0x2];                                       // 0x00DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LODThreshold;                                      // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LODInterpolateTime;                                // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LODInterpolateTimer;                               // 0x00E4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x20];                                      // 0x00E8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAnimMode_LipSync) == 0x000008, "Wrong alignment on FSBZAnimMode_LipSync");
static_assert(sizeof(FSBZAnimMode_LipSync) == 0x000108, "Wrong size on FSBZAnimMode_LipSync");
static_assert(offsetof(FSBZAnimMode_LipSync, SourcePose) == 0x000020, "Member 'FSBZAnimMode_LipSync::SourcePose' has a wrong offset!");
static_assert(offsetof(FSBZAnimMode_LipSync, PhonemeBlendInType) == 0x000030, "Member 'FSBZAnimMode_LipSync::PhonemeBlendInType' has a wrong offset!");
static_assert(offsetof(FSBZAnimMode_LipSync, PhonemeBlendOutType) == 0x000031, "Member 'FSBZAnimMode_LipSync::PhonemeBlendOutType' has a wrong offset!");
static_assert(offsetof(FSBZAnimMode_LipSync, PhonemeStrength) == 0x000034, "Member 'FSBZAnimMode_LipSync::PhonemeStrength' has a wrong offset!");
static_assert(offsetof(FSBZAnimMode_LipSync, DialogAnimDataWrapper) == 0x000038, "Member 'FSBZAnimMode_LipSync::DialogAnimDataWrapper' has a wrong offset!");
static_assert(offsetof(FSBZAnimMode_LipSync, DialogStartTime) == 0x000040, "Member 'FSBZAnimMode_LipSync::DialogStartTime' has a wrong offset!");
static_assert(offsetof(FSBZAnimMode_LipSync, Alpha) == 0x000044, "Member 'FSBZAnimMode_LipSync::Alpha' has a wrong offset!");
static_assert(offsetof(FSBZAnimMode_LipSync, AlphaBoolBlend) == 0x000050, "Member 'FSBZAnimMode_LipSync::AlphaBoolBlend' has a wrong offset!");
static_assert(offsetof(FSBZAnimMode_LipSync, AlphaCurveName) == 0x000098, "Member 'FSBZAnimMode_LipSync::AlphaCurveName' has a wrong offset!");
static_assert(offsetof(FSBZAnimMode_LipSync, AlphaScaleBiasClamp) == 0x0000A4, "Member 'FSBZAnimMode_LipSync::AlphaScaleBiasClamp' has a wrong offset!");
static_assert(offsetof(FSBZAnimMode_LipSync, AlphaInputType) == 0x0000D8, "Member 'FSBZAnimMode_LipSync::AlphaInputType' has a wrong offset!");
static_assert(offsetof(FSBZAnimMode_LipSync, bAlphaBoolEnabled) == 0x0000D9, "Member 'FSBZAnimMode_LipSync::bAlphaBoolEnabled' has a wrong offset!");
static_assert(offsetof(FSBZAnimMode_LipSync, LODThreshold) == 0x0000DC, "Member 'FSBZAnimMode_LipSync::LODThreshold' has a wrong offset!");
static_assert(offsetof(FSBZAnimMode_LipSync, LODInterpolateTime) == 0x0000E0, "Member 'FSBZAnimMode_LipSync::LODInterpolateTime' has a wrong offset!");
static_assert(offsetof(FSBZAnimMode_LipSync, LODInterpolateTimer) == 0x0000E4, "Member 'FSBZAnimMode_LipSync::LODInterpolateTimer' has a wrong offset!");

// ScriptStruct Starbreeze.SBZThreeWayBlendHandler
// 0x0038 (0x0038 - 0x0000)
struct FSBZThreeWayBlendHandler final
{
public:
	struct FSBZThreeWayBlendInstance              Instance1;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FSBZThreeWayBlendInstance              Instance2;                                         // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FSBZThreeWayBlendInstance              Instance3;                                         // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZThreeWayBlendHandler) == 0x000008, "Wrong alignment on FSBZThreeWayBlendHandler");
static_assert(sizeof(FSBZThreeWayBlendHandler) == 0x000038, "Wrong size on FSBZThreeWayBlendHandler");
static_assert(offsetof(FSBZThreeWayBlendHandler, Instance1) == 0x000000, "Member 'FSBZThreeWayBlendHandler::Instance1' has a wrong offset!");
static_assert(offsetof(FSBZThreeWayBlendHandler, Instance2) == 0x000010, "Member 'FSBZThreeWayBlendHandler::Instance2' has a wrong offset!");
static_assert(offsetof(FSBZThreeWayBlendHandler, Instance3) == 0x000020, "Member 'FSBZThreeWayBlendHandler::Instance3' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAnimMode_OrientationWarping
// 0x00F8 (0x0118 - 0x0020)
struct FSBZAnimMode_OrientationWarping final : public FAnimNode_Base
{
public:
	struct FPoseLink                              BasePose;                                          // 0x0020(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LocomotionAngle;                                   // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSBZAxisSettings                       Settings;                                          // 0x0034(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         PelvisBone;                                        // 0x003C(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FSBZBoneRef>                    SpineBones;                                        // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         IKFootRootBone;                                    // 0x0060(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInputAlphaBoolBlend                   AlphaBoolBlend;                                    // 0x0080(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   AlphaCurveName;                                    // 0x00C8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputScaleBiasClamp                   AlphaScaleBiasClamp;                               // 0x00D4(0x0030)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	EAnimAlphaInputType                           AlphaInputType;                                    // 0x0108(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlphaBoolEnabled;                                 // 0x0109(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10A[0x2];                                      // 0x010A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LODThreshold;                                      // 0x010C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LODInterpolateTime;                                // 0x0110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LODInterpolateTimer;                               // 0x0114(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAnimMode_OrientationWarping) == 0x000008, "Wrong alignment on FSBZAnimMode_OrientationWarping");
static_assert(sizeof(FSBZAnimMode_OrientationWarping) == 0x000118, "Wrong size on FSBZAnimMode_OrientationWarping");
static_assert(offsetof(FSBZAnimMode_OrientationWarping, BasePose) == 0x000020, "Member 'FSBZAnimMode_OrientationWarping::BasePose' has a wrong offset!");
static_assert(offsetof(FSBZAnimMode_OrientationWarping, LocomotionAngle) == 0x000030, "Member 'FSBZAnimMode_OrientationWarping::LocomotionAngle' has a wrong offset!");
static_assert(offsetof(FSBZAnimMode_OrientationWarping, Settings) == 0x000034, "Member 'FSBZAnimMode_OrientationWarping::Settings' has a wrong offset!");
static_assert(offsetof(FSBZAnimMode_OrientationWarping, PelvisBone) == 0x00003C, "Member 'FSBZAnimMode_OrientationWarping::PelvisBone' has a wrong offset!");
static_assert(offsetof(FSBZAnimMode_OrientationWarping, SpineBones) == 0x000050, "Member 'FSBZAnimMode_OrientationWarping::SpineBones' has a wrong offset!");
static_assert(offsetof(FSBZAnimMode_OrientationWarping, IKFootRootBone) == 0x000060, "Member 'FSBZAnimMode_OrientationWarping::IKFootRootBone' has a wrong offset!");
static_assert(offsetof(FSBZAnimMode_OrientationWarping, Alpha) == 0x000074, "Member 'FSBZAnimMode_OrientationWarping::Alpha' has a wrong offset!");
static_assert(offsetof(FSBZAnimMode_OrientationWarping, AlphaBoolBlend) == 0x000080, "Member 'FSBZAnimMode_OrientationWarping::AlphaBoolBlend' has a wrong offset!");
static_assert(offsetof(FSBZAnimMode_OrientationWarping, AlphaCurveName) == 0x0000C8, "Member 'FSBZAnimMode_OrientationWarping::AlphaCurveName' has a wrong offset!");
static_assert(offsetof(FSBZAnimMode_OrientationWarping, AlphaScaleBiasClamp) == 0x0000D4, "Member 'FSBZAnimMode_OrientationWarping::AlphaScaleBiasClamp' has a wrong offset!");
static_assert(offsetof(FSBZAnimMode_OrientationWarping, AlphaInputType) == 0x000108, "Member 'FSBZAnimMode_OrientationWarping::AlphaInputType' has a wrong offset!");
static_assert(offsetof(FSBZAnimMode_OrientationWarping, bAlphaBoolEnabled) == 0x000109, "Member 'FSBZAnimMode_OrientationWarping::bAlphaBoolEnabled' has a wrong offset!");
static_assert(offsetof(FSBZAnimMode_OrientationWarping, LODThreshold) == 0x00010C, "Member 'FSBZAnimMode_OrientationWarping::LODThreshold' has a wrong offset!");
static_assert(offsetof(FSBZAnimMode_OrientationWarping, LODInterpolateTime) == 0x000110, "Member 'FSBZAnimMode_OrientationWarping::LODInterpolateTime' has a wrong offset!");
static_assert(offsetof(FSBZAnimMode_OrientationWarping, LODInterpolateTimer) == 0x000114, "Member 'FSBZAnimMode_OrientationWarping::LODInterpolateTimer' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAnimNode_PoseMatchingBlendSpacePlayer
// 0x00D0 (0x0118 - 0x0048)
struct FSBZAnimNode_PoseMatchingBlendSpacePlayer final : public FAnimNode_AssetPlayerBase
{
public:
	float                                         X;                                                 // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpaceBase*                        BlendSpace;                                        // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CurveName;                                         // 0x0060(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CurveTarget;                                       // 0x006C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyOnInitialize;                                 // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartSearchFromCurrentTime;                       // 0x0079(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x6];                                       // 0x007A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlendFilter                           BlendFilter;                                       // 0x0080(0x0078)(Protected, NativeAccessSpecifierProtected)
	TArray<struct FBlendSampleData>               BlendSampleDataCache;                              // 0x00F8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UBlendSpaceBase*                        PreviousBlendSpace;                                // 0x0108(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_110[0x8];                                      // 0x0110(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAnimNode_PoseMatchingBlendSpacePlayer) == 0x000008, "Wrong alignment on FSBZAnimNode_PoseMatchingBlendSpacePlayer");
static_assert(sizeof(FSBZAnimNode_PoseMatchingBlendSpacePlayer) == 0x000118, "Wrong size on FSBZAnimNode_PoseMatchingBlendSpacePlayer");
static_assert(offsetof(FSBZAnimNode_PoseMatchingBlendSpacePlayer, X) == 0x000048, "Member 'FSBZAnimNode_PoseMatchingBlendSpacePlayer::X' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_PoseMatchingBlendSpacePlayer, Y) == 0x00004C, "Member 'FSBZAnimNode_PoseMatchingBlendSpacePlayer::Y' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_PoseMatchingBlendSpacePlayer, Z) == 0x000050, "Member 'FSBZAnimNode_PoseMatchingBlendSpacePlayer::Z' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_PoseMatchingBlendSpacePlayer, BlendSpace) == 0x000058, "Member 'FSBZAnimNode_PoseMatchingBlendSpacePlayer::BlendSpace' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_PoseMatchingBlendSpacePlayer, CurveName) == 0x000060, "Member 'FSBZAnimNode_PoseMatchingBlendSpacePlayer::CurveName' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_PoseMatchingBlendSpacePlayer, CurveTarget) == 0x00006C, "Member 'FSBZAnimNode_PoseMatchingBlendSpacePlayer::CurveTarget' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_PoseMatchingBlendSpacePlayer, PlayRate) == 0x000074, "Member 'FSBZAnimNode_PoseMatchingBlendSpacePlayer::PlayRate' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_PoseMatchingBlendSpacePlayer, bOnlyOnInitialize) == 0x000078, "Member 'FSBZAnimNode_PoseMatchingBlendSpacePlayer::bOnlyOnInitialize' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_PoseMatchingBlendSpacePlayer, bStartSearchFromCurrentTime) == 0x000079, "Member 'FSBZAnimNode_PoseMatchingBlendSpacePlayer::bStartSearchFromCurrentTime' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_PoseMatchingBlendSpacePlayer, BlendFilter) == 0x000080, "Member 'FSBZAnimNode_PoseMatchingBlendSpacePlayer::BlendFilter' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_PoseMatchingBlendSpacePlayer, BlendSampleDataCache) == 0x0000F8, "Member 'FSBZAnimNode_PoseMatchingBlendSpacePlayer::BlendSampleDataCache' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_PoseMatchingBlendSpacePlayer, PreviousBlendSpace) == 0x000108, "Member 'FSBZAnimNode_PoseMatchingBlendSpacePlayer::PreviousBlendSpace' has a wrong offset!");

// ScriptStruct Starbreeze.SBZDbgLineParams
// 0x002C (0x002C - 0x0000)
struct FSBZDbgLineParams final
{
public:
	struct FVector                                Start;                                             // 0x0000(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x000C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistent;                                       // 0x0020(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Life;                                              // 0x0024(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Priority;                                          // 0x0028(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZDbgLineParams) == 0x000004, "Wrong alignment on FSBZDbgLineParams");
static_assert(sizeof(FSBZDbgLineParams) == 0x00002C, "Wrong size on FSBZDbgLineParams");
static_assert(offsetof(FSBZDbgLineParams, Start) == 0x000000, "Member 'FSBZDbgLineParams::Start' has a wrong offset!");
static_assert(offsetof(FSBZDbgLineParams, End) == 0x00000C, "Member 'FSBZDbgLineParams::End' has a wrong offset!");
static_assert(offsetof(FSBZDbgLineParams, Thickness) == 0x000018, "Member 'FSBZDbgLineParams::Thickness' has a wrong offset!");
static_assert(offsetof(FSBZDbgLineParams, Color) == 0x00001C, "Member 'FSBZDbgLineParams::Color' has a wrong offset!");
static_assert(offsetof(FSBZDbgLineParams, bPersistent) == 0x000020, "Member 'FSBZDbgLineParams::bPersistent' has a wrong offset!");
static_assert(offsetof(FSBZDbgLineParams, Life) == 0x000024, "Member 'FSBZDbgLineParams::Life' has a wrong offset!");
static_assert(offsetof(FSBZDbgLineParams, Priority) == 0x000028, "Member 'FSBZDbgLineParams::Priority' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeaponSwayDataStruct
// 0x009C (0x009C - 0x0000)
struct FSBZWeaponSwayDataStruct final
{
public:
	struct FVector                                CameraOffset;                                      // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MinTranslation;                                    // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MaxTranslation;                                    // 0x0018(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TranslationInfluence;                              // 0x0024(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FinalTranslationMultiplier;                        // 0x0030(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OvershootTranslationDeltaMultiplier;               // 0x003C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TranslationRecoverySpeed;                          // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         XAxisTranslationRecoverySpeed;                     // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MinRotation;                                       // 0x0050(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               MaxRotation;                                       // 0x005C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RotationInfluence;                                 // 0x0068(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FinalRotationMultiplier;                           // 0x0074(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OvershootRotationDeltaMultiplier;                  // 0x0080(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawRecoverySpeed;                                  // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchRecoverySpeed;                                // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollRecoverySpeed;                                 // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YTranslationToRollInfluence;                       // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWeaponSwayDataStruct) == 0x000004, "Wrong alignment on FSBZWeaponSwayDataStruct");
static_assert(sizeof(FSBZWeaponSwayDataStruct) == 0x00009C, "Wrong size on FSBZWeaponSwayDataStruct");
static_assert(offsetof(FSBZWeaponSwayDataStruct, CameraOffset) == 0x000000, "Member 'FSBZWeaponSwayDataStruct::CameraOffset' has a wrong offset!");
static_assert(offsetof(FSBZWeaponSwayDataStruct, MinTranslation) == 0x00000C, "Member 'FSBZWeaponSwayDataStruct::MinTranslation' has a wrong offset!");
static_assert(offsetof(FSBZWeaponSwayDataStruct, MaxTranslation) == 0x000018, "Member 'FSBZWeaponSwayDataStruct::MaxTranslation' has a wrong offset!");
static_assert(offsetof(FSBZWeaponSwayDataStruct, TranslationInfluence) == 0x000024, "Member 'FSBZWeaponSwayDataStruct::TranslationInfluence' has a wrong offset!");
static_assert(offsetof(FSBZWeaponSwayDataStruct, FinalTranslationMultiplier) == 0x000030, "Member 'FSBZWeaponSwayDataStruct::FinalTranslationMultiplier' has a wrong offset!");
static_assert(offsetof(FSBZWeaponSwayDataStruct, OvershootTranslationDeltaMultiplier) == 0x00003C, "Member 'FSBZWeaponSwayDataStruct::OvershootTranslationDeltaMultiplier' has a wrong offset!");
static_assert(offsetof(FSBZWeaponSwayDataStruct, TranslationRecoverySpeed) == 0x000048, "Member 'FSBZWeaponSwayDataStruct::TranslationRecoverySpeed' has a wrong offset!");
static_assert(offsetof(FSBZWeaponSwayDataStruct, XAxisTranslationRecoverySpeed) == 0x00004C, "Member 'FSBZWeaponSwayDataStruct::XAxisTranslationRecoverySpeed' has a wrong offset!");
static_assert(offsetof(FSBZWeaponSwayDataStruct, MinRotation) == 0x000050, "Member 'FSBZWeaponSwayDataStruct::MinRotation' has a wrong offset!");
static_assert(offsetof(FSBZWeaponSwayDataStruct, MaxRotation) == 0x00005C, "Member 'FSBZWeaponSwayDataStruct::MaxRotation' has a wrong offset!");
static_assert(offsetof(FSBZWeaponSwayDataStruct, RotationInfluence) == 0x000068, "Member 'FSBZWeaponSwayDataStruct::RotationInfluence' has a wrong offset!");
static_assert(offsetof(FSBZWeaponSwayDataStruct, FinalRotationMultiplier) == 0x000074, "Member 'FSBZWeaponSwayDataStruct::FinalRotationMultiplier' has a wrong offset!");
static_assert(offsetof(FSBZWeaponSwayDataStruct, OvershootRotationDeltaMultiplier) == 0x000080, "Member 'FSBZWeaponSwayDataStruct::OvershootRotationDeltaMultiplier' has a wrong offset!");
static_assert(offsetof(FSBZWeaponSwayDataStruct, YawRecoverySpeed) == 0x00008C, "Member 'FSBZWeaponSwayDataStruct::YawRecoverySpeed' has a wrong offset!");
static_assert(offsetof(FSBZWeaponSwayDataStruct, PitchRecoverySpeed) == 0x000090, "Member 'FSBZWeaponSwayDataStruct::PitchRecoverySpeed' has a wrong offset!");
static_assert(offsetof(FSBZWeaponSwayDataStruct, RollRecoverySpeed) == 0x000094, "Member 'FSBZWeaponSwayDataStruct::RollRecoverySpeed' has a wrong offset!");
static_assert(offsetof(FSBZWeaponSwayDataStruct, YTranslationToRollInfluence) == 0x000098, "Member 'FSBZWeaponSwayDataStruct::YTranslationToRollInfluence' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAnimNode_TransitionPose
// 0x0060 (0x0080 - 0x0020)
struct FSBZAnimNode_TransitionPose final : public FAnimNode_Base
{
public:
	float                                         TransitionDuration;                                // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActivateInertialization;                          // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPoseLink                              BasePose;                                          // 0x0028(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x48];                                      // 0x0038(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAnimNode_TransitionPose) == 0x000008, "Wrong alignment on FSBZAnimNode_TransitionPose");
static_assert(sizeof(FSBZAnimNode_TransitionPose) == 0x000080, "Wrong size on FSBZAnimNode_TransitionPose");
static_assert(offsetof(FSBZAnimNode_TransitionPose, TransitionDuration) == 0x000020, "Member 'FSBZAnimNode_TransitionPose::TransitionDuration' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_TransitionPose, bActivateInertialization) == 0x000024, "Member 'FSBZAnimNode_TransitionPose::bActivateInertialization' has a wrong offset!");
static_assert(offsetof(FSBZAnimNode_TransitionPose, BasePose) == 0x000028, "Member 'FSBZAnimNode_TransitionPose::BasePose' has a wrong offset!");

// ScriptStruct Starbreeze.SBZRandomDefaultSwitchStates
// 0x0020 (0x0020 - 0x0000)
struct FSBZRandomDefaultSwitchStates final
{
public:
	TArray<class FString>                         SwitchGroups;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FString>                         States;                                            // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZRandomDefaultSwitchStates) == 0x000008, "Wrong alignment on FSBZRandomDefaultSwitchStates");
static_assert(sizeof(FSBZRandomDefaultSwitchStates) == 0x000020, "Wrong size on FSBZRandomDefaultSwitchStates");
static_assert(offsetof(FSBZRandomDefaultSwitchStates, SwitchGroups) == 0x000000, "Member 'FSBZRandomDefaultSwitchStates::SwitchGroups' has a wrong offset!");
static_assert(offsetof(FSBZRandomDefaultSwitchStates, States) == 0x000010, "Member 'FSBZRandomDefaultSwitchStates::States' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInertializationPoseDiff
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FSBZInertializationPoseDiff final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZInertializationPoseDiff) == 0x000008, "Wrong alignment on FSBZInertializationPoseDiff");
static_assert(sizeof(FSBZInertializationPoseDiff) == 0x000018, "Wrong size on FSBZInertializationPoseDiff");

// ScriptStruct Starbreeze.SBZAgilityNavlinkRooms
// 0x0060 (0x0060 - 0x0000)
struct FSBZAgilityNavlinkRooms final
{
public:
	TSoftObjectPtr<class ASBZRoomVolume>          LeftRoom;                                          // 0x0000(0x0030)(Edit, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ASBZRoomVolume>          RightRoom;                                         // 0x0030(0x0030)(Edit, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAgilityNavlinkRooms) == 0x000008, "Wrong alignment on FSBZAgilityNavlinkRooms");
static_assert(sizeof(FSBZAgilityNavlinkRooms) == 0x000060, "Wrong size on FSBZAgilityNavlinkRooms");
static_assert(offsetof(FSBZAgilityNavlinkRooms, LeftRoom) == 0x000000, "Member 'FSBZAgilityNavlinkRooms::LeftRoom' has a wrong offset!");
static_assert(offsetof(FSBZAgilityNavlinkRooms, RightRoom) == 0x000030, "Member 'FSBZAgilityNavlinkRooms::RightRoom' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInertializationBoneDiff
// 0x003C (0x003C - 0x0000)
struct alignas(0x04) FSBZInertializationBoneDiff final
{
public:
	uint8                                         Pad_0[0x3C];                                       // 0x0000(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZInertializationBoneDiff) == 0x000004, "Wrong alignment on FSBZInertializationBoneDiff");
static_assert(sizeof(FSBZInertializationBoneDiff) == 0x00003C, "Wrong size on FSBZInertializationBoneDiff");

// ScriptStruct Starbreeze.SBZInertializationPose
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x10) FSBZInertializationPose final
{
public:
	uint8                                         Pad_0[0x60];                                       // 0x0000(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZInertializationPose) == 0x000010, "Wrong alignment on FSBZInertializationPose");
static_assert(sizeof(FSBZInertializationPose) == 0x000060, "Wrong size on FSBZInertializationPose");

// ScriptStruct Starbreeze.SBZDrillMatData
// 0x0008 (0x0008 - 0x0000)
struct FSBZDrillMatData final
{
public:
	float                                         ProgressPerSec;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeatPerSec;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZDrillMatData) == 0x000004, "Wrong alignment on FSBZDrillMatData");
static_assert(sizeof(FSBZDrillMatData) == 0x000008, "Wrong size on FSBZDrillMatData");
static_assert(offsetof(FSBZDrillMatData, ProgressPerSec) == 0x000000, "Member 'FSBZDrillMatData::ProgressPerSec' has a wrong offset!");
static_assert(offsetof(FSBZDrillMatData, HeatPerSec) == 0x000004, "Member 'FSBZDrillMatData::HeatPerSec' has a wrong offset!");

// ScriptStruct Starbreeze.SBZRemoteEventWithActorParams
// 0x0008 (0x0008 - 0x0000)
struct FSBZRemoteEventWithActorParams final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZRemoteEventWithActorParams) == 0x000008, "Wrong alignment on FSBZRemoteEventWithActorParams");
static_assert(sizeof(FSBZRemoteEventWithActorParams) == 0x000008, "Wrong size on FSBZRemoteEventWithActorParams");
static_assert(offsetof(FSBZRemoteEventWithActorParams, Actor) == 0x000000, "Member 'FSBZRemoteEventWithActorParams::Actor' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWrinkleCPDData
// 0x0018 (0x0018 - 0x0000)
struct FSBZWrinkleCPDData final
{
public:
	int32                                         CPDIndex;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSBZWrinklePackedFloatData>     PackedFloatDataArray;                              // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWrinkleCPDData) == 0x000008, "Wrong alignment on FSBZWrinkleCPDData");
static_assert(sizeof(FSBZWrinkleCPDData) == 0x000018, "Wrong size on FSBZWrinkleCPDData");
static_assert(offsetof(FSBZWrinkleCPDData, CPDIndex) == 0x000000, "Member 'FSBZWrinkleCPDData::CPDIndex' has a wrong offset!");
static_assert(offsetof(FSBZWrinkleCPDData, PackedFloatDataArray) == 0x000008, "Member 'FSBZWrinkleCPDData::PackedFloatDataArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWrinklesHandler
// 0x0010 (0x0010 - 0x0000)
struct FSBZWrinklesHandler final
{
public:
	TArray<struct FSBZWrinkleCPDData>             WrinkleCPDDataArray;                               // 0x0000(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FSBZWrinklesHandler) == 0x000008, "Wrong alignment on FSBZWrinklesHandler");
static_assert(sizeof(FSBZWrinklesHandler) == 0x000010, "Wrong size on FSBZWrinklesHandler");
static_assert(offsetof(FSBZWrinklesHandler, WrinkleCPDDataArray) == 0x000000, "Member 'FSBZWrinklesHandler::WrinkleCPDDataArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZActionControlReference
// 0x0010 (0x0030 - 0x0020)
struct FSBZActionControlReference final : public FSBZBaseControlReference
{
public:
	TArray<class FName>                           ActionList;                                        // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZActionControlReference) == 0x000008, "Wrong alignment on FSBZActionControlReference");
static_assert(sizeof(FSBZActionControlReference) == 0x000030, "Wrong size on FSBZActionControlReference");
static_assert(offsetof(FSBZActionControlReference, ActionList) == 0x000020, "Member 'FSBZActionControlReference::ActionList' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMainteneanceBoxSequence
// 0x0010 (0x0010 - 0x0000)
struct FSBZMainteneanceBoxSequence final
{
public:
	TArray<int32>                                 Sequence;                                          // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZMainteneanceBoxSequence) == 0x000008, "Wrong alignment on FSBZMainteneanceBoxSequence");
static_assert(sizeof(FSBZMainteneanceBoxSequence) == 0x000010, "Wrong size on FSBZMainteneanceBoxSequence");
static_assert(offsetof(FSBZMainteneanceBoxSequence, Sequence) == 0x000000, "Member 'FSBZMainteneanceBoxSequence::Sequence' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMontageSectionSwitchRequest
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x10) FSBZMontageSectionSwitchRequest final
{
public:
	class USBZAutoSectionSwitchNotifyState*       NotifyState;                                       // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Montage;                                           // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x20];                                      // 0x0010(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZMontageSectionSwitchRequest) == 0x000010, "Wrong alignment on FSBZMontageSectionSwitchRequest");
static_assert(sizeof(FSBZMontageSectionSwitchRequest) == 0x000030, "Wrong size on FSBZMontageSectionSwitchRequest");
static_assert(offsetof(FSBZMontageSectionSwitchRequest, NotifyState) == 0x000000, "Member 'FSBZMontageSectionSwitchRequest::NotifyState' has a wrong offset!");
static_assert(offsetof(FSBZMontageSectionSwitchRequest, Montage) == 0x000008, "Member 'FSBZMontageSectionSwitchRequest::Montage' has a wrong offset!");

// ScriptStruct Starbreeze.SBZFlooredIntervalDetectionSettings
// 0x0094 (0x0094 - 0x0000)
struct FSBZFlooredIntervalDetectionSettings final
{
public:
	bool                                          bUseDisablingCurve;                                // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DisablingCurve;                                    // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDisablingFrameInterval;                        // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x1];                                       // 0x0011(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int16                                         MinFrame;                                          // 0x0012(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         MaxFrame;                                          // 0x0014(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ToeBaseHeightThreshold;                            // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ToeBasePitchThreshold;                             // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloorBoneHeightThreshold;                          // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloorBonePitchThreshold;                           // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoComputeLooping;                               // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLooping;                                        // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDoingToeToTip;                                  // 0x002A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebug;                                            // 0x002B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinIntervalFrameCount;                             // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreateContactCurves;                              // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreateContactNotifies;                            // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FootContactNotifyTrackName;                        // 0x0034(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RootBoneName;                                      // 0x0040(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftCurveName;                                     // 0x004C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightCurveName;                                    // 0x0058(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftFloorBoneName;                                 // 0x0064(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftToeBaseBoneName;                               // 0x0070(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightFloorBoneName;                                // 0x007C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightToeBaseBoneName;                              // 0x0088(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZFlooredIntervalDetectionSettings) == 0x000004, "Wrong alignment on FSBZFlooredIntervalDetectionSettings");
static_assert(sizeof(FSBZFlooredIntervalDetectionSettings) == 0x000094, "Wrong size on FSBZFlooredIntervalDetectionSettings");
static_assert(offsetof(FSBZFlooredIntervalDetectionSettings, bUseDisablingCurve) == 0x000000, "Member 'FSBZFlooredIntervalDetectionSettings::bUseDisablingCurve' has a wrong offset!");
static_assert(offsetof(FSBZFlooredIntervalDetectionSettings, DisablingCurve) == 0x000004, "Member 'FSBZFlooredIntervalDetectionSettings::DisablingCurve' has a wrong offset!");
static_assert(offsetof(FSBZFlooredIntervalDetectionSettings, bUseDisablingFrameInterval) == 0x000010, "Member 'FSBZFlooredIntervalDetectionSettings::bUseDisablingFrameInterval' has a wrong offset!");
static_assert(offsetof(FSBZFlooredIntervalDetectionSettings, MinFrame) == 0x000012, "Member 'FSBZFlooredIntervalDetectionSettings::MinFrame' has a wrong offset!");
static_assert(offsetof(FSBZFlooredIntervalDetectionSettings, MaxFrame) == 0x000014, "Member 'FSBZFlooredIntervalDetectionSettings::MaxFrame' has a wrong offset!");
static_assert(offsetof(FSBZFlooredIntervalDetectionSettings, ToeBaseHeightThreshold) == 0x000018, "Member 'FSBZFlooredIntervalDetectionSettings::ToeBaseHeightThreshold' has a wrong offset!");
static_assert(offsetof(FSBZFlooredIntervalDetectionSettings, ToeBasePitchThreshold) == 0x00001C, "Member 'FSBZFlooredIntervalDetectionSettings::ToeBasePitchThreshold' has a wrong offset!");
static_assert(offsetof(FSBZFlooredIntervalDetectionSettings, FloorBoneHeightThreshold) == 0x000020, "Member 'FSBZFlooredIntervalDetectionSettings::FloorBoneHeightThreshold' has a wrong offset!");
static_assert(offsetof(FSBZFlooredIntervalDetectionSettings, FloorBonePitchThreshold) == 0x000024, "Member 'FSBZFlooredIntervalDetectionSettings::FloorBonePitchThreshold' has a wrong offset!");
static_assert(offsetof(FSBZFlooredIntervalDetectionSettings, bAutoComputeLooping) == 0x000028, "Member 'FSBZFlooredIntervalDetectionSettings::bAutoComputeLooping' has a wrong offset!");
static_assert(offsetof(FSBZFlooredIntervalDetectionSettings, bIsLooping) == 0x000029, "Member 'FSBZFlooredIntervalDetectionSettings::bIsLooping' has a wrong offset!");
static_assert(offsetof(FSBZFlooredIntervalDetectionSettings, bIsDoingToeToTip) == 0x00002A, "Member 'FSBZFlooredIntervalDetectionSettings::bIsDoingToeToTip' has a wrong offset!");
static_assert(offsetof(FSBZFlooredIntervalDetectionSettings, bDebug) == 0x00002B, "Member 'FSBZFlooredIntervalDetectionSettings::bDebug' has a wrong offset!");
static_assert(offsetof(FSBZFlooredIntervalDetectionSettings, MinIntervalFrameCount) == 0x00002C, "Member 'FSBZFlooredIntervalDetectionSettings::MinIntervalFrameCount' has a wrong offset!");
static_assert(offsetof(FSBZFlooredIntervalDetectionSettings, bCreateContactCurves) == 0x000030, "Member 'FSBZFlooredIntervalDetectionSettings::bCreateContactCurves' has a wrong offset!");
static_assert(offsetof(FSBZFlooredIntervalDetectionSettings, bCreateContactNotifies) == 0x000031, "Member 'FSBZFlooredIntervalDetectionSettings::bCreateContactNotifies' has a wrong offset!");
static_assert(offsetof(FSBZFlooredIntervalDetectionSettings, FootContactNotifyTrackName) == 0x000034, "Member 'FSBZFlooredIntervalDetectionSettings::FootContactNotifyTrackName' has a wrong offset!");
static_assert(offsetof(FSBZFlooredIntervalDetectionSettings, RootBoneName) == 0x000040, "Member 'FSBZFlooredIntervalDetectionSettings::RootBoneName' has a wrong offset!");
static_assert(offsetof(FSBZFlooredIntervalDetectionSettings, LeftCurveName) == 0x00004C, "Member 'FSBZFlooredIntervalDetectionSettings::LeftCurveName' has a wrong offset!");
static_assert(offsetof(FSBZFlooredIntervalDetectionSettings, RightCurveName) == 0x000058, "Member 'FSBZFlooredIntervalDetectionSettings::RightCurveName' has a wrong offset!");
static_assert(offsetof(FSBZFlooredIntervalDetectionSettings, LeftFloorBoneName) == 0x000064, "Member 'FSBZFlooredIntervalDetectionSettings::LeftFloorBoneName' has a wrong offset!");
static_assert(offsetof(FSBZFlooredIntervalDetectionSettings, LeftToeBaseBoneName) == 0x000070, "Member 'FSBZFlooredIntervalDetectionSettings::LeftToeBaseBoneName' has a wrong offset!");
static_assert(offsetof(FSBZFlooredIntervalDetectionSettings, RightFloorBoneName) == 0x00007C, "Member 'FSBZFlooredIntervalDetectionSettings::RightFloorBoneName' has a wrong offset!");
static_assert(offsetof(FSBZFlooredIntervalDetectionSettings, RightToeBaseBoneName) == 0x000088, "Member 'FSBZFlooredIntervalDetectionSettings::RightToeBaseBoneName' has a wrong offset!");

// ScriptStruct Starbreeze.SBZLookFocusParameters
// 0x0040 (0x0040 - 0x0000)
struct FSBZLookFocusParameters final
{
public:
	struct FFloatInterval                         YawInterval;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         PitchInterval;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinBlendInTime;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInEaseExp;                                    // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinBlendOutTime;                                   // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutEaseExp;                                   // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         SignificancePercentInterval;                       // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceForMaxSignificance;                        // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistFromGoal;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationInterpSpeed;                               // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENotifyFilterType                             NotifyFilterType;                                  // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NotifyFilterLOD;                                   // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZLookFocusParameters) == 0x000004, "Wrong alignment on FSBZLookFocusParameters");
static_assert(sizeof(FSBZLookFocusParameters) == 0x000040, "Wrong size on FSBZLookFocusParameters");
static_assert(offsetof(FSBZLookFocusParameters, YawInterval) == 0x000000, "Member 'FSBZLookFocusParameters::YawInterval' has a wrong offset!");
static_assert(offsetof(FSBZLookFocusParameters, PitchInterval) == 0x000008, "Member 'FSBZLookFocusParameters::PitchInterval' has a wrong offset!");
static_assert(offsetof(FSBZLookFocusParameters, MinBlendInTime) == 0x000010, "Member 'FSBZLookFocusParameters::MinBlendInTime' has a wrong offset!");
static_assert(offsetof(FSBZLookFocusParameters, BlendInEaseExp) == 0x000014, "Member 'FSBZLookFocusParameters::BlendInEaseExp' has a wrong offset!");
static_assert(offsetof(FSBZLookFocusParameters, MinBlendOutTime) == 0x000018, "Member 'FSBZLookFocusParameters::MinBlendOutTime' has a wrong offset!");
static_assert(offsetof(FSBZLookFocusParameters, BlendOutEaseExp) == 0x00001C, "Member 'FSBZLookFocusParameters::BlendOutEaseExp' has a wrong offset!");
static_assert(offsetof(FSBZLookFocusParameters, SignificancePercentInterval) == 0x000020, "Member 'FSBZLookFocusParameters::SignificancePercentInterval' has a wrong offset!");
static_assert(offsetof(FSBZLookFocusParameters, DistanceForMaxSignificance) == 0x000028, "Member 'FSBZLookFocusParameters::DistanceForMaxSignificance' has a wrong offset!");
static_assert(offsetof(FSBZLookFocusParameters, Speed) == 0x00002C, "Member 'FSBZLookFocusParameters::Speed' has a wrong offset!");
static_assert(offsetof(FSBZLookFocusParameters, MaxDistFromGoal) == 0x000030, "Member 'FSBZLookFocusParameters::MaxDistFromGoal' has a wrong offset!");
static_assert(offsetof(FSBZLookFocusParameters, RotationInterpSpeed) == 0x000034, "Member 'FSBZLookFocusParameters::RotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(FSBZLookFocusParameters, NotifyFilterType) == 0x000038, "Member 'FSBZLookFocusParameters::NotifyFilterType' has a wrong offset!");
static_assert(offsetof(FSBZLookFocusParameters, NotifyFilterLOD) == 0x00003C, "Member 'FSBZLookFocusParameters::NotifyFilterLOD' has a wrong offset!");

// ScriptStruct Starbreeze.SBZDialogAnimData
// 0x0048 (0x0048 - 0x0000)
struct FSBZDialogAnimData final
{
public:
	TSoftObjectPtr<class UDataTable>              PhonemeDataTable;                                  // 0x0000(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideFacialEmotion;                            // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZFacialEmotion                             FacialEmotion;                                     // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSBZPhoneme>                    Phonemes;                                          // 0x0038(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZDialogAnimData) == 0x000008, "Wrong alignment on FSBZDialogAnimData");
static_assert(sizeof(FSBZDialogAnimData) == 0x000048, "Wrong size on FSBZDialogAnimData");
static_assert(offsetof(FSBZDialogAnimData, PhonemeDataTable) == 0x000000, "Member 'FSBZDialogAnimData::PhonemeDataTable' has a wrong offset!");
static_assert(offsetof(FSBZDialogAnimData, bOverrideFacialEmotion) == 0x000030, "Member 'FSBZDialogAnimData::bOverrideFacialEmotion' has a wrong offset!");
static_assert(offsetof(FSBZDialogAnimData, FacialEmotion) == 0x000031, "Member 'FSBZDialogAnimData::FacialEmotion' has a wrong offset!");
static_assert(offsetof(FSBZDialogAnimData, Phonemes) == 0x000038, "Member 'FSBZDialogAnimData::Phonemes' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPhonemeDataTableRow
// 0x0040 (0x0048 - 0x0008)
struct FSBZPhonemeDataTableRow final : public FTableRowBase
{
public:
	float                                         m1v;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ev;                                                // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         cv;                                                // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         c;                                                 // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         e;                                                 // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         i;                                                 // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m2v;                                               // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         sv;                                                // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         s;                                                 // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m1;                                                // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m2;                                                // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 t;                                                 // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPhonemeDataTableRow) == 0x000008, "Wrong alignment on FSBZPhonemeDataTableRow");
static_assert(sizeof(FSBZPhonemeDataTableRow) == 0x000048, "Wrong size on FSBZPhonemeDataTableRow");
static_assert(offsetof(FSBZPhonemeDataTableRow, m1v) == 0x000008, "Member 'FSBZPhonemeDataTableRow::m1v' has a wrong offset!");
static_assert(offsetof(FSBZPhonemeDataTableRow, ev) == 0x00000C, "Member 'FSBZPhonemeDataTableRow::ev' has a wrong offset!");
static_assert(offsetof(FSBZPhonemeDataTableRow, cv) == 0x000010, "Member 'FSBZPhonemeDataTableRow::cv' has a wrong offset!");
static_assert(offsetof(FSBZPhonemeDataTableRow, c) == 0x000014, "Member 'FSBZPhonemeDataTableRow::c' has a wrong offset!");
static_assert(offsetof(FSBZPhonemeDataTableRow, e) == 0x000018, "Member 'FSBZPhonemeDataTableRow::e' has a wrong offset!");
static_assert(offsetof(FSBZPhonemeDataTableRow, i) == 0x00001C, "Member 'FSBZPhonemeDataTableRow::i' has a wrong offset!");
static_assert(offsetof(FSBZPhonemeDataTableRow, m2v) == 0x000020, "Member 'FSBZPhonemeDataTableRow::m2v' has a wrong offset!");
static_assert(offsetof(FSBZPhonemeDataTableRow, sv) == 0x000024, "Member 'FSBZPhonemeDataTableRow::sv' has a wrong offset!");
static_assert(offsetof(FSBZPhonemeDataTableRow, s) == 0x000028, "Member 'FSBZPhonemeDataTableRow::s' has a wrong offset!");
static_assert(offsetof(FSBZPhonemeDataTableRow, m1) == 0x00002C, "Member 'FSBZPhonemeDataTableRow::m1' has a wrong offset!");
static_assert(offsetof(FSBZPhonemeDataTableRow, m2) == 0x000030, "Member 'FSBZPhonemeDataTableRow::m2' has a wrong offset!");
static_assert(offsetof(FSBZPhonemeDataTableRow, t) == 0x000038, "Member 'FSBZPhonemeDataTableRow::t' has a wrong offset!");

// ScriptStruct Starbreeze.SBZStopAndTurnMontageInfo
// 0x0010 (0x0010 - 0x0000)
struct FSBZStopAndTurnMontageInfo final
{
public:
	float                                         EntrySpeed;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SelectionSpeedThreshold;                           // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SelectionAngleThreshold;                           // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZStopAndTurnMontageInfo) == 0x000004, "Wrong alignment on FSBZStopAndTurnMontageInfo");
static_assert(sizeof(FSBZStopAndTurnMontageInfo) == 0x000010, "Wrong size on FSBZStopAndTurnMontageInfo");
static_assert(offsetof(FSBZStopAndTurnMontageInfo, EntrySpeed) == 0x000000, "Member 'FSBZStopAndTurnMontageInfo::EntrySpeed' has a wrong offset!");
static_assert(offsetof(FSBZStopAndTurnMontageInfo, Angle) == 0x000004, "Member 'FSBZStopAndTurnMontageInfo::Angle' has a wrong offset!");
static_assert(offsetof(FSBZStopAndTurnMontageInfo, SelectionSpeedThreshold) == 0x000008, "Member 'FSBZStopAndTurnMontageInfo::SelectionSpeedThreshold' has a wrong offset!");
static_assert(offsetof(FSBZStopAndTurnMontageInfo, SelectionAngleThreshold) == 0x00000C, "Member 'FSBZStopAndTurnMontageInfo::SelectionAngleThreshold' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCharacterInventoryData
// 0x0028 (0x0028 - 0x0000)
struct FSBZCharacterInventoryData final
{
public:
	class USBZPlayerCharacterData*                CharacterData;                                     // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCharacterLocked;                                  // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZCharacterLockReason                       CharacterLockReason;                               // 0x0009(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SelectedIndex;                                     // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FirstPlatformPurchaseUrl;                          // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZCharacterInventoryData) == 0x000008, "Wrong alignment on FSBZCharacterInventoryData");
static_assert(sizeof(FSBZCharacterInventoryData) == 0x000028, "Wrong size on FSBZCharacterInventoryData");
static_assert(offsetof(FSBZCharacterInventoryData, CharacterData) == 0x000000, "Member 'FSBZCharacterInventoryData::CharacterData' has a wrong offset!");
static_assert(offsetof(FSBZCharacterInventoryData, bCharacterLocked) == 0x000008, "Member 'FSBZCharacterInventoryData::bCharacterLocked' has a wrong offset!");
static_assert(offsetof(FSBZCharacterInventoryData, CharacterLockReason) == 0x000009, "Member 'FSBZCharacterInventoryData::CharacterLockReason' has a wrong offset!");
static_assert(offsetof(FSBZCharacterInventoryData, SelectedIndex) == 0x00000C, "Member 'FSBZCharacterInventoryData::SelectedIndex' has a wrong offset!");
static_assert(offsetof(FSBZCharacterInventoryData, FirstPlatformPurchaseUrl) == 0x000010, "Member 'FSBZCharacterInventoryData::FirstPlatformPurchaseUrl' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCharacterSlotData
// 0x0030 (0x0030 - 0x0000)
struct FSBZCharacterSlotData final
{
public:
	struct FSBZCharacterInventoryData             CharacterInventoryData;                            // 0x0000(0x0028)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         IndexInInventory;                                  // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZCharacterSlotStatus                       SlotStatus;                                        // 0x002C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZCharacterSlotData) == 0x000008, "Wrong alignment on FSBZCharacterSlotData");
static_assert(sizeof(FSBZCharacterSlotData) == 0x000030, "Wrong size on FSBZCharacterSlotData");
static_assert(offsetof(FSBZCharacterSlotData, CharacterInventoryData) == 0x000000, "Member 'FSBZCharacterSlotData::CharacterInventoryData' has a wrong offset!");
static_assert(offsetof(FSBZCharacterSlotData, IndexInInventory) == 0x000028, "Member 'FSBZCharacterSlotData::IndexInInventory' has a wrong offset!");
static_assert(offsetof(FSBZCharacterSlotData, SlotStatus) == 0x00002C, "Member 'FSBZCharacterSlotData::SlotStatus' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeaponPatternAreaPart
// 0x0018 (0x0018 - 0x0000)
struct FSBZWeaponPatternAreaPart final
{
public:
	int8                                          PartIndex;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeFullPart;                                  // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int8>                                  SubPartIndexes;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWeaponPatternAreaPart) == 0x000008, "Wrong alignment on FSBZWeaponPatternAreaPart");
static_assert(sizeof(FSBZWeaponPatternAreaPart) == 0x000018, "Wrong size on FSBZWeaponPatternAreaPart");
static_assert(offsetof(FSBZWeaponPatternAreaPart, PartIndex) == 0x000000, "Member 'FSBZWeaponPatternAreaPart::PartIndex' has a wrong offset!");
static_assert(offsetof(FSBZWeaponPatternAreaPart, bIncludeFullPart) == 0x000001, "Member 'FSBZWeaponPatternAreaPart::bIncludeFullPart' has a wrong offset!");
static_assert(offsetof(FSBZWeaponPatternAreaPart, SubPartIndexes) == 0x000008, "Member 'FSBZWeaponPatternAreaPart::SubPartIndexes' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeaponPatternAreaDefinition
// 0x0010 (0x0010 - 0x0000)
struct FSBZWeaponPatternAreaDefinition final
{
public:
	TArray<struct FSBZWeaponPatternAreaPart>      PartsInArea;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWeaponPatternAreaDefinition) == 0x000008, "Wrong alignment on FSBZWeaponPatternAreaDefinition");
static_assert(sizeof(FSBZWeaponPatternAreaDefinition) == 0x000010, "Wrong size on FSBZWeaponPatternAreaDefinition");
static_assert(offsetof(FSBZWeaponPatternAreaDefinition, PartsInArea) == 0x000000, "Member 'FSBZWeaponPatternAreaDefinition::PartsInArea' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSharedMontageInfo
// 0x0040 (0x0040 - 0x0000)
struct FSBZSharedMontageInfo final
{
public:
	class UAnimMontage*                           CharacterAnimMontage;                              // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           EquippableAnimMontage;                             // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           LeftEquippableAnimMontage;                         // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USBZCharacterAnimation*                 CharacterAnimInstance;                             // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimInstance*                          EquippableAnimInstance;                            // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimInstance*                          LeftEquippableAnimInstance;                        // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSharedMontageInfo) == 0x000008, "Wrong alignment on FSBZSharedMontageInfo");
static_assert(sizeof(FSBZSharedMontageInfo) == 0x000040, "Wrong size on FSBZSharedMontageInfo");
static_assert(offsetof(FSBZSharedMontageInfo, CharacterAnimMontage) == 0x000000, "Member 'FSBZSharedMontageInfo::CharacterAnimMontage' has a wrong offset!");
static_assert(offsetof(FSBZSharedMontageInfo, EquippableAnimMontage) == 0x000008, "Member 'FSBZSharedMontageInfo::EquippableAnimMontage' has a wrong offset!");
static_assert(offsetof(FSBZSharedMontageInfo, LeftEquippableAnimMontage) == 0x000010, "Member 'FSBZSharedMontageInfo::LeftEquippableAnimMontage' has a wrong offset!");
static_assert(offsetof(FSBZSharedMontageInfo, CharacterAnimInstance) == 0x000028, "Member 'FSBZSharedMontageInfo::CharacterAnimInstance' has a wrong offset!");
static_assert(offsetof(FSBZSharedMontageInfo, EquippableAnimInstance) == 0x000030, "Member 'FSBZSharedMontageInfo::EquippableAnimInstance' has a wrong offset!");
static_assert(offsetof(FSBZSharedMontageInfo, LeftEquippableAnimInstance) == 0x000038, "Member 'FSBZSharedMontageInfo::LeftEquippableAnimInstance' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSharedAnimBehavior
// 0x0070 (0x0070 - 0x0000)
struct FSBZSharedAnimBehavior final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FSBZSharedMontageInfo> SharedMontageInfos;                              // 0x0020(0x0050)(Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FSBZSharedAnimBehavior) == 0x000008, "Wrong alignment on FSBZSharedAnimBehavior");
static_assert(sizeof(FSBZSharedAnimBehavior) == 0x000070, "Wrong size on FSBZSharedAnimBehavior");
static_assert(offsetof(FSBZSharedAnimBehavior, SharedMontageInfos) == 0x000020, "Member 'FSBZSharedAnimBehavior::SharedMontageInfos' has a wrong offset!");

// ScriptStruct Starbreeze.SBZDbgCapsuleParams
// 0x0050 (0x0050 - 0x0000)
struct FSBZDbgCapsuleParams final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfHeight;                                        // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0xC];                                       // 0x0014(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rotation;                                          // 0x0020(0x0010)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistent;                                       // 0x0038(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Life;                                              // 0x003C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Priority;                                          // 0x0040(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0xF];                                       // 0x0041(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZDbgCapsuleParams) == 0x000010, "Wrong alignment on FSBZDbgCapsuleParams");
static_assert(sizeof(FSBZDbgCapsuleParams) == 0x000050, "Wrong size on FSBZDbgCapsuleParams");
static_assert(offsetof(FSBZDbgCapsuleParams, Location) == 0x000000, "Member 'FSBZDbgCapsuleParams::Location' has a wrong offset!");
static_assert(offsetof(FSBZDbgCapsuleParams, HalfHeight) == 0x00000C, "Member 'FSBZDbgCapsuleParams::HalfHeight' has a wrong offset!");
static_assert(offsetof(FSBZDbgCapsuleParams, Radius) == 0x000010, "Member 'FSBZDbgCapsuleParams::Radius' has a wrong offset!");
static_assert(offsetof(FSBZDbgCapsuleParams, Rotation) == 0x000020, "Member 'FSBZDbgCapsuleParams::Rotation' has a wrong offset!");
static_assert(offsetof(FSBZDbgCapsuleParams, Thickness) == 0x000030, "Member 'FSBZDbgCapsuleParams::Thickness' has a wrong offset!");
static_assert(offsetof(FSBZDbgCapsuleParams, Color) == 0x000034, "Member 'FSBZDbgCapsuleParams::Color' has a wrong offset!");
static_assert(offsetof(FSBZDbgCapsuleParams, bPersistent) == 0x000038, "Member 'FSBZDbgCapsuleParams::bPersistent' has a wrong offset!");
static_assert(offsetof(FSBZDbgCapsuleParams, Life) == 0x00003C, "Member 'FSBZDbgCapsuleParams::Life' has a wrong offset!");
static_assert(offsetof(FSBZDbgCapsuleParams, Priority) == 0x000040, "Member 'FSBZDbgCapsuleParams::Priority' has a wrong offset!");

// ScriptStruct Starbreeze.SBZArmorChunkTypeData
// 0x0054 (0x0054 - 0x0000)
struct FSBZArmorChunkTypeData final
{
public:
	float                                         ReplenishDelay;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDownCount;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageScaleRelative;                               // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraumaScale;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BackgroundColor;                                   // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           MainColor;                                         // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LaggingColor;                                      // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TraumaColor;                                       // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZArmorChunkType                            Type;                                              // 0x0050(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZArmorChunkTypeData) == 0x000004, "Wrong alignment on FSBZArmorChunkTypeData");
static_assert(sizeof(FSBZArmorChunkTypeData) == 0x000054, "Wrong size on FSBZArmorChunkTypeData");
static_assert(offsetof(FSBZArmorChunkTypeData, ReplenishDelay) == 0x000000, "Member 'FSBZArmorChunkTypeData::ReplenishDelay' has a wrong offset!");
static_assert(offsetof(FSBZArmorChunkTypeData, MaxDownCount) == 0x000004, "Member 'FSBZArmorChunkTypeData::MaxDownCount' has a wrong offset!");
static_assert(offsetof(FSBZArmorChunkTypeData, DamageScaleRelative) == 0x000008, "Member 'FSBZArmorChunkTypeData::DamageScaleRelative' has a wrong offset!");
static_assert(offsetof(FSBZArmorChunkTypeData, TraumaScale) == 0x00000C, "Member 'FSBZArmorChunkTypeData::TraumaScale' has a wrong offset!");
static_assert(offsetof(FSBZArmorChunkTypeData, BackgroundColor) == 0x000010, "Member 'FSBZArmorChunkTypeData::BackgroundColor' has a wrong offset!");
static_assert(offsetof(FSBZArmorChunkTypeData, MainColor) == 0x000020, "Member 'FSBZArmorChunkTypeData::MainColor' has a wrong offset!");
static_assert(offsetof(FSBZArmorChunkTypeData, LaggingColor) == 0x000030, "Member 'FSBZArmorChunkTypeData::LaggingColor' has a wrong offset!");
static_assert(offsetof(FSBZArmorChunkTypeData, TraumaColor) == 0x000040, "Member 'FSBZArmorChunkTypeData::TraumaColor' has a wrong offset!");
static_assert(offsetof(FSBZArmorChunkTypeData, Type) == 0x000050, "Member 'FSBZArmorChunkTypeData::Type' has a wrong offset!");

// ScriptStruct Starbreeze.SBZArmorChunkGUIData
// 0x0038 (0x0038 - 0x0000)
struct FSBZArmorChunkGUIData final
{
public:
	ESBZArmorChunkType                            Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USBZArmorChunkWidget*                   Widget;                                            // 0x0008(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               DynamicMaterial;                                   // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmorScale;                                        // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraumaScale;                                       // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TraumaVector;                                      // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReplenishScale;                                    // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZArmorChunkGUIData) == 0x000008, "Wrong alignment on FSBZArmorChunkGUIData");
static_assert(sizeof(FSBZArmorChunkGUIData) == 0x000038, "Wrong size on FSBZArmorChunkGUIData");
static_assert(offsetof(FSBZArmorChunkGUIData, Type) == 0x000000, "Member 'FSBZArmorChunkGUIData::Type' has a wrong offset!");
static_assert(offsetof(FSBZArmorChunkGUIData, Widget) == 0x000008, "Member 'FSBZArmorChunkGUIData::Widget' has a wrong offset!");
static_assert(offsetof(FSBZArmorChunkGUIData, DynamicMaterial) == 0x000010, "Member 'FSBZArmorChunkGUIData::DynamicMaterial' has a wrong offset!");
static_assert(offsetof(FSBZArmorChunkGUIData, ArmorScale) == 0x000018, "Member 'FSBZArmorChunkGUIData::ArmorScale' has a wrong offset!");
static_assert(offsetof(FSBZArmorChunkGUIData, TraumaScale) == 0x00001C, "Member 'FSBZArmorChunkGUIData::TraumaScale' has a wrong offset!");
static_assert(offsetof(FSBZArmorChunkGUIData, TraumaVector) == 0x000020, "Member 'FSBZArmorChunkGUIData::TraumaVector' has a wrong offset!");
static_assert(offsetof(FSBZArmorChunkGUIData, ReplenishScale) == 0x000030, "Member 'FSBZArmorChunkGUIData::ReplenishScale' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCrosshairSettings
// 0x003C (0x003C - 0x0000)
struct FSBZCrosshairSettings final
{
public:
	float                                         BarWidth;                                          // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BarLength;                                         // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DotSize;                                           // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowAccuracy;                                     // 0x000C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CenterGap;                                         // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinCrosshairScale;                                 // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCrosshairScale;                                 // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           CrosshairBarColor;                                 // 0x001C(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           CrosshairDotColor;                                 // 0x002C(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZCrosshairSettings) == 0x000004, "Wrong alignment on FSBZCrosshairSettings");
static_assert(sizeof(FSBZCrosshairSettings) == 0x00003C, "Wrong size on FSBZCrosshairSettings");
static_assert(offsetof(FSBZCrosshairSettings, BarWidth) == 0x000000, "Member 'FSBZCrosshairSettings::BarWidth' has a wrong offset!");
static_assert(offsetof(FSBZCrosshairSettings, BarLength) == 0x000004, "Member 'FSBZCrosshairSettings::BarLength' has a wrong offset!");
static_assert(offsetof(FSBZCrosshairSettings, DotSize) == 0x000008, "Member 'FSBZCrosshairSettings::DotSize' has a wrong offset!");
static_assert(offsetof(FSBZCrosshairSettings, bShowAccuracy) == 0x00000C, "Member 'FSBZCrosshairSettings::bShowAccuracy' has a wrong offset!");
static_assert(offsetof(FSBZCrosshairSettings, CenterGap) == 0x000010, "Member 'FSBZCrosshairSettings::CenterGap' has a wrong offset!");
static_assert(offsetof(FSBZCrosshairSettings, MinCrosshairScale) == 0x000014, "Member 'FSBZCrosshairSettings::MinCrosshairScale' has a wrong offset!");
static_assert(offsetof(FSBZCrosshairSettings, MaxCrosshairScale) == 0x000018, "Member 'FSBZCrosshairSettings::MaxCrosshairScale' has a wrong offset!");
static_assert(offsetof(FSBZCrosshairSettings, CrosshairBarColor) == 0x00001C, "Member 'FSBZCrosshairSettings::CrosshairBarColor' has a wrong offset!");
static_assert(offsetof(FSBZCrosshairSettings, CrosshairDotColor) == 0x00002C, "Member 'FSBZCrosshairSettings::CrosshairDotColor' has a wrong offset!");

// ScriptStruct Starbreeze.SBZVehicleDoorStatePerType
// 0x0002 (0x0002 - 0x0000)
struct FSBZVehicleDoorStatePerType final
{
public:
	ESBZVehicleDoorType                           DoorType;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZVehicleDoorState                          DoorState;                                         // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZVehicleDoorStatePerType) == 0x000001, "Wrong alignment on FSBZVehicleDoorStatePerType");
static_assert(sizeof(FSBZVehicleDoorStatePerType) == 0x000002, "Wrong size on FSBZVehicleDoorStatePerType");
static_assert(offsetof(FSBZVehicleDoorStatePerType, DoorType) == 0x000000, "Member 'FSBZVehicleDoorStatePerType::DoorType' has a wrong offset!");
static_assert(offsetof(FSBZVehicleDoorStatePerType, DoorState) == 0x000001, "Member 'FSBZVehicleDoorStatePerType::DoorState' has a wrong offset!");

// ScriptStruct Starbreeze.SBZGameplayTagCounterArrayItem
// 0x0014 (0x0020 - 0x000C)
struct FSBZGameplayTagCounterArrayItem final : public FFastArraySerializerItem
{
public:
	struct FGameplayTag                           Tag;                                               // 0x000C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Count;                                             // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZGameplayTagCounterArrayItem) == 0x000004, "Wrong alignment on FSBZGameplayTagCounterArrayItem");
static_assert(sizeof(FSBZGameplayTagCounterArrayItem) == 0x000020, "Wrong size on FSBZGameplayTagCounterArrayItem");
static_assert(offsetof(FSBZGameplayTagCounterArrayItem, Tag) == 0x00000C, "Member 'FSBZGameplayTagCounterArrayItem::Tag' has a wrong offset!");
static_assert(offsetof(FSBZGameplayTagCounterArrayItem, Count) == 0x000018, "Member 'FSBZGameplayTagCounterArrayItem::Count' has a wrong offset!");

// ScriptStruct Starbreeze.SBZGameplayTagCounterArray
// 0x0048 (0x0150 - 0x0108)
struct FSBZGameplayTagCounterArray final : public FFastArraySerializer
{
public:
	TScriptInterface<class ISBZGameplayTagCounterArrayOwnerInterface> Owner;                         // 0x0108(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FSBZGameplayTagCounterArrayItem> Items;                                            // 0x0118(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x28];                                     // 0x0128(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZGameplayTagCounterArray) == 0x000008, "Wrong alignment on FSBZGameplayTagCounterArray");
static_assert(sizeof(FSBZGameplayTagCounterArray) == 0x000150, "Wrong size on FSBZGameplayTagCounterArray");
static_assert(offsetof(FSBZGameplayTagCounterArray, Owner) == 0x000108, "Member 'FSBZGameplayTagCounterArray::Owner' has a wrong offset!");
static_assert(offsetof(FSBZGameplayTagCounterArray, Items) == 0x000118, "Member 'FSBZGameplayTagCounterArray::Items' has a wrong offset!");

// ScriptStruct Starbreeze.SBZHurtReactionLookup
// 0x0028 (0x0028 - 0x0000)
struct FSBZHurtReactionLookup final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZDamageWeight                              Weight;                                            // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZHurtReactionPose                          Pose;                                              // 0x0009(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZHurtReactionDirection                     Direction;                                         // 0x000A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x000C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0018(0x000C)(Edit, DisableEditOnInstance, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZHurtReactionLookup) == 0x000008, "Wrong alignment on FSBZHurtReactionLookup");
static_assert(sizeof(FSBZHurtReactionLookup) == 0x000028, "Wrong size on FSBZHurtReactionLookup");
static_assert(offsetof(FSBZHurtReactionLookup, Montage) == 0x000000, "Member 'FSBZHurtReactionLookup::Montage' has a wrong offset!");
static_assert(offsetof(FSBZHurtReactionLookup, Weight) == 0x000008, "Member 'FSBZHurtReactionLookup::Weight' has a wrong offset!");
static_assert(offsetof(FSBZHurtReactionLookup, Pose) == 0x000009, "Member 'FSBZHurtReactionLookup::Pose' has a wrong offset!");
static_assert(offsetof(FSBZHurtReactionLookup, Direction) == 0x00000A, "Member 'FSBZHurtReactionLookup::Direction' has a wrong offset!");
static_assert(offsetof(FSBZHurtReactionLookup, BoneName) == 0x00000C, "Member 'FSBZHurtReactionLookup::BoneName' has a wrong offset!");
static_assert(offsetof(FSBZHurtReactionLookup, Tag) == 0x000018, "Member 'FSBZHurtReactionLookup::Tag' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPawnSpawnRequest
// 0x0050 (0x0050 - 0x0000)
struct FSBZPawnSpawnRequest final
{
public:
	class USBZPawnSpawnRequestData*               Data;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ASBZPawnSpawnBase>       Spawner;                                           // 0x0008(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZAIAction*                           Action;                                            // 0x0038(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZSpawnSignificance                         Significance;                                      // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            GameplayEffectClass;                               // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPawnSpawnRequest) == 0x000008, "Wrong alignment on FSBZPawnSpawnRequest");
static_assert(sizeof(FSBZPawnSpawnRequest) == 0x000050, "Wrong size on FSBZPawnSpawnRequest");
static_assert(offsetof(FSBZPawnSpawnRequest, Data) == 0x000000, "Member 'FSBZPawnSpawnRequest::Data' has a wrong offset!");
static_assert(offsetof(FSBZPawnSpawnRequest, Spawner) == 0x000008, "Member 'FSBZPawnSpawnRequest::Spawner' has a wrong offset!");
static_assert(offsetof(FSBZPawnSpawnRequest, Action) == 0x000038, "Member 'FSBZPawnSpawnRequest::Action' has a wrong offset!");
static_assert(offsetof(FSBZPawnSpawnRequest, Significance) == 0x000040, "Member 'FSBZPawnSpawnRequest::Significance' has a wrong offset!");
static_assert(offsetof(FSBZPawnSpawnRequest, GameplayEffectClass) == 0x000048, "Member 'FSBZPawnSpawnRequest::GameplayEffectClass' has a wrong offset!");

// ScriptStruct Starbreeze.SBZBagFilter
// 0x0030 (0x0030 - 0x0000)
struct FSBZBagFilter final
{
public:
	TArray<class USBZBagType*>                    FilterTypes;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  FilterTags;                                        // 0x0010(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZBagFilter) == 0x000008, "Wrong alignment on FSBZBagFilter");
static_assert(sizeof(FSBZBagFilter) == 0x000030, "Wrong size on FSBZBagFilter");
static_assert(offsetof(FSBZBagFilter, FilterTypes) == 0x000000, "Member 'FSBZBagFilter::FilterTypes' has a wrong offset!");
static_assert(offsetof(FSBZBagFilter, FilterTags) == 0x000010, "Member 'FSBZBagFilter::FilterTags' has a wrong offset!");

// ScriptStruct Starbreeze.SBZFallDamageTargetData
// 0x5B98 (0x5BA0 - 0x0008)
struct FSBZFallDamageTargetData final : public FGameplayAbilityTargetData
{
public:
	uint8                                         Pad_8[0x5B98];                                     // 0x0008(0x5B98)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZFallDamageTargetData) == 0x000008, "Wrong alignment on FSBZFallDamageTargetData");
static_assert(sizeof(FSBZFallDamageTargetData) == 0x005BA0, "Wrong size on FSBZFallDamageTargetData");

// ScriptStruct Starbreeze.SBZBagTriggerData
// 0x0078 (0x0078 - 0x0000)
struct FSBZBagTriggerData final
{
public:
	struct FSBZBagFilter                          BasicFilter;                                       // 0x0000(0x0030)(BlueprintVisible, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FSBZBagHandle& BagHandle, bool* Ret)> FilterDelegate;                // 0x0030(0x0014)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Target;                                            // 0x0044(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             CompleteDelegate;                                  // 0x004C(0x0014)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FSBZBagHandle& BagHandle, int32 Count)> SecuredDelegate;             // 0x0060(0x0014)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZBagTriggerData) == 0x000008, "Wrong alignment on FSBZBagTriggerData");
static_assert(sizeof(FSBZBagTriggerData) == 0x000078, "Wrong size on FSBZBagTriggerData");
static_assert(offsetof(FSBZBagTriggerData, BasicFilter) == 0x000000, "Member 'FSBZBagTriggerData::BasicFilter' has a wrong offset!");
static_assert(offsetof(FSBZBagTriggerData, FilterDelegate) == 0x000030, "Member 'FSBZBagTriggerData::FilterDelegate' has a wrong offset!");
static_assert(offsetof(FSBZBagTriggerData, Target) == 0x000044, "Member 'FSBZBagTriggerData::Target' has a wrong offset!");
static_assert(offsetof(FSBZBagTriggerData, Count) == 0x000048, "Member 'FSBZBagTriggerData::Count' has a wrong offset!");
static_assert(offsetof(FSBZBagTriggerData, CompleteDelegate) == 0x00004C, "Member 'FSBZBagTriggerData::CompleteDelegate' has a wrong offset!");
static_assert(offsetof(FSBZBagTriggerData, SecuredDelegate) == 0x000060, "Member 'FSBZBagTriggerData::SecuredDelegate' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInfamyContentData
// 0x0018 (0x0018 - 0x0000)
struct FSBZInfamyContentData final
{
public:
	int32                                         InfamyLevel;                                       // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InfamyPoints;                                      // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSBZInfamyRewardData>           InfamyRewards;                                     // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZInfamyContentData) == 0x000008, "Wrong alignment on FSBZInfamyContentData");
static_assert(sizeof(FSBZInfamyContentData) == 0x000018, "Wrong size on FSBZInfamyContentData");
static_assert(offsetof(FSBZInfamyContentData, InfamyLevel) == 0x000000, "Member 'FSBZInfamyContentData::InfamyLevel' has a wrong offset!");
static_assert(offsetof(FSBZInfamyContentData, InfamyPoints) == 0x000004, "Member 'FSBZInfamyContentData::InfamyPoints' has a wrong offset!");
static_assert(offsetof(FSBZInfamyContentData, InfamyRewards) == 0x000008, "Member 'FSBZInfamyContentData::InfamyRewards' has a wrong offset!");

// ScriptStruct Starbreeze.SBZBagPersistentData
// 0x0038 (0x0038 - 0x0000)
struct FSBZBagPersistentData final
{
public:
	struct FSBZBagHandle                          Handle;                                            // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Secured;                                           // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CurrentActor;                                      // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASBZPlayerCharacter*                    LastClaimedByPlayerCharacter;                      // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASBZPlayerState*                        LastClaimedByPlayerState;                          // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ServerTimeAtFirstPickup;                           // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZBagPersistentData) == 0x000008, "Wrong alignment on FSBZBagPersistentData");
static_assert(sizeof(FSBZBagPersistentData) == 0x000038, "Wrong size on FSBZBagPersistentData");
static_assert(offsetof(FSBZBagPersistentData, Handle) == 0x000000, "Member 'FSBZBagPersistentData::Handle' has a wrong offset!");
static_assert(offsetof(FSBZBagPersistentData, Secured) == 0x000010, "Member 'FSBZBagPersistentData::Secured' has a wrong offset!");
static_assert(offsetof(FSBZBagPersistentData, CurrentActor) == 0x000018, "Member 'FSBZBagPersistentData::CurrentActor' has a wrong offset!");
static_assert(offsetof(FSBZBagPersistentData, LastClaimedByPlayerCharacter) == 0x000020, "Member 'FSBZBagPersistentData::LastClaimedByPlayerCharacter' has a wrong offset!");
static_assert(offsetof(FSBZBagPersistentData, LastClaimedByPlayerState) == 0x000028, "Member 'FSBZBagPersistentData::LastClaimedByPlayerState' has a wrong offset!");
static_assert(offsetof(FSBZBagPersistentData, ServerTimeAtFirstPickup) == 0x000030, "Member 'FSBZBagPersistentData::ServerTimeAtFirstPickup' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAnimationContainer
// 0x0018 (0x0018 - 0x0000)
struct FSBZAnimationContainer final
{
public:
	bool                                          bOverride;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAnimationAsset*>                Animations;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAnimationContainer) == 0x000008, "Wrong alignment on FSBZAnimationContainer");
static_assert(sizeof(FSBZAnimationContainer) == 0x000018, "Wrong size on FSBZAnimationContainer");
static_assert(offsetof(FSBZAnimationContainer, bOverride) == 0x000000, "Member 'FSBZAnimationContainer::bOverride' has a wrong offset!");
static_assert(offsetof(FSBZAnimationContainer, Animations) == 0x000008, "Member 'FSBZAnimationContainer::Animations' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSoftMontageContainer
// 0x0018 (0x0018 - 0x0000)
struct FSBZSoftMontageContainer final
{
public:
	bool                                          bOverride;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UAnimMontage>>    Montages;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSoftMontageContainer) == 0x000008, "Wrong alignment on FSBZSoftMontageContainer");
static_assert(sizeof(FSBZSoftMontageContainer) == 0x000018, "Wrong size on FSBZSoftMontageContainer");
static_assert(offsetof(FSBZSoftMontageContainer, bOverride) == 0x000000, "Member 'FSBZSoftMontageContainer::bOverride' has a wrong offset!");
static_assert(offsetof(FSBZSoftMontageContainer, Montages) == 0x000008, "Member 'FSBZSoftMontageContainer::Montages' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAnimationsPerSpecificEquippablesContainer
// 0x0050 (0x0050 - 0x0000)
struct FSBZAnimationsPerSpecificEquippablesContainer final
{
public:
	TMap<class FName, struct FSBZAnimationContainer> AnimationContainers;                            // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAnimationsPerSpecificEquippablesContainer) == 0x000008, "Wrong alignment on FSBZAnimationsPerSpecificEquippablesContainer");
static_assert(sizeof(FSBZAnimationsPerSpecificEquippablesContainer) == 0x000050, "Wrong size on FSBZAnimationsPerSpecificEquippablesContainer");
static_assert(offsetof(FSBZAnimationsPerSpecificEquippablesContainer, AnimationContainers) == 0x000000, "Member 'FSBZAnimationsPerSpecificEquippablesContainer::AnimationContainers' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAnimationsPerEquippablesContainer
// 0x0140 (0x0140 - 0x0000)
struct FSBZAnimationsPerEquippablesContainer final
{
public:
	TMap<class FName, struct FSBZAnimationContainer> AnimationContainers;                            // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FSBZSoftMontageContainer> GamePlayTagBasedMontageContainers;    // 0x0050(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<TSoftClassPtr<class UClass>, struct FSBZAnimationsPerSpecificEquippablesContainer> AnimationPerSpecificEquippablesContainers; // 0x00A0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<TSoftClassPtr<class UClass>, struct FSBZAnimationsPerSpecificEquippablesContainer> AnimationLeftHandEquippedContainers; // 0x00F0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAnimationsPerEquippablesContainer) == 0x000008, "Wrong alignment on FSBZAnimationsPerEquippablesContainer");
static_assert(sizeof(FSBZAnimationsPerEquippablesContainer) == 0x000140, "Wrong size on FSBZAnimationsPerEquippablesContainer");
static_assert(offsetof(FSBZAnimationsPerEquippablesContainer, AnimationContainers) == 0x000000, "Member 'FSBZAnimationsPerEquippablesContainer::AnimationContainers' has a wrong offset!");
static_assert(offsetof(FSBZAnimationsPerEquippablesContainer, GamePlayTagBasedMontageContainers) == 0x000050, "Member 'FSBZAnimationsPerEquippablesContainer::GamePlayTagBasedMontageContainers' has a wrong offset!");
static_assert(offsetof(FSBZAnimationsPerEquippablesContainer, AnimationPerSpecificEquippablesContainers) == 0x0000A0, "Member 'FSBZAnimationsPerEquippablesContainer::AnimationPerSpecificEquippablesContainers' has a wrong offset!");
static_assert(offsetof(FSBZAnimationsPerEquippablesContainer, AnimationLeftHandEquippedContainers) == 0x0000F0, "Member 'FSBZAnimationsPerEquippablesContainer::AnimationLeftHandEquippedContainers' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAnimationsPerStancesContainer
// 0x0050 (0x0050 - 0x0000)
struct FSBZAnimationsPerStancesContainer final
{
public:
	TMap<ESBZEquippableFamily, struct FSBZAnimationsPerEquippablesContainer> AnimationContainersPerEquippables; // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAnimationsPerStancesContainer) == 0x000008, "Wrong alignment on FSBZAnimationsPerStancesContainer");
static_assert(sizeof(FSBZAnimationsPerStancesContainer) == 0x000050, "Wrong size on FSBZAnimationsPerStancesContainer");
static_assert(offsetof(FSBZAnimationsPerStancesContainer, AnimationContainersPerEquippables) == 0x000000, "Member 'FSBZAnimationsPerStancesContainer::AnimationContainersPerEquippables' has a wrong offset!");

// ScriptStruct Starbreeze.SBZChallengeRecommandationSlot
// 0x0028 (0x0028 - 0x0000)
struct FSBZChallengeRecommandationSlot final
{
public:
	TArray<class FString>                         MandatoryTags;                                     // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         ExcludedTags;                                      // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          CheckInfamyLevel;                                  // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZChallengeRecommandationsPriorityType      ChallengeRecommandationsPriorityType;              // 0x0021(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZChallengeRecommandationSlot) == 0x000008, "Wrong alignment on FSBZChallengeRecommandationSlot");
static_assert(sizeof(FSBZChallengeRecommandationSlot) == 0x000028, "Wrong size on FSBZChallengeRecommandationSlot");
static_assert(offsetof(FSBZChallengeRecommandationSlot, MandatoryTags) == 0x000000, "Member 'FSBZChallengeRecommandationSlot::MandatoryTags' has a wrong offset!");
static_assert(offsetof(FSBZChallengeRecommandationSlot, ExcludedTags) == 0x000010, "Member 'FSBZChallengeRecommandationSlot::ExcludedTags' has a wrong offset!");
static_assert(offsetof(FSBZChallengeRecommandationSlot, CheckInfamyLevel) == 0x000020, "Member 'FSBZChallengeRecommandationSlot::CheckInfamyLevel' has a wrong offset!");
static_assert(offsetof(FSBZChallengeRecommandationSlot, ChallengeRecommandationsPriorityType) == 0x000021, "Member 'FSBZChallengeRecommandationSlot::ChallengeRecommandationsPriorityType' has a wrong offset!");

// ScriptStruct Starbreeze.SBZChallengeRecommandationBlock
// 0x0020 (0x0020 - 0x0000)
struct FSBZChallengeRecommandationBlock final
{
public:
	class FString                                 ScreenName;                                        // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSBZChallengeRecommandationSlot> SlotArray;                                        // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZChallengeRecommandationBlock) == 0x000008, "Wrong alignment on FSBZChallengeRecommandationBlock");
static_assert(sizeof(FSBZChallengeRecommandationBlock) == 0x000020, "Wrong size on FSBZChallengeRecommandationBlock");
static_assert(offsetof(FSBZChallengeRecommandationBlock, ScreenName) == 0x000000, "Member 'FSBZChallengeRecommandationBlock::ScreenName' has a wrong offset!");
static_assert(offsetof(FSBZChallengeRecommandationBlock, SlotArray) == 0x000010, "Member 'FSBZChallengeRecommandationBlock::SlotArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPawnSpawnDefinition
// 0x0040 (0x0040 - 0x0000)
struct FSBZPawnSpawnDefinition final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   NameType;                                          // 0x0030(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZPawnSpawnDefinition) == 0x000010, "Wrong alignment on FSBZPawnSpawnDefinition");
static_assert(sizeof(FSBZPawnSpawnDefinition) == 0x000040, "Wrong size on FSBZPawnSpawnDefinition");
static_assert(offsetof(FSBZPawnSpawnDefinition, Transform) == 0x000000, "Member 'FSBZPawnSpawnDefinition::Transform' has a wrong offset!");
static_assert(offsetof(FSBZPawnSpawnDefinition, NameType) == 0x000030, "Member 'FSBZPawnSpawnDefinition::NameType' has a wrong offset!");

// ScriptStruct Starbreeze.SBZStandardImpactData
// 0x0018 (0x0040 - 0x0028)
struct FSBZStandardImpactData : public FSBZBaseImpactData
{
public:
	struct FFloatInterval                         DecalScale;                                        // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalDepth;                                        // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalMaxStretchCosAngle;                           // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         DecalMaxStretchScaler;                             // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZStandardImpactData) == 0x000008, "Wrong alignment on FSBZStandardImpactData");
static_assert(sizeof(FSBZStandardImpactData) == 0x000040, "Wrong size on FSBZStandardImpactData");
static_assert(offsetof(FSBZStandardImpactData, DecalScale) == 0x000028, "Member 'FSBZStandardImpactData::DecalScale' has a wrong offset!");
static_assert(offsetof(FSBZStandardImpactData, DecalDepth) == 0x000030, "Member 'FSBZStandardImpactData::DecalDepth' has a wrong offset!");
static_assert(offsetof(FSBZStandardImpactData, DecalMaxStretchCosAngle) == 0x000034, "Member 'FSBZStandardImpactData::DecalMaxStretchCosAngle' has a wrong offset!");
static_assert(offsetof(FSBZStandardImpactData, DecalMaxStretchScaler) == 0x000038, "Member 'FSBZStandardImpactData::DecalMaxStretchScaler' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPlaceToolTargetData
// 0x0038 (0x0040 - 0x0008)
struct alignas(0x10) FSBZPlaceToolTargetData final : public FGameplayAbilityTargetData
{
public:
	class UPrimitiveComponent*                    AttachParent;                                      // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10[0x30];                                      // 0x0010(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZPlaceToolTargetData) == 0x000010, "Wrong alignment on FSBZPlaceToolTargetData");
static_assert(sizeof(FSBZPlaceToolTargetData) == 0x000040, "Wrong size on FSBZPlaceToolTargetData");
static_assert(offsetof(FSBZPlaceToolTargetData, AttachParent) == 0x000008, "Member 'FSBZPlaceToolTargetData::AttachParent' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAnimationContainerCopy
// 0x0001 (0x0001 - 0x0000)
struct FSBZAnimationContainerCopy final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAnimationContainerCopy) == 0x000001, "Wrong alignment on FSBZAnimationContainerCopy");
static_assert(sizeof(FSBZAnimationContainerCopy) == 0x000001, "Wrong size on FSBZAnimationContainerCopy");

// ScriptStruct Starbreeze.SBZCheckInteractableScreenInputData
// 0x0038 (0x0038 - 0x0000)
struct FSBZCheckInteractableScreenInputData final
{
public:
	class USBZInteractorComponent*                Interactor;                                        // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZAgentManager*                       AgentManager;                                      // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x28];                                      // 0x0010(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZCheckInteractableScreenInputData) == 0x000008, "Wrong alignment on FSBZCheckInteractableScreenInputData");
static_assert(sizeof(FSBZCheckInteractableScreenInputData) == 0x000038, "Wrong size on FSBZCheckInteractableScreenInputData");
static_assert(offsetof(FSBZCheckInteractableScreenInputData, Interactor) == 0x000000, "Member 'FSBZCheckInteractableScreenInputData::Interactor' has a wrong offset!");
static_assert(offsetof(FSBZCheckInteractableScreenInputData, AgentManager) == 0x000008, "Member 'FSBZCheckInteractableScreenInputData::AgentManager' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPlaceItemTargetData
// 0x0020 (0x0028 - 0x0008)
struct FSBZPlaceItemTargetData final : public FGameplayAbilityTargetData
{
public:
	uint8                                         Pad_8[0x20];                                       // 0x0008(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZPlaceItemTargetData) == 0x000008, "Wrong alignment on FSBZPlaceItemTargetData");
static_assert(sizeof(FSBZPlaceItemTargetData) == 0x000028, "Wrong size on FSBZPlaceItemTargetData");

// ScriptStruct Starbreeze.SBZInteractableModeData
// 0x00A0 (0x00A0 - 0x0000)
struct FSBZInteractableModeData final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInputConsumed;                                  // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDistanceBreaksInteraction;                        // 0x001D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAllowedInCasing;                                // 0x001E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSignalInteract;                                 // 0x001F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsIllegal;                                        // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEncumberedAllowed;                              // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDistanceCheck2D;                                // 0x0022(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x1];                                       // 0x0023(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AnimationName;                                     // 0x0028(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USBZAnimatedInteractionData*            AnimatedInteractionData;                           // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseOverriddenShapes;                              // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSBZComponentSelector>          OverriddenShapes;                                  // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          OnStart2DAudioEvent;                               // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          OnStart3DAudioEvent;                               // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          OnFinish2DAudioEvent;                              // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          OnFinish3DAudioEvent;                              // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          OnCancel2DAudioEvent;                              // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          OnCancel3DAudioEvent;                              // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZVoiceCommentDataAsset*              StartComment;                                      // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZVoiceCommentDataAsset*              CompletedComment;                                  // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZVoiceCommentDataAsset*              CancelComment;                                     // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZInteractableModeData) == 0x000008, "Wrong alignment on FSBZInteractableModeData");
static_assert(sizeof(FSBZInteractableModeData) == 0x0000A0, "Wrong size on FSBZInteractableModeData");
static_assert(offsetof(FSBZInteractableModeData, Text) == 0x000000, "Member 'FSBZInteractableModeData::Text' has a wrong offset!");
static_assert(offsetof(FSBZInteractableModeData, Duration) == 0x000018, "Member 'FSBZInteractableModeData::Duration' has a wrong offset!");
static_assert(offsetof(FSBZInteractableModeData, bIsInputConsumed) == 0x00001C, "Member 'FSBZInteractableModeData::bIsInputConsumed' has a wrong offset!");
static_assert(offsetof(FSBZInteractableModeData, bDistanceBreaksInteraction) == 0x00001D, "Member 'FSBZInteractableModeData::bDistanceBreaksInteraction' has a wrong offset!");
static_assert(offsetof(FSBZInteractableModeData, bIsAllowedInCasing) == 0x00001E, "Member 'FSBZInteractableModeData::bIsAllowedInCasing' has a wrong offset!");
static_assert(offsetof(FSBZInteractableModeData, bIsSignalInteract) == 0x00001F, "Member 'FSBZInteractableModeData::bIsSignalInteract' has a wrong offset!");
static_assert(offsetof(FSBZInteractableModeData, bIsIllegal) == 0x000020, "Member 'FSBZInteractableModeData::bIsIllegal' has a wrong offset!");
static_assert(offsetof(FSBZInteractableModeData, bIsEncumberedAllowed) == 0x000021, "Member 'FSBZInteractableModeData::bIsEncumberedAllowed' has a wrong offset!");
static_assert(offsetof(FSBZInteractableModeData, bIsDistanceCheck2D) == 0x000022, "Member 'FSBZInteractableModeData::bIsDistanceCheck2D' has a wrong offset!");
static_assert(offsetof(FSBZInteractableModeData, Priority) == 0x000024, "Member 'FSBZInteractableModeData::Priority' has a wrong offset!");
static_assert(offsetof(FSBZInteractableModeData, AnimationName) == 0x000028, "Member 'FSBZInteractableModeData::AnimationName' has a wrong offset!");
static_assert(offsetof(FSBZInteractableModeData, AnimatedInteractionData) == 0x000038, "Member 'FSBZInteractableModeData::AnimatedInteractionData' has a wrong offset!");
static_assert(offsetof(FSBZInteractableModeData, bUseOverriddenShapes) == 0x000040, "Member 'FSBZInteractableModeData::bUseOverriddenShapes' has a wrong offset!");
static_assert(offsetof(FSBZInteractableModeData, OverriddenShapes) == 0x000048, "Member 'FSBZInteractableModeData::OverriddenShapes' has a wrong offset!");
static_assert(offsetof(FSBZInteractableModeData, OnStart2DAudioEvent) == 0x000058, "Member 'FSBZInteractableModeData::OnStart2DAudioEvent' has a wrong offset!");
static_assert(offsetof(FSBZInteractableModeData, OnStart3DAudioEvent) == 0x000060, "Member 'FSBZInteractableModeData::OnStart3DAudioEvent' has a wrong offset!");
static_assert(offsetof(FSBZInteractableModeData, OnFinish2DAudioEvent) == 0x000068, "Member 'FSBZInteractableModeData::OnFinish2DAudioEvent' has a wrong offset!");
static_assert(offsetof(FSBZInteractableModeData, OnFinish3DAudioEvent) == 0x000070, "Member 'FSBZInteractableModeData::OnFinish3DAudioEvent' has a wrong offset!");
static_assert(offsetof(FSBZInteractableModeData, OnCancel2DAudioEvent) == 0x000078, "Member 'FSBZInteractableModeData::OnCancel2DAudioEvent' has a wrong offset!");
static_assert(offsetof(FSBZInteractableModeData, OnCancel3DAudioEvent) == 0x000080, "Member 'FSBZInteractableModeData::OnCancel3DAudioEvent' has a wrong offset!");
static_assert(offsetof(FSBZInteractableModeData, StartComment) == 0x000088, "Member 'FSBZInteractableModeData::StartComment' has a wrong offset!");
static_assert(offsetof(FSBZInteractableModeData, CompletedComment) == 0x000090, "Member 'FSBZInteractableModeData::CompletedComment' has a wrong offset!");
static_assert(offsetof(FSBZInteractableModeData, CancelComment) == 0x000098, "Member 'FSBZInteractableModeData::CancelComment' has a wrong offset!");

// ScriptStruct Starbreeze.SBZItemRewardRequestEntry
// 0x0020 (0x0020 - 0x0000)
struct FSBZItemRewardRequestEntry final
{
public:
	ESBZRewardRequestType                         RewardRequestType;                                 // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AccelByteUserId;                                   // 0x0008(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerId;                                          // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZItemRewardRequestEntry) == 0x000008, "Wrong alignment on FSBZItemRewardRequestEntry");
static_assert(sizeof(FSBZItemRewardRequestEntry) == 0x000020, "Wrong size on FSBZItemRewardRequestEntry");
static_assert(offsetof(FSBZItemRewardRequestEntry, RewardRequestType) == 0x000000, "Member 'FSBZItemRewardRequestEntry::RewardRequestType' has a wrong offset!");
static_assert(offsetof(FSBZItemRewardRequestEntry, AccelByteUserId) == 0x000008, "Member 'FSBZItemRewardRequestEntry::AccelByteUserId' has a wrong offset!");
static_assert(offsetof(FSBZItemRewardRequestEntry, PlayerId) == 0x000018, "Member 'FSBZItemRewardRequestEntry::PlayerId' has a wrong offset!");

// ScriptStruct Starbreeze.SBZLifeTimeLensParticleHandle
// 0x0010 (0x0010 - 0x0000)
struct FSBZLifeTimeLensParticleHandle final
{
public:
	class UNiagaraComponent*                      ParticleEffect;                                    // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           TimerHandle;                                       // 0x0008(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZLifeTimeLensParticleHandle) == 0x000008, "Wrong alignment on FSBZLifeTimeLensParticleHandle");
static_assert(sizeof(FSBZLifeTimeLensParticleHandle) == 0x000010, "Wrong size on FSBZLifeTimeLensParticleHandle");
static_assert(offsetof(FSBZLifeTimeLensParticleHandle, ParticleEffect) == 0x000000, "Member 'FSBZLifeTimeLensParticleHandle::ParticleEffect' has a wrong offset!");
static_assert(offsetof(FSBZLifeTimeLensParticleHandle, TimerHandle) == 0x000008, "Member 'FSBZLifeTimeLensParticleHandle::TimerHandle' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCachedWeaponTargeting
// 0x0010 (0x0010 - 0x0000)
struct FSBZCachedWeaponTargeting final
{
public:
	class USBZWeaponSightData*                    SightData;                                         // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetingTransitionTime;                           // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZCachedWeaponTargeting) == 0x000008, "Wrong alignment on FSBZCachedWeaponTargeting");
static_assert(sizeof(FSBZCachedWeaponTargeting) == 0x000010, "Wrong size on FSBZCachedWeaponTargeting");
static_assert(offsetof(FSBZCachedWeaponTargeting, SightData) == 0x000000, "Member 'FSBZCachedWeaponTargeting::SightData' has a wrong offset!");
static_assert(offsetof(FSBZCachedWeaponTargeting, TargetingTransitionTime) == 0x000008, "Member 'FSBZCachedWeaponTargeting::TargetingTransitionTime' has a wrong offset!");

// ScriptStruct Starbreeze.SBZHoldOutDroneFogSettings
// 0x0008 (0x0008 - 0x0000)
struct FSBZHoldOutDroneFogSettings final
{
public:
	float                                         TargetFogDensity;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogTransitionSpeed;                                // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZHoldOutDroneFogSettings) == 0x000004, "Wrong alignment on FSBZHoldOutDroneFogSettings");
static_assert(sizeof(FSBZHoldOutDroneFogSettings) == 0x000008, "Wrong size on FSBZHoldOutDroneFogSettings");
static_assert(offsetof(FSBZHoldOutDroneFogSettings, TargetFogDensity) == 0x000000, "Member 'FSBZHoldOutDroneFogSettings::TargetFogDensity' has a wrong offset!");
static_assert(offsetof(FSBZHoldOutDroneFogSettings, FogTransitionSpeed) == 0x000004, "Member 'FSBZHoldOutDroneFogSettings::FogTransitionSpeed' has a wrong offset!");

// ScriptStruct Starbreeze.SBZProgressionFogMapping
// 0x000C (0x000C - 0x0000)
struct FSBZProgressionFogMapping final
{
public:
	struct FSBZHoldOutDroneFogSettings            FogSettings;                                       // 0x0000(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Progression;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZProgressionFogMapping) == 0x000004, "Wrong alignment on FSBZProgressionFogMapping");
static_assert(sizeof(FSBZProgressionFogMapping) == 0x00000C, "Wrong size on FSBZProgressionFogMapping");
static_assert(offsetof(FSBZProgressionFogMapping, FogSettings) == 0x000000, "Member 'FSBZProgressionFogMapping::FogSettings' has a wrong offset!");
static_assert(offsetof(FSBZProgressionFogMapping, Progression) == 0x000008, "Member 'FSBZProgressionFogMapping::Progression' has a wrong offset!");

// ScriptStruct Starbreeze.TLMVoiceSessionInfo
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FTLMVoiceSessionInfo final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTLMVoiceSessionInfo) == 0x000008, "Wrong alignment on FTLMVoiceSessionInfo");
static_assert(sizeof(FTLMVoiceSessionInfo) == 0x000020, "Wrong size on FTLMVoiceSessionInfo");

// ScriptStruct Starbreeze.SBZEventRequestContainer
// 0x0010 (0x0010 - 0x0000)
struct FSBZEventRequestContainer final
{
public:
	TArray<struct FSBZEventRequest>               EventRequests;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZEventRequestContainer) == 0x000008, "Wrong alignment on FSBZEventRequestContainer");
static_assert(sizeof(FSBZEventRequestContainer) == 0x000010, "Wrong size on FSBZEventRequestContainer");
static_assert(offsetof(FSBZEventRequestContainer, EventRequests) == 0x000000, "Member 'FSBZEventRequestContainer::EventRequests' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMissionInfo
// 0x0008 (0x0008 - 0x0000)
struct FSBZMissionInfo final
{
public:
	int32                                         LevelIdx;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DifficultyIdx;                                     // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZMissionInfo) == 0x000004, "Wrong alignment on FSBZMissionInfo");
static_assert(sizeof(FSBZMissionInfo) == 0x000008, "Wrong size on FSBZMissionInfo");
static_assert(offsetof(FSBZMissionInfo, LevelIdx) == 0x000000, "Member 'FSBZMissionInfo::LevelIdx' has a wrong offset!");
static_assert(offsetof(FSBZMissionInfo, DifficultyIdx) == 0x000004, "Member 'FSBZMissionInfo::DifficultyIdx' has a wrong offset!");

// ScriptStruct Starbreeze.SBZStoreItemUIData
// 0x0108 (0x0108 - 0x0000)
struct FSBZStoreItemUIData final
{
public:
	ESBZStoreItemUIIdSource                       StoreItemUIIdSource;                               // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ItemSku;                                           // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ExternalItemId;                                    // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZInventoryBaseData*                  InventoryItem;                                     // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSBZStoreBaseItem                      StoreItem;                                         // 0x0030(0x00D8)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZStoreItemUIData) == 0x000008, "Wrong alignment on FSBZStoreItemUIData");
static_assert(sizeof(FSBZStoreItemUIData) == 0x000108, "Wrong size on FSBZStoreItemUIData");
static_assert(offsetof(FSBZStoreItemUIData, StoreItemUIIdSource) == 0x000000, "Member 'FSBZStoreItemUIData::StoreItemUIIdSource' has a wrong offset!");
static_assert(offsetof(FSBZStoreItemUIData, ItemSku) == 0x000008, "Member 'FSBZStoreItemUIData::ItemSku' has a wrong offset!");
static_assert(offsetof(FSBZStoreItemUIData, ExternalItemId) == 0x000018, "Member 'FSBZStoreItemUIData::ExternalItemId' has a wrong offset!");
static_assert(offsetof(FSBZStoreItemUIData, InventoryItem) == 0x000028, "Member 'FSBZStoreItemUIData::InventoryItem' has a wrong offset!");
static_assert(offsetof(FSBZStoreItemUIData, StoreItem) == 0x000030, "Member 'FSBZStoreItemUIData::StoreItem' has a wrong offset!");

// ScriptStruct Starbreeze.SBZStoreItemUIGroup
// 0x0020 (0x0020 - 0x0000)
struct FSBZStoreItemUIGroup final
{
public:
	struct FSBZStoreItemUICategory                ItemCategory;                                      // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FSBZStoreItemUIData>            CategoryItems;                                     // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZStoreItemUIGroup) == 0x000008, "Wrong alignment on FSBZStoreItemUIGroup");
static_assert(sizeof(FSBZStoreItemUIGroup) == 0x000020, "Wrong size on FSBZStoreItemUIGroup");
static_assert(offsetof(FSBZStoreItemUIGroup, ItemCategory) == 0x000000, "Member 'FSBZStoreItemUIGroup::ItemCategory' has a wrong offset!");
static_assert(offsetof(FSBZStoreItemUIGroup, CategoryItems) == 0x000010, "Member 'FSBZStoreItemUIGroup::CategoryItems' has a wrong offset!");

// ScriptStruct Starbreeze.SBZBlackMarketUIVendorData
// 0x0020 (0x0020 - 0x0000)
struct FSBZBlackMarketUIVendorData final
{
public:
	class USBZVendorData*                         VendorData;                                        // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSBZStoreItemUIGroup>           UIStoreItemArray;                                  // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bHasFetchedStoreData;                              // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZBlackMarketUIVendorData) == 0x000008, "Wrong alignment on FSBZBlackMarketUIVendorData");
static_assert(sizeof(FSBZBlackMarketUIVendorData) == 0x000020, "Wrong size on FSBZBlackMarketUIVendorData");
static_assert(offsetof(FSBZBlackMarketUIVendorData, VendorData) == 0x000000, "Member 'FSBZBlackMarketUIVendorData::VendorData' has a wrong offset!");
static_assert(offsetof(FSBZBlackMarketUIVendorData, UIStoreItemArray) == 0x000008, "Member 'FSBZBlackMarketUIVendorData::UIStoreItemArray' has a wrong offset!");
static_assert(offsetof(FSBZBlackMarketUIVendorData, bHasFetchedStoreData) == 0x000018, "Member 'FSBZBlackMarketUIVendorData::bHasFetchedStoreData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZLocalPlayerFeedbackInfo
// 0x0010 (0x0010 - 0x0000)
struct FSBZLocalPlayerFeedbackInfo final
{
public:
	class USBZLocalPlayerFeedback*                PlayerFeedback;                                    // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ID;                                                // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZLocalPlayerFeedbackInfo) == 0x000008, "Wrong alignment on FSBZLocalPlayerFeedbackInfo");
static_assert(sizeof(FSBZLocalPlayerFeedbackInfo) == 0x000010, "Wrong size on FSBZLocalPlayerFeedbackInfo");
static_assert(offsetof(FSBZLocalPlayerFeedbackInfo, PlayerFeedback) == 0x000000, "Member 'FSBZLocalPlayerFeedbackInfo::PlayerFeedback' has a wrong offset!");
static_assert(offsetof(FSBZLocalPlayerFeedbackInfo, ID) == 0x000008, "Member 'FSBZLocalPlayerFeedbackInfo::ID' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInputActionKeyboardBinding
// 0x0050 (0x0050 - 0x0000)
struct FSBZInputActionKeyboardBinding final
{
public:
	class FName                                   ActionName;                                        // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   KeyPrimary;                                        // 0x0010(0x0020)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   KeySecondary;                                      // 0x0030(0x0020)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZInputActionKeyboardBinding) == 0x000008, "Wrong alignment on FSBZInputActionKeyboardBinding");
static_assert(sizeof(FSBZInputActionKeyboardBinding) == 0x000050, "Wrong size on FSBZInputActionKeyboardBinding");
static_assert(offsetof(FSBZInputActionKeyboardBinding, ActionName) == 0x000000, "Member 'FSBZInputActionKeyboardBinding::ActionName' has a wrong offset!");
static_assert(offsetof(FSBZInputActionKeyboardBinding, KeyPrimary) == 0x000010, "Member 'FSBZInputActionKeyboardBinding::KeyPrimary' has a wrong offset!");
static_assert(offsetof(FSBZInputActionKeyboardBinding, KeySecondary) == 0x000030, "Member 'FSBZInputActionKeyboardBinding::KeySecondary' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInventoryItem
// 0x0018 (0x0018 - 0x0000)
struct FSBZInventoryItem
{
public:
	int32                                         UseCount;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZItemType                                  ItemType;                                          // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ItemSku;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZInventoryItem) == 0x000008, "Wrong alignment on FSBZInventoryItem");
static_assert(sizeof(FSBZInventoryItem) == 0x000018, "Wrong size on FSBZInventoryItem");
static_assert(offsetof(FSBZInventoryItem, UseCount) == 0x000000, "Member 'FSBZInventoryItem::UseCount' has a wrong offset!");
static_assert(offsetof(FSBZInventoryItem, ItemType) == 0x000004, "Member 'FSBZInventoryItem::ItemType' has a wrong offset!");
static_assert(offsetof(FSBZInventoryItem, ItemSku) == 0x000008, "Member 'FSBZInventoryItem::ItemSku' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSuitInventoryItem
// 0x0008 (0x0020 - 0x0018)
struct FSBZSuitInventoryItem final : public FSBZInventoryItem
{
public:
	class USBZSuitData*                           SuitData;                                          // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSuitInventoryItem) == 0x000008, "Wrong alignment on FSBZSuitInventoryItem");
static_assert(sizeof(FSBZSuitInventoryItem) == 0x000020, "Wrong size on FSBZSuitInventoryItem");
static_assert(offsetof(FSBZSuitInventoryItem, SuitData) == 0x000018, "Member 'FSBZSuitInventoryItem::SuitData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZBlockedPlayer
// 0x0010 (0x0010 - 0x0000)
struct FSBZBlockedPlayer final
{
public:
	class FString                                 AccelbyteUserId;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZBlockedPlayer) == 0x000008, "Wrong alignment on FSBZBlockedPlayer");
static_assert(sizeof(FSBZBlockedPlayer) == 0x000010, "Wrong size on FSBZBlockedPlayer");
static_assert(offsetof(FSBZBlockedPlayer, AccelbyteUserId) == 0x000000, "Member 'FSBZBlockedPlayer::AccelbyteUserId' has a wrong offset!");

// ScriptStruct Starbreeze.SBZBlockedPlayers
// 0x0020 (0x0020 - 0x0000)
struct FSBZBlockedPlayers final
{
public:
	class FString                                 Platform;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSBZBlockedPlayer>              BlockedPlayers;                                    // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZBlockedPlayers) == 0x000008, "Wrong alignment on FSBZBlockedPlayers");
static_assert(sizeof(FSBZBlockedPlayers) == 0x000020, "Wrong size on FSBZBlockedPlayers");
static_assert(offsetof(FSBZBlockedPlayers, Platform) == 0x000000, "Member 'FSBZBlockedPlayers::Platform' has a wrong offset!");
static_assert(offsetof(FSBZBlockedPlayers, BlockedPlayers) == 0x000010, "Member 'FSBZBlockedPlayers::BlockedPlayers' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPlatformsBlockedPlayersInfo
// 0x0010 (0x0010 - 0x0000)
struct FSBZPlatformsBlockedPlayersInfo final
{
public:
	TArray<struct FSBZBlockedPlayers>             PlatformBlockedPlayers;                            // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPlatformsBlockedPlayersInfo) == 0x000008, "Wrong alignment on FSBZPlatformsBlockedPlayersInfo");
static_assert(sizeof(FSBZPlatformsBlockedPlayersInfo) == 0x000010, "Wrong size on FSBZPlatformsBlockedPlayersInfo");
static_assert(offsetof(FSBZPlatformsBlockedPlayersInfo, PlatformBlockedPlayers) == 0x000000, "Member 'FSBZPlatformsBlockedPlayersInfo::PlatformBlockedPlayers' has a wrong offset!");

// ScriptStruct Starbreeze.SBZHumanShieldDirection
// 0x0020 (0x0020 - 0x0000)
struct FSBZHumanShieldDirection final
{
public:
	uint8                                         AllowedCategories;                                 // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumAngleAroundTarget;                          // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumAngleAroundTarget;                          // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Tag;                                               // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZHumanShieldDirection) == 0x000008, "Wrong alignment on FSBZHumanShieldDirection");
static_assert(sizeof(FSBZHumanShieldDirection) == 0x000020, "Wrong size on FSBZHumanShieldDirection");
static_assert(offsetof(FSBZHumanShieldDirection, AllowedCategories) == 0x000000, "Member 'FSBZHumanShieldDirection::AllowedCategories' has a wrong offset!");
static_assert(offsetof(FSBZHumanShieldDirection, MinimumAngleAroundTarget) == 0x000004, "Member 'FSBZHumanShieldDirection::MinimumAngleAroundTarget' has a wrong offset!");
static_assert(offsetof(FSBZHumanShieldDirection, MaximumAngleAroundTarget) == 0x000008, "Member 'FSBZHumanShieldDirection::MaximumAngleAroundTarget' has a wrong offset!");
static_assert(offsetof(FSBZHumanShieldDirection, Tag) == 0x000010, "Member 'FSBZHumanShieldDirection::Tag' has a wrong offset!");

// ScriptStruct Starbreeze.ChallengeLocalizationEntry
// 0x0050 (0x0050 - 0x0000)
struct FChallengeLocalizationEntry final
{
public:
	class FString                                 ChallengeId;                                       // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InternalName;                                      // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InternalDescription;                               // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InGameName;                                        // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InGameDescription;                                 // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChallengeLocalizationEntry) == 0x000008, "Wrong alignment on FChallengeLocalizationEntry");
static_assert(sizeof(FChallengeLocalizationEntry) == 0x000050, "Wrong size on FChallengeLocalizationEntry");
static_assert(offsetof(FChallengeLocalizationEntry, ChallengeId) == 0x000000, "Member 'FChallengeLocalizationEntry::ChallengeId' has a wrong offset!");
static_assert(offsetof(FChallengeLocalizationEntry, InternalName) == 0x000010, "Member 'FChallengeLocalizationEntry::InternalName' has a wrong offset!");
static_assert(offsetof(FChallengeLocalizationEntry, InternalDescription) == 0x000020, "Member 'FChallengeLocalizationEntry::InternalDescription' has a wrong offset!");
static_assert(offsetof(FChallengeLocalizationEntry, InGameName) == 0x000030, "Member 'FChallengeLocalizationEntry::InGameName' has a wrong offset!");
static_assert(offsetof(FChallengeLocalizationEntry, InGameDescription) == 0x000040, "Member 'FChallengeLocalizationEntry::InGameDescription' has a wrong offset!");

// ScriptStruct Starbreeze.SBZFactionInfo
// 0x0018 (0x0018 - 0x0000)
struct FSBZFactionInfo final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 PrimaryColor;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 SecondaryColor;                                    // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZFactionInfo) == 0x000008, "Wrong alignment on FSBZFactionInfo");
static_assert(sizeof(FSBZFactionInfo) == 0x000018, "Wrong size on FSBZFactionInfo");
static_assert(offsetof(FSBZFactionInfo, Name) == 0x000000, "Member 'FSBZFactionInfo::Name' has a wrong offset!");
static_assert(offsetof(FSBZFactionInfo, PrimaryColor) == 0x000010, "Member 'FSBZFactionInfo::PrimaryColor' has a wrong offset!");
static_assert(offsetof(FSBZFactionInfo, SecondaryColor) == 0x000014, "Member 'FSBZFactionInfo::SecondaryColor' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAttackTargetDifficultySettings
// 0x0010 (0x0010 - 0x0000)
struct FSBZAttackTargetDifficultySettings final
{
public:
	float                                         AttackTime;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomDeviation;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimTime;                                           // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LOSLostAdditionalAimTime;                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAttackTargetDifficultySettings) == 0x000004, "Wrong alignment on FSBZAttackTargetDifficultySettings");
static_assert(sizeof(FSBZAttackTargetDifficultySettings) == 0x000010, "Wrong size on FSBZAttackTargetDifficultySettings");
static_assert(offsetof(FSBZAttackTargetDifficultySettings, AttackTime) == 0x000000, "Member 'FSBZAttackTargetDifficultySettings::AttackTime' has a wrong offset!");
static_assert(offsetof(FSBZAttackTargetDifficultySettings, RandomDeviation) == 0x000004, "Member 'FSBZAttackTargetDifficultySettings::RandomDeviation' has a wrong offset!");
static_assert(offsetof(FSBZAttackTargetDifficultySettings, AimTime) == 0x000008, "Member 'FSBZAttackTargetDifficultySettings::AimTime' has a wrong offset!");
static_assert(offsetof(FSBZAttackTargetDifficultySettings, LOSLostAdditionalAimTime) == 0x00000C, "Member 'FSBZAttackTargetDifficultySettings::LOSLostAdditionalAimTime' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAIRepositionType
// 0x0058 (0x0058 - 0x0000)
struct FSBZAIRepositionType final
{
public:
	TSubclassOf<class USBZAIRepositionPredicate>  Predicate;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEQSParametrizedQueryExecutionRequest  EQSRequest;                                        // 0x0008(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAIRepositionType) == 0x000008, "Wrong alignment on FSBZAIRepositionType");
static_assert(sizeof(FSBZAIRepositionType) == 0x000058, "Wrong size on FSBZAIRepositionType");
static_assert(offsetof(FSBZAIRepositionType, Predicate) == 0x000000, "Member 'FSBZAIRepositionType::Predicate' has a wrong offset!");
static_assert(offsetof(FSBZAIRepositionType, EQSRequest) == 0x000008, "Member 'FSBZAIRepositionType::EQSRequest' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWatchInventoryItem
// 0x0008 (0x0020 - 0x0018)
struct FSBZWatchInventoryItem final : public FSBZInventoryItem
{
public:
	class USBZWatchData*                          WatchData;                                         // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWatchInventoryItem) == 0x000008, "Wrong alignment on FSBZWatchInventoryItem");
static_assert(sizeof(FSBZWatchInventoryItem) == 0x000020, "Wrong size on FSBZWatchInventoryItem");
static_assert(offsetof(FSBZWatchInventoryItem, WatchData) == 0x000018, "Member 'FSBZWatchInventoryItem::WatchData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSabotageAnimationData
// 0x0010 (0x0010 - 0x0000)
struct FSBZSabotageAnimationData final
{
public:
	class UAnimMontage*                           AnimMontage;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         AcceptedHeights;                                   // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSabotageAnimationData) == 0x000008, "Wrong alignment on FSBZSabotageAnimationData");
static_assert(sizeof(FSBZSabotageAnimationData) == 0x000010, "Wrong size on FSBZSabotageAnimationData");
static_assert(offsetof(FSBZSabotageAnimationData, AnimMontage) == 0x000000, "Member 'FSBZSabotageAnimationData::AnimMontage' has a wrong offset!");
static_assert(offsetof(FSBZSabotageAnimationData, AcceptedHeights) == 0x000008, "Member 'FSBZSabotageAnimationData::AcceptedHeights' has a wrong offset!");

// ScriptStruct Starbreeze.SBZExplosivePhysicsEffectData
// 0x0010 (0x0010 - 0x0000)
struct FSBZExplosivePhysicsEffectData final
{
public:
	float                                         UpwardImpulse;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpwardImpulseAsVel;                               // 0x0004(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatInterval                         TorqueStrength;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZExplosivePhysicsEffectData) == 0x000004, "Wrong alignment on FSBZExplosivePhysicsEffectData");
static_assert(sizeof(FSBZExplosivePhysicsEffectData) == 0x000010, "Wrong size on FSBZExplosivePhysicsEffectData");
static_assert(offsetof(FSBZExplosivePhysicsEffectData, UpwardImpulse) == 0x000000, "Member 'FSBZExplosivePhysicsEffectData::UpwardImpulse' has a wrong offset!");
static_assert(offsetof(FSBZExplosivePhysicsEffectData, bUpwardImpulseAsVel) == 0x000004, "Member 'FSBZExplosivePhysicsEffectData::bUpwardImpulseAsVel' has a wrong offset!");
static_assert(offsetof(FSBZExplosivePhysicsEffectData, TorqueStrength) == 0x000008, "Member 'FSBZExplosivePhysicsEffectData::TorqueStrength' has a wrong offset!");

// ScriptStruct Starbreeze.SBZBuiltInAnimMontageValueTrack
// 0x0098 (0x0098 - 0x0000)
struct FSBZBuiltInAnimMontageValueTrack final
{
public:
	ESBZBuiltInAnimMontageTrackType               TrackType;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     Curve;                                             // 0x0008(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x0090(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZBuiltInAnimMontageValueTrack) == 0x000008, "Wrong alignment on FSBZBuiltInAnimMontageValueTrack");
static_assert(sizeof(FSBZBuiltInAnimMontageValueTrack) == 0x000098, "Wrong size on FSBZBuiltInAnimMontageValueTrack");
static_assert(offsetof(FSBZBuiltInAnimMontageValueTrack, TrackType) == 0x000000, "Member 'FSBZBuiltInAnimMontageValueTrack::TrackType' has a wrong offset!");
static_assert(offsetof(FSBZBuiltInAnimMontageValueTrack, Curve) == 0x000008, "Member 'FSBZBuiltInAnimMontageValueTrack::Curve' has a wrong offset!");
static_assert(offsetof(FSBZBuiltInAnimMontageValueTrack, PlayRate) == 0x000090, "Member 'FSBZBuiltInAnimMontageValueTrack::PlayRate' has a wrong offset!");

// ScriptStruct Starbreeze.SBZBuiltInAnimMontageBoneTrack
// 0x0020 (0x0020 - 0x0000)
struct FSBZBuiltInAnimMontageBoneTrack final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneModificationMode                         BoneModificationMode;                              // 0x000C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSBZBuiltInAnimMontageValueTrack> ValueTracks;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZBuiltInAnimMontageBoneTrack) == 0x000008, "Wrong alignment on FSBZBuiltInAnimMontageBoneTrack");
static_assert(sizeof(FSBZBuiltInAnimMontageBoneTrack) == 0x000020, "Wrong size on FSBZBuiltInAnimMontageBoneTrack");
static_assert(offsetof(FSBZBuiltInAnimMontageBoneTrack, BoneName) == 0x000000, "Member 'FSBZBuiltInAnimMontageBoneTrack::BoneName' has a wrong offset!");
static_assert(offsetof(FSBZBuiltInAnimMontageBoneTrack, BoneModificationMode) == 0x00000C, "Member 'FSBZBuiltInAnimMontageBoneTrack::BoneModificationMode' has a wrong offset!");
static_assert(offsetof(FSBZBuiltInAnimMontageBoneTrack, ValueTracks) == 0x000010, "Member 'FSBZBuiltInAnimMontageBoneTrack::ValueTracks' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCablePointAttachment
// 0x0068 (0x0068 - 0x0000)
struct FSBZCablePointAttachment final
{
public:
	int32                                         PointIndex;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0004(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FComponentReference                    AttachTo;                                          // 0x0010(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   AttachToSocketName;                                // 0x0040(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoUpdatePointIndex;                             // 0x004C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SegmentStretchFactor;                              // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRelativeToCableLength;                            // 0x0054(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoWinding;                                      // 0x0055(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopAutoWindingAtFirstLockedPoint;                // 0x0056(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_57[0x1];                                       // 0x0057(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WindingSpeed;                                      // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0xC];                                       // 0x005C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZCablePointAttachment) == 0x000008, "Wrong alignment on FSBZCablePointAttachment");
static_assert(sizeof(FSBZCablePointAttachment) == 0x000068, "Wrong size on FSBZCablePointAttachment");
static_assert(offsetof(FSBZCablePointAttachment, PointIndex) == 0x000000, "Member 'FSBZCablePointAttachment::PointIndex' has a wrong offset!");
static_assert(offsetof(FSBZCablePointAttachment, Location) == 0x000004, "Member 'FSBZCablePointAttachment::Location' has a wrong offset!");
static_assert(offsetof(FSBZCablePointAttachment, AttachTo) == 0x000010, "Member 'FSBZCablePointAttachment::AttachTo' has a wrong offset!");
static_assert(offsetof(FSBZCablePointAttachment, AttachToSocketName) == 0x000040, "Member 'FSBZCablePointAttachment::AttachToSocketName' has a wrong offset!");
static_assert(offsetof(FSBZCablePointAttachment, bAutoUpdatePointIndex) == 0x00004C, "Member 'FSBZCablePointAttachment::bAutoUpdatePointIndex' has a wrong offset!");
static_assert(offsetof(FSBZCablePointAttachment, SegmentStretchFactor) == 0x000050, "Member 'FSBZCablePointAttachment::SegmentStretchFactor' has a wrong offset!");
static_assert(offsetof(FSBZCablePointAttachment, bRelativeToCableLength) == 0x000054, "Member 'FSBZCablePointAttachment::bRelativeToCableLength' has a wrong offset!");
static_assert(offsetof(FSBZCablePointAttachment, bAutoWinding) == 0x000055, "Member 'FSBZCablePointAttachment::bAutoWinding' has a wrong offset!");
static_assert(offsetof(FSBZCablePointAttachment, bStopAutoWindingAtFirstLockedPoint) == 0x000056, "Member 'FSBZCablePointAttachment::bStopAutoWindingAtFirstLockedPoint' has a wrong offset!");
static_assert(offsetof(FSBZCablePointAttachment, WindingSpeed) == 0x000058, "Member 'FSBZCablePointAttachment::WindingSpeed' has a wrong offset!");

// ScriptStruct Starbreeze.SBZDLCReward
// 0x0020 (0x0020 - 0x0000)
struct FSBZDLCReward final
{
public:
	class FString                                 DLCName;                                           // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         EntitlementArray;                                  // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZDLCReward) == 0x000008, "Wrong alignment on FSBZDLCReward");
static_assert(sizeof(FSBZDLCReward) == 0x000020, "Wrong size on FSBZDLCReward");
static_assert(offsetof(FSBZDLCReward, DLCName) == 0x000000, "Member 'FSBZDLCReward::DLCName' has a wrong offset!");
static_assert(offsetof(FSBZDLCReward, EntitlementArray) == 0x000010, "Member 'FSBZDLCReward::EntitlementArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCableCollisionPlane
// 0x0020 (0x0020 - 0x0000)
struct FSBZCableCollisionPlane final
{
public:
	struct FPlane                                 Plane;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideFriction;                                 // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Friction;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZCableCollisionPlane) == 0x000010, "Wrong alignment on FSBZCableCollisionPlane");
static_assert(sizeof(FSBZCableCollisionPlane) == 0x000020, "Wrong size on FSBZCableCollisionPlane");
static_assert(offsetof(FSBZCableCollisionPlane, Plane) == 0x000000, "Member 'FSBZCableCollisionPlane::Plane' has a wrong offset!");
static_assert(offsetof(FSBZCableCollisionPlane, bOverrideFriction) == 0x000010, "Member 'FSBZCableCollisionPlane::bOverrideFriction' has a wrong offset!");
static_assert(offsetof(FSBZCableCollisionPlane, Friction) == 0x000014, "Member 'FSBZCableCollisionPlane::Friction' has a wrong offset!");

// ScriptStruct Starbreeze.SBZDebugSelection
// 0x0018 (0x0018 - 0x0000)
struct FSBZDebugSelection final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0008(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DepthStencil;                                      // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZDebugSelection) == 0x000008, "Wrong alignment on FSBZDebugSelection");
static_assert(sizeof(FSBZDebugSelection) == 0x000018, "Wrong size on FSBZDebugSelection");
static_assert(offsetof(FSBZDebugSelection, Object) == 0x000000, "Member 'FSBZDebugSelection::Object' has a wrong offset!");
static_assert(offsetof(FSBZDebugSelection, SocketName) == 0x000008, "Member 'FSBZDebugSelection::SocketName' has a wrong offset!");
static_assert(offsetof(FSBZDebugSelection, DepthStencil) == 0x000014, "Member 'FSBZDebugSelection::DepthStencil' has a wrong offset!");

// ScriptStruct Starbreeze.SBZVariationDataIndexTracker
// 0x0014 (0x0014 - 0x0000)
struct FSBZVariationDataIndexTracker final
{
public:
	TWeakObjectPtr<class USBZVariationSetData>    VariationData;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0xC];                                        // 0x0008(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZVariationDataIndexTracker) == 0x000004, "Wrong alignment on FSBZVariationDataIndexTracker");
static_assert(sizeof(FSBZVariationDataIndexTracker) == 0x000014, "Wrong size on FSBZVariationDataIndexTracker");
static_assert(offsetof(FSBZVariationDataIndexTracker, VariationData) == 0x000000, "Member 'FSBZVariationDataIndexTracker::VariationData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZVariationSeedGenerator
// 0x0010 (0x0010 - 0x0000)
struct FSBZVariationSeedGenerator final
{
public:
	TArray<struct FSBZVariationDataIndexTracker>  VariationDataIndexTrackers;                        // 0x0000(0x0010)(Edit, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FSBZVariationSeedGenerator) == 0x000008, "Wrong alignment on FSBZVariationSeedGenerator");
static_assert(sizeof(FSBZVariationSeedGenerator) == 0x000010, "Wrong size on FSBZVariationSeedGenerator");
static_assert(offsetof(FSBZVariationSeedGenerator, VariationDataIndexTrackers) == 0x000000, "Member 'FSBZVariationSeedGenerator::VariationDataIndexTrackers' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCameraViewRestrictionHandle
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FSBZCameraViewRestrictionHandle final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZCameraViewRestrictionHandle) == 0x000004, "Wrong alignment on FSBZCameraViewRestrictionHandle");
static_assert(sizeof(FSBZCameraViewRestrictionHandle) == 0x000004, "Wrong size on FSBZCameraViewRestrictionHandle");

// ScriptStruct Starbreeze.SBZCapsuleShadowingSettings
// 0x001C (0x001C - 0x0000)
struct FSBZCapsuleShadowingSettings final
{
public:
	int32                                         Quality;                                           // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleIndirectShadowMinVisibility;                // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdateInterval;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         DistanceInterval;                                  // 0x000C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         ZDeactivationInterval;                             // 0x0014(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZCapsuleShadowingSettings) == 0x000004, "Wrong alignment on FSBZCapsuleShadowingSettings");
static_assert(sizeof(FSBZCapsuleShadowingSettings) == 0x00001C, "Wrong size on FSBZCapsuleShadowingSettings");
static_assert(offsetof(FSBZCapsuleShadowingSettings, Quality) == 0x000000, "Member 'FSBZCapsuleShadowingSettings::Quality' has a wrong offset!");
static_assert(offsetof(FSBZCapsuleShadowingSettings, CapsuleIndirectShadowMinVisibility) == 0x000004, "Member 'FSBZCapsuleShadowingSettings::CapsuleIndirectShadowMinVisibility' has a wrong offset!");
static_assert(offsetof(FSBZCapsuleShadowingSettings, UpdateInterval) == 0x000008, "Member 'FSBZCapsuleShadowingSettings::UpdateInterval' has a wrong offset!");
static_assert(offsetof(FSBZCapsuleShadowingSettings, DistanceInterval) == 0x00000C, "Member 'FSBZCapsuleShadowingSettings::DistanceInterval' has a wrong offset!");
static_assert(offsetof(FSBZCapsuleShadowingSettings, ZDeactivationInterval) == 0x000014, "Member 'FSBZCapsuleShadowingSettings::ZDeactivationInterval' has a wrong offset!");

// ScriptStruct Starbreeze.SBZHumanShieldSlotParameters
// 0x0010 (0x0010 - 0x0000)
struct FSBZHumanShieldSlotParameters final
{
public:
	ESBZHumanShieldEnterType                      HumanShieldEnterType;                              // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Offset;                                            // 0x0004(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZHumanShieldSlotParameters) == 0x000004, "Wrong alignment on FSBZHumanShieldSlotParameters");
static_assert(sizeof(FSBZHumanShieldSlotParameters) == 0x000010, "Wrong size on FSBZHumanShieldSlotParameters");
static_assert(offsetof(FSBZHumanShieldSlotParameters, HumanShieldEnterType) == 0x000000, "Member 'FSBZHumanShieldSlotParameters::HumanShieldEnterType' has a wrong offset!");
static_assert(offsetof(FSBZHumanShieldSlotParameters, Offset) == 0x000004, "Member 'FSBZHumanShieldSlotParameters::Offset' has a wrong offset!");

// ScriptStruct Starbreeze.SBZDailyChallenges
// 0x0010 (0x0010 - 0x0000)
struct FSBZDailyChallenges final
{
public:
	TArray<struct FSBZChallengeData>              DailyChallengeData;                                // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZDailyChallenges) == 0x000008, "Wrong alignment on FSBZDailyChallenges");
static_assert(sizeof(FSBZDailyChallenges) == 0x000010, "Wrong size on FSBZDailyChallenges");
static_assert(offsetof(FSBZDailyChallenges, DailyChallengeData) == 0x000000, "Member 'FSBZDailyChallenges::DailyChallengeData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZGameInfo
// 0x0038 (0x0038 - 0x0000)
struct FSBZGameInfo final
{
public:
	int32                                         Changelist;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DateTime;                                          // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Platform;                                          // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Address;                                           // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZGameInfo) == 0x000008, "Wrong alignment on FSBZGameInfo");
static_assert(sizeof(FSBZGameInfo) == 0x000038, "Wrong size on FSBZGameInfo");
static_assert(offsetof(FSBZGameInfo, Changelist) == 0x000000, "Member 'FSBZGameInfo::Changelist' has a wrong offset!");
static_assert(offsetof(FSBZGameInfo, DateTime) == 0x000008, "Member 'FSBZGameInfo::DateTime' has a wrong offset!");
static_assert(offsetof(FSBZGameInfo, Platform) == 0x000018, "Member 'FSBZGameInfo::Platform' has a wrong offset!");
static_assert(offsetof(FSBZGameInfo, Address) == 0x000028, "Member 'FSBZGameInfo::Address' has a wrong offset!");

// ScriptStruct Starbreeze.SBZRecommendedChallenges
// 0x0010 (0x0010 - 0x0000)
struct FSBZRecommendedChallenges final
{
public:
	TArray<struct FSBZChallengeData>              RecommendedChallengeData;                          // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZRecommendedChallenges) == 0x000008, "Wrong alignment on FSBZRecommendedChallenges");
static_assert(sizeof(FSBZRecommendedChallenges) == 0x000010, "Wrong size on FSBZRecommendedChallenges");
static_assert(offsetof(FSBZRecommendedChallenges, RecommendedChallengeData) == 0x000000, "Member 'FSBZRecommendedChallenges::RecommendedChallengeData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInternalChallengeStat
// 0x0018 (0x0018 - 0x0000)
struct FSBZInternalChallengeStat final
{
public:
	class FString                                 StatCode;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZInternalChallengeStat) == 0x000008, "Wrong alignment on FSBZInternalChallengeStat");
static_assert(sizeof(FSBZInternalChallengeStat) == 0x000018, "Wrong size on FSBZInternalChallengeStat");
static_assert(offsetof(FSBZInternalChallengeStat, StatCode) == 0x000000, "Member 'FSBZInternalChallengeStat::StatCode' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeStat, Value) == 0x000010, "Member 'FSBZInternalChallengeStat::Value' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInternalItemDetails
// 0x0018 (0x0018 - 0x0000)
struct FSBZInternalItemDetails final
{
public:
	class FString                                 ItemSku;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZInternalItemDetails) == 0x000008, "Wrong alignment on FSBZInternalItemDetails");
static_assert(sizeof(FSBZInternalItemDetails) == 0x000018, "Wrong size on FSBZInternalItemDetails");
static_assert(offsetof(FSBZInternalItemDetails, ItemSku) == 0x000000, "Member 'FSBZInternalItemDetails::ItemSku' has a wrong offset!");
static_assert(offsetof(FSBZInternalItemDetails, Quantity) == 0x000010, "Member 'FSBZInternalItemDetails::Quantity' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInternalChallengePrerequisites
// 0x0030 (0x0030 - 0x0000)
struct FSBZInternalChallengePrerequisites final
{
public:
	TArray<class FString>                         CompletedChallengeIds;                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSBZInternalChallengeStat>      Stats;                                             // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSBZInternalItemDetails>        Items;                                             // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZInternalChallengePrerequisites) == 0x000008, "Wrong alignment on FSBZInternalChallengePrerequisites");
static_assert(sizeof(FSBZInternalChallengePrerequisites) == 0x000030, "Wrong size on FSBZInternalChallengePrerequisites");
static_assert(offsetof(FSBZInternalChallengePrerequisites, CompletedChallengeIds) == 0x000000, "Member 'FSBZInternalChallengePrerequisites::CompletedChallengeIds' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengePrerequisites, Stats) == 0x000010, "Member 'FSBZInternalChallengePrerequisites::Stats' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengePrerequisites, Items) == 0x000020, "Member 'FSBZInternalChallengePrerequisites::Items' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInternalChallengeObjectives
// 0x0010 (0x0010 - 0x0000)
struct FSBZInternalChallengeObjectives final
{
public:
	TArray<struct FSBZInternalChallengeStat>      Stats;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZInternalChallengeObjectives) == 0x000008, "Wrong alignment on FSBZInternalChallengeObjectives");
static_assert(sizeof(FSBZInternalChallengeObjectives) == 0x000010, "Wrong size on FSBZInternalChallengeObjectives");
static_assert(offsetof(FSBZInternalChallengeObjectives, Stats) == 0x000000, "Member 'FSBZInternalChallengeObjectives::Stats' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInternalRewardItemDetails
// 0x0028 (0x0028 - 0x0000)
struct FSBZInternalRewardItemDetails final
{
public:
	class FString                                 Sku;                                               // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemId;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsActive;                                          // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZInternalRewardItemDetails) == 0x000008, "Wrong alignment on FSBZInternalRewardItemDetails");
static_assert(sizeof(FSBZInternalRewardItemDetails) == 0x000028, "Wrong size on FSBZInternalRewardItemDetails");
static_assert(offsetof(FSBZInternalRewardItemDetails, Sku) == 0x000000, "Member 'FSBZInternalRewardItemDetails::Sku' has a wrong offset!");
static_assert(offsetof(FSBZInternalRewardItemDetails, ItemId) == 0x000010, "Member 'FSBZInternalRewardItemDetails::ItemId' has a wrong offset!");
static_assert(offsetof(FSBZInternalRewardItemDetails, Quantity) == 0x000020, "Member 'FSBZInternalRewardItemDetails::Quantity' has a wrong offset!");
static_assert(offsetof(FSBZInternalRewardItemDetails, IsActive) == 0x000024, "Member 'FSBZInternalRewardItemDetails::IsActive' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInternalChallengeReward
// 0x0030 (0x0030 - 0x0000)
struct FSBZInternalChallengeReward final
{
public:
	TArray<struct FSBZInternalChallengeStat>      Stats;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSBZInternalRewardItemDetails>  Items;                                             // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 RewardId;                                          // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZInternalChallengeReward) == 0x000008, "Wrong alignment on FSBZInternalChallengeReward");
static_assert(sizeof(FSBZInternalChallengeReward) == 0x000030, "Wrong size on FSBZInternalChallengeReward");
static_assert(offsetof(FSBZInternalChallengeReward, Stats) == 0x000000, "Member 'FSBZInternalChallengeReward::Stats' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeReward, Items) == 0x000010, "Member 'FSBZInternalChallengeReward::Items' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeReward, RewardId) == 0x000020, "Member 'FSBZInternalChallengeReward::RewardId' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInternalChallengeConfiguration
// 0x00E8 (0x00E8 - 0x0000)
struct FSBZInternalChallengeConfiguration final
{
public:
	class FString                                 ChallengeId;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Namespace;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CreatedAt;                                         // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UpdatedAt;                                         // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSBZInternalChallengePrerequisites     Prerequisite;                                      // 0x0060(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSBZInternalChallengeObjectives        Objective;                                         // 0x0090(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSBZInternalChallengeReward            Reward;                                            // 0x00A0(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FString>                         Tags;                                              // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsActive;                                          // 0x00E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OrderNo;                                           // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZInternalChallengeConfiguration) == 0x000008, "Wrong alignment on FSBZInternalChallengeConfiguration");
static_assert(sizeof(FSBZInternalChallengeConfiguration) == 0x0000E8, "Wrong size on FSBZInternalChallengeConfiguration");
static_assert(offsetof(FSBZInternalChallengeConfiguration, ChallengeId) == 0x000000, "Member 'FSBZInternalChallengeConfiguration::ChallengeId' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeConfiguration, Namespace) == 0x000010, "Member 'FSBZInternalChallengeConfiguration::Namespace' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeConfiguration, CreatedAt) == 0x000020, "Member 'FSBZInternalChallengeConfiguration::CreatedAt' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeConfiguration, UpdatedAt) == 0x000030, "Member 'FSBZInternalChallengeConfiguration::UpdatedAt' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeConfiguration, Name) == 0x000040, "Member 'FSBZInternalChallengeConfiguration::Name' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeConfiguration, Description) == 0x000050, "Member 'FSBZInternalChallengeConfiguration::Description' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeConfiguration, Prerequisite) == 0x000060, "Member 'FSBZInternalChallengeConfiguration::Prerequisite' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeConfiguration, Objective) == 0x000090, "Member 'FSBZInternalChallengeConfiguration::Objective' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeConfiguration, Reward) == 0x0000A0, "Member 'FSBZInternalChallengeConfiguration::Reward' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeConfiguration, Tags) == 0x0000D0, "Member 'FSBZInternalChallengeConfiguration::Tags' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeConfiguration, IsActive) == 0x0000E0, "Member 'FSBZInternalChallengeConfiguration::IsActive' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeConfiguration, OrderNo) == 0x0000E4, "Member 'FSBZInternalChallengeConfiguration::OrderNo' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInternalChallengeProgressStat
// 0x0018 (0x0018 - 0x0000)
struct FSBZInternalChallengeProgressStat final
{
public:
	class FString                                 StatCode;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentValue;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetValue;                                       // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZInternalChallengeProgressStat) == 0x000008, "Wrong alignment on FSBZInternalChallengeProgressStat");
static_assert(sizeof(FSBZInternalChallengeProgressStat) == 0x000018, "Wrong size on FSBZInternalChallengeProgressStat");
static_assert(offsetof(FSBZInternalChallengeProgressStat, StatCode) == 0x000000, "Member 'FSBZInternalChallengeProgressStat::StatCode' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeProgressStat, CurrentValue) == 0x000010, "Member 'FSBZInternalChallengeProgressStat::CurrentValue' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeProgressStat, TargetValue) == 0x000014, "Member 'FSBZInternalChallengeProgressStat::TargetValue' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInternalChallengeProgressItem
// 0x0018 (0x0018 - 0x0000)
struct FSBZInternalChallengeProgressItem final
{
public:
	class FString                                 ItemSku;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentQuantity;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetQuantity;                                    // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZInternalChallengeProgressItem) == 0x000008, "Wrong alignment on FSBZInternalChallengeProgressItem");
static_assert(sizeof(FSBZInternalChallengeProgressItem) == 0x000018, "Wrong size on FSBZInternalChallengeProgressItem");
static_assert(offsetof(FSBZInternalChallengeProgressItem, ItemSku) == 0x000000, "Member 'FSBZInternalChallengeProgressItem::ItemSku' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeProgressItem, CurrentQuantity) == 0x000010, "Member 'FSBZInternalChallengeProgressItem::CurrentQuantity' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeProgressItem, TargetQuantity) == 0x000014, "Member 'FSBZInternalChallengeProgressItem::TargetQuantity' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInternalChallengeProgressPrerequisite
// 0x0030 (0x0030 - 0x0000)
struct FSBZInternalChallengeProgressPrerequisite final
{
public:
	TArray<struct FSBZInternalChallengeProgressStat> Stats;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSBZInternalChallengeProgressItem> Items;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x10];                                      // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZInternalChallengeProgressPrerequisite) == 0x000008, "Wrong alignment on FSBZInternalChallengeProgressPrerequisite");
static_assert(sizeof(FSBZInternalChallengeProgressPrerequisite) == 0x000030, "Wrong size on FSBZInternalChallengeProgressPrerequisite");
static_assert(offsetof(FSBZInternalChallengeProgressPrerequisite, Stats) == 0x000000, "Member 'FSBZInternalChallengeProgressPrerequisite::Stats' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeProgressPrerequisite, Items) == 0x000010, "Member 'FSBZInternalChallengeProgressPrerequisite::Items' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInternalChallengeProgressObjective
// 0x0010 (0x0010 - 0x0000)
struct FSBZInternalChallengeProgressObjective final
{
public:
	TArray<struct FSBZInternalChallengeProgressStat> Stats;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZInternalChallengeProgressObjective) == 0x000008, "Wrong alignment on FSBZInternalChallengeProgressObjective");
static_assert(sizeof(FSBZInternalChallengeProgressObjective) == 0x000010, "Wrong size on FSBZInternalChallengeProgressObjective");
static_assert(offsetof(FSBZInternalChallengeProgressObjective, Stats) == 0x000000, "Member 'FSBZInternalChallengeProgressObjective::Stats' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInternalChallengeProgress
// 0x0040 (0x0040 - 0x0000)
struct FSBZInternalChallengeProgress final
{
public:
	struct FSBZInternalChallengeProgressPrerequisite Prerequisite;                                   // 0x0000(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSBZInternalChallengeProgressObjective Objective;                                         // 0x0030(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZInternalChallengeProgress) == 0x000008, "Wrong alignment on FSBZInternalChallengeProgress");
static_assert(sizeof(FSBZInternalChallengeProgress) == 0x000040, "Wrong size on FSBZInternalChallengeProgress");
static_assert(offsetof(FSBZInternalChallengeProgress, Prerequisite) == 0x000000, "Member 'FSBZInternalChallengeProgress::Prerequisite' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeProgress, Objective) == 0x000030, "Member 'FSBZInternalChallengeProgress::Objective' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInternalUserChallengeRecord
// 0x0170 (0x0170 - 0x0000)
struct FSBZInternalUserChallengeRecord final
{
public:
	class FString                                 RecordId;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UserId;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSBZInternalChallengeConfiguration     Challenge;                                         // 0x0020(0x00E8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSBZInternalChallengeProgress          Progress;                                          // 0x0108(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 UpdatedAt;                                         // 0x0148(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EChallengeStatus                              Status;                                            // 0x0158(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsActive;                                          // 0x0159(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15A[0x6];                                      // 0x015A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Namespace;                                         // 0x0160(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZInternalUserChallengeRecord) == 0x000008, "Wrong alignment on FSBZInternalUserChallengeRecord");
static_assert(sizeof(FSBZInternalUserChallengeRecord) == 0x000170, "Wrong size on FSBZInternalUserChallengeRecord");
static_assert(offsetof(FSBZInternalUserChallengeRecord, RecordId) == 0x000000, "Member 'FSBZInternalUserChallengeRecord::RecordId' has a wrong offset!");
static_assert(offsetof(FSBZInternalUserChallengeRecord, UserId) == 0x000010, "Member 'FSBZInternalUserChallengeRecord::UserId' has a wrong offset!");
static_assert(offsetof(FSBZInternalUserChallengeRecord, Challenge) == 0x000020, "Member 'FSBZInternalUserChallengeRecord::Challenge' has a wrong offset!");
static_assert(offsetof(FSBZInternalUserChallengeRecord, Progress) == 0x000108, "Member 'FSBZInternalUserChallengeRecord::Progress' has a wrong offset!");
static_assert(offsetof(FSBZInternalUserChallengeRecord, UpdatedAt) == 0x000148, "Member 'FSBZInternalUserChallengeRecord::UpdatedAt' has a wrong offset!");
static_assert(offsetof(FSBZInternalUserChallengeRecord, Status) == 0x000158, "Member 'FSBZInternalUserChallengeRecord::Status' has a wrong offset!");
static_assert(offsetof(FSBZInternalUserChallengeRecord, IsActive) == 0x000159, "Member 'FSBZInternalUserChallengeRecord::IsActive' has a wrong offset!");
static_assert(offsetof(FSBZInternalUserChallengeRecord, Namespace) == 0x000160, "Member 'FSBZInternalUserChallengeRecord::Namespace' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMatchmakingAndHostingData
// 0x0050 (0x0050 - 0x0000)
struct FSBZMatchmakingAndHostingData final
{
public:
	class FString                                 MatchmakingProvider;                               // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HostingProvider;                                   // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MatchmakerURL;                                     // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MatchmakerToken;                                   // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BeaconsKey;                                        // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZMatchmakingAndHostingData) == 0x000008, "Wrong alignment on FSBZMatchmakingAndHostingData");
static_assert(sizeof(FSBZMatchmakingAndHostingData) == 0x000050, "Wrong size on FSBZMatchmakingAndHostingData");
static_assert(offsetof(FSBZMatchmakingAndHostingData, MatchmakingProvider) == 0x000000, "Member 'FSBZMatchmakingAndHostingData::MatchmakingProvider' has a wrong offset!");
static_assert(offsetof(FSBZMatchmakingAndHostingData, HostingProvider) == 0x000010, "Member 'FSBZMatchmakingAndHostingData::HostingProvider' has a wrong offset!");
static_assert(offsetof(FSBZMatchmakingAndHostingData, MatchmakerURL) == 0x000020, "Member 'FSBZMatchmakingAndHostingData::MatchmakerURL' has a wrong offset!");
static_assert(offsetof(FSBZMatchmakingAndHostingData, MatchmakerToken) == 0x000030, "Member 'FSBZMatchmakingAndHostingData::MatchmakerToken' has a wrong offset!");
static_assert(offsetof(FSBZMatchmakingAndHostingData, BeaconsKey) == 0x000040, "Member 'FSBZMatchmakingAndHostingData::BeaconsKey' has a wrong offset!");

// ScriptStruct Starbreeze.SBZGasVolumeTarget
// 0x0010 (0x0010 - 0x0000)
struct FSBZGasVolumeTarget final
{
public:
	class APawn*                                  Pawn;                                              // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PendingTimeSeconds;                                // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasReceivedDamage;                                // 0x000C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZGasVolumeTarget) == 0x000008, "Wrong alignment on FSBZGasVolumeTarget");
static_assert(sizeof(FSBZGasVolumeTarget) == 0x000010, "Wrong size on FSBZGasVolumeTarget");
static_assert(offsetof(FSBZGasVolumeTarget, Pawn) == 0x000000, "Member 'FSBZGasVolumeTarget::Pawn' has a wrong offset!");
static_assert(offsetof(FSBZGasVolumeTarget, PendingTimeSeconds) == 0x000008, "Member 'FSBZGasVolumeTarget::PendingTimeSeconds' has a wrong offset!");
static_assert(offsetof(FSBZGasVolumeTarget, bHasReceivedDamage) == 0x00000C, "Member 'FSBZGasVolumeTarget::bHasReceivedDamage' has a wrong offset!");

// ScriptStruct Starbreeze.SBZItemRewardConfiguration
// 0x0020 (0x0020 - 0x0000)
struct FSBZItemRewardConfiguration final
{
public:
	class FString                                 ItemSku;                                           // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StatCode;                                          // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZItemRewardConfiguration) == 0x000008, "Wrong alignment on FSBZItemRewardConfiguration");
static_assert(sizeof(FSBZItemRewardConfiguration) == 0x000020, "Wrong size on FSBZItemRewardConfiguration");
static_assert(offsetof(FSBZItemRewardConfiguration, ItemSku) == 0x000000, "Member 'FSBZItemRewardConfiguration::ItemSku' has a wrong offset!");
static_assert(offsetof(FSBZItemRewardConfiguration, StatCode) == 0x000010, "Member 'FSBZItemRewardConfiguration::StatCode' has a wrong offset!");

// ScriptStruct Starbreeze.SBZVehicleSplineData
// 0x0068 (0x0068 - 0x0000)
struct FSBZVehicleSplineData final
{
public:
	TSoftObjectPtr<class ASBZSpline>              EnterSpline;                                       // 0x0000(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ASBZSpline>              ExitSpline;                                        // 0x0030(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartsEnabled;                                    // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZVehicleSplineData) == 0x000008, "Wrong alignment on FSBZVehicleSplineData");
static_assert(sizeof(FSBZVehicleSplineData) == 0x000068, "Wrong size on FSBZVehicleSplineData");
static_assert(offsetof(FSBZVehicleSplineData, EnterSpline) == 0x000000, "Member 'FSBZVehicleSplineData::EnterSpline' has a wrong offset!");
static_assert(offsetof(FSBZVehicleSplineData, ExitSpline) == 0x000030, "Member 'FSBZVehicleSplineData::ExitSpline' has a wrong offset!");
static_assert(offsetof(FSBZVehicleSplineData, bStartsEnabled) == 0x000060, "Member 'FSBZVehicleSplineData::bStartsEnabled' has a wrong offset!");

// ScriptStruct Starbreeze.SBZChatCommand
// 0x0020 (0x0028 - 0x0008)
struct FSBZChatCommand final : public FTableRowBase
{
public:
	class FText                                   CommandAsString;                                   // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ESBZChatCommandTypes                          CommandToExecute;                                  // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZChatCommand) == 0x000008, "Wrong alignment on FSBZChatCommand");
static_assert(sizeof(FSBZChatCommand) == 0x000028, "Wrong size on FSBZChatCommand");
static_assert(offsetof(FSBZChatCommand, CommandAsString) == 0x000008, "Member 'FSBZChatCommand::CommandAsString' has a wrong offset!");
static_assert(offsetof(FSBZChatCommand, CommandToExecute) == 0x000020, "Member 'FSBZChatCommand::CommandToExecute' has a wrong offset!");

// ScriptStruct Starbreeze.SBZGameplayTagContainerComparison
// 0x0050 (0x0050 - 0x0000)
struct FSBZGameplayTagContainerComparison final
{
public:
	struct FGameplayTagContainer                  GameplayTagContainer;                              // 0x0000(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EGameplayContainerMatchType                   MatchType;                                         // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   FailedMessage;                                     // 0x0028(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             FailedIcon;                                        // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertTagContainerQuery;                          // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZGameplayTagContainerComparison) == 0x000008, "Wrong alignment on FSBZGameplayTagContainerComparison");
static_assert(sizeof(FSBZGameplayTagContainerComparison) == 0x000050, "Wrong size on FSBZGameplayTagContainerComparison");
static_assert(offsetof(FSBZGameplayTagContainerComparison, GameplayTagContainer) == 0x000000, "Member 'FSBZGameplayTagContainerComparison::GameplayTagContainer' has a wrong offset!");
static_assert(offsetof(FSBZGameplayTagContainerComparison, MatchType) == 0x000020, "Member 'FSBZGameplayTagContainerComparison::MatchType' has a wrong offset!");
static_assert(offsetof(FSBZGameplayTagContainerComparison, FailedMessage) == 0x000028, "Member 'FSBZGameplayTagContainerComparison::FailedMessage' has a wrong offset!");
static_assert(offsetof(FSBZGameplayTagContainerComparison, FailedIcon) == 0x000040, "Member 'FSBZGameplayTagContainerComparison::FailedIcon' has a wrong offset!");
static_assert(offsetof(FSBZGameplayTagContainerComparison, bInvertTagContainerQuery) == 0x000048, "Member 'FSBZGameplayTagContainerComparison::bInvertTagContainerQuery' has a wrong offset!");

// ScriptStruct Starbreeze.SBZEmotions
// 0x0010 (0x0010 - 0x0000)
struct FSBZEmotions final
{
public:
	TArray<ESBZFacialEmotion>                     Emotions;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZEmotions) == 0x000008, "Wrong alignment on FSBZEmotions");
static_assert(sizeof(FSBZEmotions) == 0x000010, "Wrong size on FSBZEmotions");
static_assert(offsetof(FSBZEmotions, Emotions) == 0x000000, "Member 'FSBZEmotions::Emotions' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMaximumPenetrationCountDistance
// 0x0008 (0x0008 - 0x0000)
struct FSBZMaximumPenetrationCountDistance final
{
public:
	uint32                                        Count;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZMaximumPenetrationCountDistance) == 0x000004, "Wrong alignment on FSBZMaximumPenetrationCountDistance");
static_assert(sizeof(FSBZMaximumPenetrationCountDistance) == 0x000008, "Wrong size on FSBZMaximumPenetrationCountDistance");
static_assert(offsetof(FSBZMaximumPenetrationCountDistance, Count) == 0x000000, "Member 'FSBZMaximumPenetrationCountDistance::Count' has a wrong offset!");
static_assert(offsetof(FSBZMaximumPenetrationCountDistance, Distance) == 0x000004, "Member 'FSBZMaximumPenetrationCountDistance::Distance' has a wrong offset!");

// ScriptStruct Starbreeze.SBZChallengesDsSettings
// 0x0010 (0x0010 - 0x0000)
struct FSBZChallengesDsSettings final
{
public:
	struct FSBZChallengesDsSettingsBlock          BlockArray;                                        // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZChallengesDsSettings) == 0x000008, "Wrong alignment on FSBZChallengesDsSettings");
static_assert(sizeof(FSBZChallengesDsSettings) == 0x000010, "Wrong size on FSBZChallengesDsSettings");
static_assert(offsetof(FSBZChallengesDsSettings, BlockArray) == 0x000000, "Member 'FSBZChallengesDsSettings::BlockArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZVoteFactoryFunctions
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FSBZVoteFactoryFunctions final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZVoteFactoryFunctions) == 0x000008, "Wrong alignment on FSBZVoteFactoryFunctions");
static_assert(sizeof(FSBZVoteFactoryFunctions) == 0x000020, "Wrong size on FSBZVoteFactoryFunctions");

// ScriptStruct Starbreeze.SBZInternalChallengeRewardItem
// 0x0030 (0x0030 - 0x0000)
struct FSBZInternalChallengeRewardItem final
{
public:
	class FString                                 AccelByteSku;                                      // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  AccelbyteItemId;                                   // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USBZInventoryBaseData*                  Item;                                              // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZInternalChallengeRewardItem) == 0x000008, "Wrong alignment on FSBZInternalChallengeRewardItem");
static_assert(sizeof(FSBZInternalChallengeRewardItem) == 0x000030, "Wrong size on FSBZInternalChallengeRewardItem");
static_assert(offsetof(FSBZInternalChallengeRewardItem, AccelByteSku) == 0x000000, "Member 'FSBZInternalChallengeRewardItem::AccelByteSku' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeRewardItem, AccelbyteItemId) == 0x000010, "Member 'FSBZInternalChallengeRewardItem::AccelbyteItemId' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeRewardItem, Quantity) == 0x000020, "Member 'FSBZInternalChallengeRewardItem::Quantity' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeRewardItem, Item) == 0x000028, "Member 'FSBZInternalChallengeRewardItem::Item' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInternalChallengeData
// 0x00A8 (0x00A8 - 0x0000)
struct FSBZInternalChallengeData final
{
public:
	class FName                                   ChallengeId;                                       // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ChallengeName;                                     // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  AccelbyteChallengeId;                              // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         PrerequisiteChallengeIds;                          // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSBZInternalChallengeProgressStat> PrerequisiteStatData;                           // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSBZInternalChallengeProgressItem> PrerequisiteItemData;                           // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSBZInternalChallengeProgressStat> ObjectiveStatData;                              // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSBZInternalChallengeRewardItem> RewardItemsData;                                  // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         Tags;                                              // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EChallengeStatusEnum                          ChallengeStatus;                                   // 0x0090(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InfamyPointReward;                                 // 0x0094(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DailyCreationObjectiveStartStatValue;              // 0x0098(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalProgress;                                     // 0x009C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalTarget;                                       // 0x00A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZChallengeConversion                       ChallengeConversion;                               // 0x00A4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsActive;                                          // 0x00A5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A6[0x2];                                       // 0x00A6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZInternalChallengeData) == 0x000008, "Wrong alignment on FSBZInternalChallengeData");
static_assert(sizeof(FSBZInternalChallengeData) == 0x0000A8, "Wrong size on FSBZInternalChallengeData");
static_assert(offsetof(FSBZInternalChallengeData, ChallengeId) == 0x000000, "Member 'FSBZInternalChallengeData::ChallengeId' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeData, ChallengeName) == 0x000010, "Member 'FSBZInternalChallengeData::ChallengeName' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeData, AccelbyteChallengeId) == 0x000020, "Member 'FSBZInternalChallengeData::AccelbyteChallengeId' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeData, PrerequisiteChallengeIds) == 0x000030, "Member 'FSBZInternalChallengeData::PrerequisiteChallengeIds' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeData, PrerequisiteStatData) == 0x000040, "Member 'FSBZInternalChallengeData::PrerequisiteStatData' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeData, PrerequisiteItemData) == 0x000050, "Member 'FSBZInternalChallengeData::PrerequisiteItemData' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeData, ObjectiveStatData) == 0x000060, "Member 'FSBZInternalChallengeData::ObjectiveStatData' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeData, RewardItemsData) == 0x000070, "Member 'FSBZInternalChallengeData::RewardItemsData' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeData, Tags) == 0x000080, "Member 'FSBZInternalChallengeData::Tags' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeData, ChallengeStatus) == 0x000090, "Member 'FSBZInternalChallengeData::ChallengeStatus' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeData, InfamyPointReward) == 0x000094, "Member 'FSBZInternalChallengeData::InfamyPointReward' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeData, DailyCreationObjectiveStartStatValue) == 0x000098, "Member 'FSBZInternalChallengeData::DailyCreationObjectiveStartStatValue' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeData, TotalProgress) == 0x00009C, "Member 'FSBZInternalChallengeData::TotalProgress' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeData, TotalTarget) == 0x0000A0, "Member 'FSBZInternalChallengeData::TotalTarget' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeData, ChallengeConversion) == 0x0000A4, "Member 'FSBZInternalChallengeData::ChallengeConversion' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeData, IsActive) == 0x0000A5, "Member 'FSBZInternalChallengeData::IsActive' has a wrong offset!");

// ScriptStruct Starbreeze.SBZControlsReference
// 0x0028 (0x0028 - 0x0000)
struct FSBZControlsReference final
{
public:
	TArray<struct FSBZActionControlReference>     ActionList;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DisplayTime;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x14];                                      // 0x0014(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZControlsReference) == 0x000008, "Wrong alignment on FSBZControlsReference");
static_assert(sizeof(FSBZControlsReference) == 0x000028, "Wrong size on FSBZControlsReference");
static_assert(offsetof(FSBZControlsReference, ActionList) == 0x000000, "Member 'FSBZControlsReference::ActionList' has a wrong offset!");
static_assert(offsetof(FSBZControlsReference, DisplayTime) == 0x000010, "Member 'FSBZControlsReference::DisplayTime' has a wrong offset!");

// ScriptStruct Starbreeze.SBZHoldOutDroneReactionArray
// 0x0010 (0x0010 - 0x0000)
struct FSBZHoldOutDroneReactionArray final
{
public:
	TArray<class ASBZHoldOutDroneReaction*>       DroneReactions;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZHoldOutDroneReactionArray) == 0x000008, "Wrong alignment on FSBZHoldOutDroneReactionArray");
static_assert(sizeof(FSBZHoldOutDroneReactionArray) == 0x000010, "Wrong size on FSBZHoldOutDroneReactionArray");
static_assert(offsetof(FSBZHoldOutDroneReactionArray, DroneReactions) == 0x000000, "Member 'FSBZHoldOutDroneReactionArray::DroneReactions' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInternalChallengeNotifPayload
// 0x0050 (0x0050 - 0x0000)
struct FSBZInternalChallengeNotifPayload final
{
public:
	class FString                                 challengeId;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 challengeName;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSBZInternalChallengeReward            reward;                                            // 0x0020(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZInternalChallengeNotifPayload) == 0x000008, "Wrong alignment on FSBZInternalChallengeNotifPayload");
static_assert(sizeof(FSBZInternalChallengeNotifPayload) == 0x000050, "Wrong size on FSBZInternalChallengeNotifPayload");
static_assert(offsetof(FSBZInternalChallengeNotifPayload, challengeId) == 0x000000, "Member 'FSBZInternalChallengeNotifPayload::challengeId' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeNotifPayload, challengeName) == 0x000010, "Member 'FSBZInternalChallengeNotifPayload::challengeName' has a wrong offset!");
static_assert(offsetof(FSBZInternalChallengeNotifPayload, reward) == 0x000020, "Member 'FSBZInternalChallengeNotifPayload::reward' has a wrong offset!");

// ScriptStruct Starbreeze.SBZObjectiveKeysOverrides
// 0x0050 (0x0050 - 0x0000)
struct FSBZObjectiveKeysOverrides final
{
public:
	TMap<class FString, class FString>            KeysOverrides;                                     // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZObjectiveKeysOverrides) == 0x000008, "Wrong alignment on FSBZObjectiveKeysOverrides");
static_assert(sizeof(FSBZObjectiveKeysOverrides) == 0x000050, "Wrong size on FSBZObjectiveKeysOverrides");
static_assert(offsetof(FSBZObjectiveKeysOverrides, KeysOverrides) == 0x000000, "Member 'FSBZObjectiveKeysOverrides::KeysOverrides' has a wrong offset!");

// ScriptStruct Starbreeze.ChallengeRequest
// 0x0108 (0x0108 - 0x0000)
struct alignas(0x08) FChallengeRequest final
{
public:
	uint8                                         Pad_0[0x108];                                      // 0x0000(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChallengeRequest) == 0x000008, "Wrong alignment on FChallengeRequest");
static_assert(sizeof(FChallengeRequest) == 0x000108, "Wrong size on FChallengeRequest");

// ScriptStruct Starbreeze.SBZExplosionBox
// 0x0050 (0x0050 - 0x0000)
struct FSBZExplosionBox final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Quat;                                              // 0x0010(0x0010)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                HalfExtent;                                        // 0x0020(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Delay;                                             // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DelayHalfExtentPadding;                            // 0x0030(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DelayOffset;                                       // 0x003C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZExplosionBox) == 0x000010, "Wrong alignment on FSBZExplosionBox");
static_assert(sizeof(FSBZExplosionBox) == 0x000050, "Wrong size on FSBZExplosionBox");
static_assert(offsetof(FSBZExplosionBox, Location) == 0x000000, "Member 'FSBZExplosionBox::Location' has a wrong offset!");
static_assert(offsetof(FSBZExplosionBox, Quat) == 0x000010, "Member 'FSBZExplosionBox::Quat' has a wrong offset!");
static_assert(offsetof(FSBZExplosionBox, HalfExtent) == 0x000020, "Member 'FSBZExplosionBox::HalfExtent' has a wrong offset!");
static_assert(offsetof(FSBZExplosionBox, Delay) == 0x00002C, "Member 'FSBZExplosionBox::Delay' has a wrong offset!");
static_assert(offsetof(FSBZExplosionBox, DelayHalfExtentPadding) == 0x000030, "Member 'FSBZExplosionBox::DelayHalfExtentPadding' has a wrong offset!");
static_assert(offsetof(FSBZExplosionBox, DelayOffset) == 0x00003C, "Member 'FSBZExplosionBox::DelayOffset' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInternalStatData
// 0x0004 (0x0004 - 0x0000)
struct FSBZInternalStatData final
{
public:
	float                                         Progress;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZInternalStatData) == 0x000004, "Wrong alignment on FSBZInternalStatData");
static_assert(sizeof(FSBZInternalStatData) == 0x000004, "Wrong size on FSBZInternalStatData");
static_assert(offsetof(FSBZInternalStatData, Progress) == 0x000000, "Member 'FSBZInternalStatData::Progress' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMetaEventModifierData
// 0x0008 (0x0008 - 0x0000)
struct FSBZMetaEventModifierData final
{
public:
	ESBZMetaEventModifierType                     ModifierType;                                      // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Multiplier;                                        // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZMetaEventModifierData) == 0x000004, "Wrong alignment on FSBZMetaEventModifierData");
static_assert(sizeof(FSBZMetaEventModifierData) == 0x000008, "Wrong size on FSBZMetaEventModifierData");
static_assert(offsetof(FSBZMetaEventModifierData, ModifierType) == 0x000000, "Member 'FSBZMetaEventModifierData::ModifierType' has a wrong offset!");
static_assert(offsetof(FSBZMetaEventModifierData, Multiplier) == 0x000004, "Member 'FSBZMetaEventModifierData::Multiplier' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMetaEventData
// 0x0058 (0x0058 - 0x0000)
struct FSBZMetaEventData final
{
public:
	bool                                          Active;                                            // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZMetaEventType                             EventType;                                         // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              StartDate;                                         // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              StopDate;                                          // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSBZMetaEventModifierData>      Modifiers;                                         // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         Tags;                                              // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 EventId;                                           // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZMetaEventData) == 0x000008, "Wrong alignment on FSBZMetaEventData");
static_assert(sizeof(FSBZMetaEventData) == 0x000058, "Wrong size on FSBZMetaEventData");
static_assert(offsetof(FSBZMetaEventData, Active) == 0x000000, "Member 'FSBZMetaEventData::Active' has a wrong offset!");
static_assert(offsetof(FSBZMetaEventData, EventType) == 0x000001, "Member 'FSBZMetaEventData::EventType' has a wrong offset!");
static_assert(offsetof(FSBZMetaEventData, StartDate) == 0x000008, "Member 'FSBZMetaEventData::StartDate' has a wrong offset!");
static_assert(offsetof(FSBZMetaEventData, StopDate) == 0x000010, "Member 'FSBZMetaEventData::StopDate' has a wrong offset!");
static_assert(offsetof(FSBZMetaEventData, Description) == 0x000018, "Member 'FSBZMetaEventData::Description' has a wrong offset!");
static_assert(offsetof(FSBZMetaEventData, Modifiers) == 0x000028, "Member 'FSBZMetaEventData::Modifiers' has a wrong offset!");
static_assert(offsetof(FSBZMetaEventData, Tags) == 0x000038, "Member 'FSBZMetaEventData::Tags' has a wrong offset!");
static_assert(offsetof(FSBZMetaEventData, EventId) == 0x000048, "Member 'FSBZMetaEventData::EventId' has a wrong offset!");

// ScriptStruct Starbreeze.SBZDropCharacterSound
// 0x0010 (0x0010 - 0x0000)
struct FSBZDropCharacterSound final
{
public:
	class UAkAudioEvent*                          DropRagdollSoundEvent;                             // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          DropHumanShieldSoundEvent;                         // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZDropCharacterSound) == 0x000008, "Wrong alignment on FSBZDropCharacterSound");
static_assert(sizeof(FSBZDropCharacterSound) == 0x000010, "Wrong size on FSBZDropCharacterSound");
static_assert(offsetof(FSBZDropCharacterSound, DropRagdollSoundEvent) == 0x000000, "Member 'FSBZDropCharacterSound::DropRagdollSoundEvent' has a wrong offset!");
static_assert(offsetof(FSBZDropCharacterSound, DropHumanShieldSoundEvent) == 0x000008, "Member 'FSBZDropCharacterSound::DropHumanShieldSoundEvent' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAttackInfo
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x04) FSBZAttackInfo final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZAttackInfo) == 0x000004, "Wrong alignment on FSBZAttackInfo");
static_assert(sizeof(FSBZAttackInfo) == 0x000028, "Wrong size on FSBZAttackInfo");

// ScriptStruct Starbreeze.SBZStartMoveHandler
// 0x0058 (0x0058 - 0x0000)
struct FSBZStartMoveHandler final
{
public:
	class UBlendSpaceBase*                        BlendSpace;                                        // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Animation;                                         // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x48];                                      // 0x0010(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZStartMoveHandler) == 0x000008, "Wrong alignment on FSBZStartMoveHandler");
static_assert(sizeof(FSBZStartMoveHandler) == 0x000058, "Wrong size on FSBZStartMoveHandler");
static_assert(offsetof(FSBZStartMoveHandler, BlendSpace) == 0x000000, "Member 'FSBZStartMoveHandler::BlendSpace' has a wrong offset!");
static_assert(offsetof(FSBZStartMoveHandler, Animation) == 0x000008, "Member 'FSBZStartMoveHandler::Animation' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSpeedWarpingData
// 0x0014 (0x0014 - 0x0000)
struct FSBZSpeedWarpingData final
{
public:
	float                                         Alpha;                                             // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedScaling;                                      // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PelvisZOffset;                                     // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LegsZOffset;                                       // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSpeedWarpingData) == 0x000004, "Wrong alignment on FSBZSpeedWarpingData");
static_assert(sizeof(FSBZSpeedWarpingData) == 0x000014, "Wrong size on FSBZSpeedWarpingData");
static_assert(offsetof(FSBZSpeedWarpingData, Alpha) == 0x000000, "Member 'FSBZSpeedWarpingData::Alpha' has a wrong offset!");
static_assert(offsetof(FSBZSpeedWarpingData, SpeedScaling) == 0x000004, "Member 'FSBZSpeedWarpingData::SpeedScaling' has a wrong offset!");
static_assert(offsetof(FSBZSpeedWarpingData, PelvisZOffset) == 0x000008, "Member 'FSBZSpeedWarpingData::PelvisZOffset' has a wrong offset!");
static_assert(offsetof(FSBZSpeedWarpingData, LegsZOffset) == 0x00000C, "Member 'FSBZSpeedWarpingData::LegsZOffset' has a wrong offset!");
static_assert(offsetof(FSBZSpeedWarpingData, PlayRate) == 0x000010, "Member 'FSBZSpeedWarpingData::PlayRate' has a wrong offset!");

// ScriptStruct Starbreeze.SBZTraverseAnimationHandler
// 0x0058 (0x0058 - 0x0000)
struct FSBZTraverseAnimationHandler final
{
public:
	uint8                                         bStart : 1;                                        // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTraverse : 1;                                     // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bExitTraverse : 1;                                 // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLand : 1;                                         // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFall : 1;                                         // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEndsInFalling : 1;                                // 0x0000(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsPlaying : 1;                                    // 0x0000(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMantle : 1;                                       // 0x0000(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VerticalDistToFrontEdge;                           // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalDistFromBackEdge;                          // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExitTraverseTime;                                  // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      StartAnim;                                         // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      ExitTraverseAnim;                                  // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      LandAnim;                                          // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           EndMontage;                                        // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZTraverseAnimationHandler) == 0x000008, "Wrong alignment on FSBZTraverseAnimationHandler");
static_assert(sizeof(FSBZTraverseAnimationHandler) == 0x000058, "Wrong size on FSBZTraverseAnimationHandler");
static_assert(offsetof(FSBZTraverseAnimationHandler, VerticalDistToFrontEdge) == 0x000004, "Member 'FSBZTraverseAnimationHandler::VerticalDistToFrontEdge' has a wrong offset!");
static_assert(offsetof(FSBZTraverseAnimationHandler, VerticalDistFromBackEdge) == 0x000008, "Member 'FSBZTraverseAnimationHandler::VerticalDistFromBackEdge' has a wrong offset!");
static_assert(offsetof(FSBZTraverseAnimationHandler, ExitTraverseTime) == 0x00000C, "Member 'FSBZTraverseAnimationHandler::ExitTraverseTime' has a wrong offset!");
static_assert(offsetof(FSBZTraverseAnimationHandler, StartAnim) == 0x000010, "Member 'FSBZTraverseAnimationHandler::StartAnim' has a wrong offset!");
static_assert(offsetof(FSBZTraverseAnimationHandler, ExitTraverseAnim) == 0x000018, "Member 'FSBZTraverseAnimationHandler::ExitTraverseAnim' has a wrong offset!");
static_assert(offsetof(FSBZTraverseAnimationHandler, LandAnim) == 0x000020, "Member 'FSBZTraverseAnimationHandler::LandAnim' has a wrong offset!");
static_assert(offsetof(FSBZTraverseAnimationHandler, EndMontage) == 0x000028, "Member 'FSBZTraverseAnimationHandler::EndMontage' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCharacterEffectSpawnParams
// 0x000C (0x000C - 0x0000)
struct FSBZCharacterEffectSpawnParams final
{
public:
	float                                         InitialProgress;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InitialCharacterEffectValue;                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHidesWhenActive;                                  // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZCharacterEffectSpawnParams) == 0x000004, "Wrong alignment on FSBZCharacterEffectSpawnParams");
static_assert(sizeof(FSBZCharacterEffectSpawnParams) == 0x00000C, "Wrong size on FSBZCharacterEffectSpawnParams");
static_assert(offsetof(FSBZCharacterEffectSpawnParams, InitialProgress) == 0x000000, "Member 'FSBZCharacterEffectSpawnParams::InitialProgress' has a wrong offset!");
static_assert(offsetof(FSBZCharacterEffectSpawnParams, InitialCharacterEffectValue) == 0x000004, "Member 'FSBZCharacterEffectSpawnParams::InitialCharacterEffectValue' has a wrong offset!");
static_assert(offsetof(FSBZCharacterEffectSpawnParams, bHidesWhenActive) == 0x000008, "Member 'FSBZCharacterEffectSpawnParams::bHidesWhenActive' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCharacterMeshScaleData
// 0x0010 (0x0010 - 0x0000)
struct FSBZCharacterMeshScaleData final
{
public:
	TArray<float>                                 ScaleFactors;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZCharacterMeshScaleData) == 0x000008, "Wrong alignment on FSBZCharacterMeshScaleData");
static_assert(sizeof(FSBZCharacterMeshScaleData) == 0x000010, "Wrong size on FSBZCharacterMeshScaleData");
static_assert(offsetof(FSBZCharacterMeshScaleData, ScaleFactors) == 0x000000, "Member 'FSBZCharacterMeshScaleData::ScaleFactors' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCharacterCommentAssets
// 0x0040 (0x0040 - 0x0000)
struct FSBZCharacterCommentAssets final
{
public:
	class USBZVoiceCommentDataAsset*              TakeDamage;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZVoiceCommentDataAsset*              OnDeath;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZVoiceCommentDataAsset*              GruntLight;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZVoiceCommentDataAsset*              GruntHeavy;                                        // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZVoiceCommentDataAsset*              GruntHurtLight;                                    // 0x0020(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZVoiceCommentDataAsset*              GruntHurtHeavy;                                    // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZVoiceCommentDataAsset*              GruntUpwards;                                      // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZVoiceCommentDataAsset*              GruntDownwards;                                    // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZCharacterCommentAssets) == 0x000008, "Wrong alignment on FSBZCharacterCommentAssets");
static_assert(sizeof(FSBZCharacterCommentAssets) == 0x000040, "Wrong size on FSBZCharacterCommentAssets");
static_assert(offsetof(FSBZCharacterCommentAssets, TakeDamage) == 0x000000, "Member 'FSBZCharacterCommentAssets::TakeDamage' has a wrong offset!");
static_assert(offsetof(FSBZCharacterCommentAssets, OnDeath) == 0x000008, "Member 'FSBZCharacterCommentAssets::OnDeath' has a wrong offset!");
static_assert(offsetof(FSBZCharacterCommentAssets, GruntLight) == 0x000010, "Member 'FSBZCharacterCommentAssets::GruntLight' has a wrong offset!");
static_assert(offsetof(FSBZCharacterCommentAssets, GruntHeavy) == 0x000018, "Member 'FSBZCharacterCommentAssets::GruntHeavy' has a wrong offset!");
static_assert(offsetof(FSBZCharacterCommentAssets, GruntHurtLight) == 0x000020, "Member 'FSBZCharacterCommentAssets::GruntHurtLight' has a wrong offset!");
static_assert(offsetof(FSBZCharacterCommentAssets, GruntHurtHeavy) == 0x000028, "Member 'FSBZCharacterCommentAssets::GruntHurtHeavy' has a wrong offset!");
static_assert(offsetof(FSBZCharacterCommentAssets, GruntUpwards) == 0x000030, "Member 'FSBZCharacterCommentAssets::GruntUpwards' has a wrong offset!");
static_assert(offsetof(FSBZCharacterCommentAssets, GruntDownwards) == 0x000038, "Member 'FSBZCharacterCommentAssets::GruntDownwards' has a wrong offset!");

// ScriptStruct Starbreeze.SBZVoiceInfoCallback
// 0x0008 (0x0008 - 0x0000)
struct FSBZVoiceInfoCallback final
{
public:
	class USBZCharacterVoiceComponent*            VoiceComponent;                                    // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZVoiceInfoCallback) == 0x000008, "Wrong alignment on FSBZVoiceInfoCallback");
static_assert(sizeof(FSBZVoiceInfoCallback) == 0x000008, "Wrong size on FSBZVoiceInfoCallback");
static_assert(offsetof(FSBZVoiceInfoCallback, VoiceComponent) == 0x000000, "Member 'FSBZVoiceInfoCallback::VoiceComponent' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWhisperInfo
// 0x0038 (0x0038 - 0x0000)
struct FSBZWhisperInfo final
{
public:
	struct FUniqueNetIdRepl                       ReplicatedUniqueID;                                // 0x0000(0x0028)(BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWhisperInfo) == 0x000008, "Wrong alignment on FSBZWhisperInfo");
static_assert(sizeof(FSBZWhisperInfo) == 0x000038, "Wrong size on FSBZWhisperInfo");
static_assert(offsetof(FSBZWhisperInfo, ReplicatedUniqueID) == 0x000000, "Member 'FSBZWhisperInfo::ReplicatedUniqueID' has a wrong offset!");
static_assert(offsetof(FSBZWhisperInfo, Name) == 0x000028, "Member 'FSBZWhisperInfo::Name' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCommandArray
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FSBZCommandArray final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZCommandArray) == 0x000008, "Wrong alignment on FSBZCommandArray");
static_assert(sizeof(FSBZCommandArray) == 0x000030, "Wrong size on FSBZCommandArray");

// ScriptStruct Starbreeze.SBZControlsReferenceRuntime
// 0x0030 (0x0030 - 0x0000)
struct FSBZControlsReferenceRuntime final
{
public:
	struct FSBZControlsReference                  ControlsReference;                                 // 0x0000(0x0028)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         ID;                                                // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZControlsReferenceRuntime) == 0x000008, "Wrong alignment on FSBZControlsReferenceRuntime");
static_assert(sizeof(FSBZControlsReferenceRuntime) == 0x000030, "Wrong size on FSBZControlsReferenceRuntime");
static_assert(offsetof(FSBZControlsReferenceRuntime, ControlsReference) == 0x000000, "Member 'FSBZControlsReferenceRuntime::ControlsReference' has a wrong offset!");
static_assert(offsetof(FSBZControlsReferenceRuntime, ID) == 0x000028, "Member 'FSBZControlsReferenceRuntime::ID' has a wrong offset!");

// ScriptStruct Starbreeze.SBZButtonControlsReference
// 0x0028 (0x0028 - 0x0000)
struct FSBZButtonControlsReference final
{
public:
	TArray<struct FSBZButtonControlReference>     ActionList;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x18];                                      // 0x0010(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZButtonControlsReference) == 0x000008, "Wrong alignment on FSBZButtonControlsReference");
static_assert(sizeof(FSBZButtonControlsReference) == 0x000028, "Wrong size on FSBZButtonControlsReference");
static_assert(offsetof(FSBZButtonControlsReference, ActionList) == 0x000000, "Member 'FSBZButtonControlsReference::ActionList' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCookingDifficultyDurations
// 0x0018 (0x0018 - 0x0000)
struct FSBZCookingDifficultyDurations final
{
public:
	struct FFloatInterval                         UnderCookedInterval;                               // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         CookedInterval;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         OverCookedInterval;                                // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZCookingDifficultyDurations) == 0x000004, "Wrong alignment on FSBZCookingDifficultyDurations");
static_assert(sizeof(FSBZCookingDifficultyDurations) == 0x000018, "Wrong size on FSBZCookingDifficultyDurations");
static_assert(offsetof(FSBZCookingDifficultyDurations, UnderCookedInterval) == 0x000000, "Member 'FSBZCookingDifficultyDurations::UnderCookedInterval' has a wrong offset!");
static_assert(offsetof(FSBZCookingDifficultyDurations, CookedInterval) == 0x000008, "Member 'FSBZCookingDifficultyDurations::CookedInterval' has a wrong offset!");
static_assert(offsetof(FSBZCookingDifficultyDurations, OverCookedInterval) == 0x000010, "Member 'FSBZCookingDifficultyDurations::OverCookedInterval' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCoverShootingPoints
// 0x0014 (0x0014 - 0x0000)
struct FSBZCoverShootingPoints final
{
public:
	struct FVector                                Offset;                                            // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLineTraceLength;                                // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZShootingPointType                         ShootingType;                                      // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZCoverShootingPoints) == 0x000004, "Wrong alignment on FSBZCoverShootingPoints");
static_assert(sizeof(FSBZCoverShootingPoints) == 0x000014, "Wrong size on FSBZCoverShootingPoints");
static_assert(offsetof(FSBZCoverShootingPoints, Offset) == 0x000000, "Member 'FSBZCoverShootingPoints::Offset' has a wrong offset!");
static_assert(offsetof(FSBZCoverShootingPoints, MaxLineTraceLength) == 0x00000C, "Member 'FSBZCoverShootingPoints::MaxLineTraceLength' has a wrong offset!");
static_assert(offsetof(FSBZCoverShootingPoints, ShootingType) == 0x000010, "Member 'FSBZCoverShootingPoints::ShootingType' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCutProgressData
// 0x0018 (0x0018 - 0x0000)
struct FSBZCutProgressData final
{
public:
	float                                         AccumulatedDeltaTime;                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineCutLength;                                     // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasInitialCut;                                    // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartCutTimeSeconds;                               // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastUsedSkillSpeedModifier;                        // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentSplineTime;                                 // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZCutProgressData) == 0x000004, "Wrong alignment on FSBZCutProgressData");
static_assert(sizeof(FSBZCutProgressData) == 0x000018, "Wrong size on FSBZCutProgressData");
static_assert(offsetof(FSBZCutProgressData, AccumulatedDeltaTime) == 0x000000, "Member 'FSBZCutProgressData::AccumulatedDeltaTime' has a wrong offset!");
static_assert(offsetof(FSBZCutProgressData, LineCutLength) == 0x000004, "Member 'FSBZCutProgressData::LineCutLength' has a wrong offset!");
static_assert(offsetof(FSBZCutProgressData, bHasInitialCut) == 0x000008, "Member 'FSBZCutProgressData::bHasInitialCut' has a wrong offset!");
static_assert(offsetof(FSBZCutProgressData, StartCutTimeSeconds) == 0x00000C, "Member 'FSBZCutProgressData::StartCutTimeSeconds' has a wrong offset!");
static_assert(offsetof(FSBZCutProgressData, LastUsedSkillSpeedModifier) == 0x000010, "Member 'FSBZCutProgressData::LastUsedSkillSpeedModifier' has a wrong offset!");
static_assert(offsetof(FSBZCutProgressData, CurrentSplineTime) == 0x000014, "Member 'FSBZCutProgressData::CurrentSplineTime' has a wrong offset!");

// ScriptStruct Starbreeze.SBZDamageAndTimePair
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FSBZDamageAndTimePair final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZDamageAndTimePair) == 0x000004, "Wrong alignment on FSBZDamageAndTimePair");
static_assert(sizeof(FSBZDamageAndTimePair) == 0x000008, "Wrong size on FSBZDamageAndTimePair");

// ScriptStruct Starbreeze.SBZTrackedDamageWrapper
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FSBZTrackedDamageWrapper final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZTrackedDamageWrapper) == 0x000008, "Wrong alignment on FSBZTrackedDamageWrapper");
static_assert(sizeof(FSBZTrackedDamageWrapper) == 0x000020, "Wrong size on FSBZTrackedDamageWrapper");

// ScriptStruct Starbreeze.SBZDbgTextParams
// 0x0028 (0x0028 - 0x0000)
struct FSBZDbgTextParams final
{
public:
	struct FLinearColor                           Colour;                                            // 0x0000(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Text;                                              // 0x0010(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToDisplay;                                     // 0x0020(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZDbgDisplayOutput                          OutputLocation;                                    // 0x0024(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZDbgTextParams) == 0x000008, "Wrong alignment on FSBZDbgTextParams");
static_assert(sizeof(FSBZDbgTextParams) == 0x000028, "Wrong size on FSBZDbgTextParams");
static_assert(offsetof(FSBZDbgTextParams, Colour) == 0x000000, "Member 'FSBZDbgTextParams::Colour' has a wrong offset!");
static_assert(offsetof(FSBZDbgTextParams, Text) == 0x000010, "Member 'FSBZDbgTextParams::Text' has a wrong offset!");
static_assert(offsetof(FSBZDbgTextParams, TimeToDisplay) == 0x000020, "Member 'FSBZDbgTextParams::TimeToDisplay' has a wrong offset!");
static_assert(offsetof(FSBZDbgTextParams, OutputLocation) == 0x000024, "Member 'FSBZDbgTextParams::OutputLocation' has a wrong offset!");

// ScriptStruct Starbreeze.SBZDbgSphereParams
// 0x0024 (0x0024 - 0x0000)
struct FSBZDbgSphereParams final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Segments;                                          // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistent;                                       // 0x0018(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Life;                                              // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Priority;                                          // 0x0020(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZDbgSphereParams) == 0x000004, "Wrong alignment on FSBZDbgSphereParams");
static_assert(sizeof(FSBZDbgSphereParams) == 0x000024, "Wrong size on FSBZDbgSphereParams");
static_assert(offsetof(FSBZDbgSphereParams, Location) == 0x000000, "Member 'FSBZDbgSphereParams::Location' has a wrong offset!");
static_assert(offsetof(FSBZDbgSphereParams, Radius) == 0x00000C, "Member 'FSBZDbgSphereParams::Radius' has a wrong offset!");
static_assert(offsetof(FSBZDbgSphereParams, Segments) == 0x000010, "Member 'FSBZDbgSphereParams::Segments' has a wrong offset!");
static_assert(offsetof(FSBZDbgSphereParams, Color) == 0x000014, "Member 'FSBZDbgSphereParams::Color' has a wrong offset!");
static_assert(offsetof(FSBZDbgSphereParams, bPersistent) == 0x000018, "Member 'FSBZDbgSphereParams::bPersistent' has a wrong offset!");
static_assert(offsetof(FSBZDbgSphereParams, Life) == 0x00001C, "Member 'FSBZDbgSphereParams::Life' has a wrong offset!");
static_assert(offsetof(FSBZDbgSphereParams, Priority) == 0x000020, "Member 'FSBZDbgSphereParams::Priority' has a wrong offset!");

// ScriptStruct Starbreeze.SBZDbgPointParams
// 0x0020 (0x0020 - 0x0000)
struct FSBZDbgPointParams final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Size;                                              // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistent;                                       // 0x0014(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Life;                                              // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Priority;                                          // 0x001C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZDbgPointParams) == 0x000004, "Wrong alignment on FSBZDbgPointParams");
static_assert(sizeof(FSBZDbgPointParams) == 0x000020, "Wrong size on FSBZDbgPointParams");
static_assert(offsetof(FSBZDbgPointParams, Location) == 0x000000, "Member 'FSBZDbgPointParams::Location' has a wrong offset!");
static_assert(offsetof(FSBZDbgPointParams, Size) == 0x00000C, "Member 'FSBZDbgPointParams::Size' has a wrong offset!");
static_assert(offsetof(FSBZDbgPointParams, Color) == 0x000010, "Member 'FSBZDbgPointParams::Color' has a wrong offset!");
static_assert(offsetof(FSBZDbgPointParams, bPersistent) == 0x000014, "Member 'FSBZDbgPointParams::bPersistent' has a wrong offset!");
static_assert(offsetof(FSBZDbgPointParams, Life) == 0x000018, "Member 'FSBZDbgPointParams::Life' has a wrong offset!");
static_assert(offsetof(FSBZDbgPointParams, Priority) == 0x00001C, "Member 'FSBZDbgPointParams::Priority' has a wrong offset!");

// ScriptStruct Starbreeze.SBZDefeatStateAnimationHandler
// 0x0028 (0x0028 - 0x0000)
struct FSBZDefeatStateAnimationHandler final
{
public:
	class UAnimSequenceBase*                      IdleSubdued;                                       // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      IdleDowned;                                        // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      IdleBleedOut;                                      // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlendSpaceBase*                        DownedAimOffset;                                   // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDefeated : 1;                                     // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSubdued : 1;                                      // 0x0020(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDowned : 1;                                       // 0x0020(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bBleedOut : 1;                                     // 0x0020(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZDefeatStateAnimationHandler) == 0x000008, "Wrong alignment on FSBZDefeatStateAnimationHandler");
static_assert(sizeof(FSBZDefeatStateAnimationHandler) == 0x000028, "Wrong size on FSBZDefeatStateAnimationHandler");
static_assert(offsetof(FSBZDefeatStateAnimationHandler, IdleSubdued) == 0x000000, "Member 'FSBZDefeatStateAnimationHandler::IdleSubdued' has a wrong offset!");
static_assert(offsetof(FSBZDefeatStateAnimationHandler, IdleDowned) == 0x000008, "Member 'FSBZDefeatStateAnimationHandler::IdleDowned' has a wrong offset!");
static_assert(offsetof(FSBZDefeatStateAnimationHandler, IdleBleedOut) == 0x000010, "Member 'FSBZDefeatStateAnimationHandler::IdleBleedOut' has a wrong offset!");
static_assert(offsetof(FSBZDefeatStateAnimationHandler, DownedAimOffset) == 0x000018, "Member 'FSBZDefeatStateAnimationHandler::DownedAimOffset' has a wrong offset!");

// ScriptStruct Starbreeze.SBZActiveDialogData
// 0x0038 (0x0038 - 0x0000)
struct FSBZActiveDialogData final
{
public:
	class USBZDialogDataAsset*                    DialogDataAsset;                                   // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         Performers;                                        // 0x0008(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x20];                                      // 0x0018(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZActiveDialogData) == 0x000008, "Wrong alignment on FSBZActiveDialogData");
static_assert(sizeof(FSBZActiveDialogData) == 0x000038, "Wrong size on FSBZActiveDialogData");
static_assert(offsetof(FSBZActiveDialogData, DialogDataAsset) == 0x000000, "Member 'FSBZActiveDialogData::DialogDataAsset' has a wrong offset!");
static_assert(offsetof(FSBZActiveDialogData, Performers) == 0x000008, "Member 'FSBZActiveDialogData::Performers' has a wrong offset!");

// ScriptStruct Starbreeze.SBZDialogLineDefinition
// 0x0028 (0x0028 - 0x0000)
struct FSBZDialogLineDefinition final
{
public:
	ESBZDialogPerformer                           Performer;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          AudioEvent;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CommentState;                                      // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Delay;                                             // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZDialogLineDefinition) == 0x000008, "Wrong alignment on FSBZDialogLineDefinition");
static_assert(sizeof(FSBZDialogLineDefinition) == 0x000028, "Wrong size on FSBZDialogLineDefinition");
static_assert(offsetof(FSBZDialogLineDefinition, Performer) == 0x000000, "Member 'FSBZDialogLineDefinition::Performer' has a wrong offset!");
static_assert(offsetof(FSBZDialogLineDefinition, AudioEvent) == 0x000008, "Member 'FSBZDialogLineDefinition::AudioEvent' has a wrong offset!");
static_assert(offsetof(FSBZDialogLineDefinition, CommentState) == 0x000010, "Member 'FSBZDialogLineDefinition::CommentState' has a wrong offset!");
static_assert(offsetof(FSBZDialogLineDefinition, Delay) == 0x000020, "Member 'FSBZDialogLineDefinition::Delay' has a wrong offset!");

// ScriptStruct Starbreeze.SBZDrillRepData
// 0x0028 (0x0028 - 0x0000)
struct FSBZDrillRepData final
{
public:
	ESBZDrillState                                State;                                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProgressLast;                                      // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeatLast;                                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeatPerSec;                                        // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProgressPerSec;                                    // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastTime;                                          // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFastSpeed;                                        // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USBZDrillMaterial*                      CurrentMaterial;                                   // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZDrillRepData) == 0x000008, "Wrong alignment on FSBZDrillRepData");
static_assert(sizeof(FSBZDrillRepData) == 0x000028, "Wrong size on FSBZDrillRepData");
static_assert(offsetof(FSBZDrillRepData, State) == 0x000000, "Member 'FSBZDrillRepData::State' has a wrong offset!");
static_assert(offsetof(FSBZDrillRepData, ProgressLast) == 0x000004, "Member 'FSBZDrillRepData::ProgressLast' has a wrong offset!");
static_assert(offsetof(FSBZDrillRepData, HeatLast) == 0x000008, "Member 'FSBZDrillRepData::HeatLast' has a wrong offset!");
static_assert(offsetof(FSBZDrillRepData, HeatPerSec) == 0x00000C, "Member 'FSBZDrillRepData::HeatPerSec' has a wrong offset!");
static_assert(offsetof(FSBZDrillRepData, ProgressPerSec) == 0x000010, "Member 'FSBZDrillRepData::ProgressPerSec' has a wrong offset!");
static_assert(offsetof(FSBZDrillRepData, LastTime) == 0x000014, "Member 'FSBZDrillRepData::LastTime' has a wrong offset!");
static_assert(offsetof(FSBZDrillRepData, bFastSpeed) == 0x000018, "Member 'FSBZDrillRepData::bFastSpeed' has a wrong offset!");
static_assert(offsetof(FSBZDrillRepData, CurrentMaterial) == 0x000020, "Member 'FSBZDrillRepData::CurrentMaterial' has a wrong offset!");

// ScriptStruct Starbreeze.SBZDropPlaceableEquippableData
// 0x0040 (0x0040 - 0x0000)
struct FSBZDropPlaceableEquippableData final
{
public:
	struct FVector_NetQuantize                    Location;                                          // 0x0000(0x000C)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSBZQuat_NetQuantizeNormal             Quat;                                              // 0x0010(0x0010)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    LinearVelocity;                                    // 0x0020(0x000C)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 AngularVelocity;                                   // 0x002C(0x000C)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZDropPlaceableEquippableData) == 0x000010, "Wrong alignment on FSBZDropPlaceableEquippableData");
static_assert(sizeof(FSBZDropPlaceableEquippableData) == 0x000040, "Wrong size on FSBZDropPlaceableEquippableData");
static_assert(offsetof(FSBZDropPlaceableEquippableData, Location) == 0x000000, "Member 'FSBZDropPlaceableEquippableData::Location' has a wrong offset!");
static_assert(offsetof(FSBZDropPlaceableEquippableData, Quat) == 0x000010, "Member 'FSBZDropPlaceableEquippableData::Quat' has a wrong offset!");
static_assert(offsetof(FSBZDropPlaceableEquippableData, LinearVelocity) == 0x000020, "Member 'FSBZDropPlaceableEquippableData::LinearVelocity' has a wrong offset!");
static_assert(offsetof(FSBZDropPlaceableEquippableData, AngularVelocity) == 0x00002C, "Member 'FSBZDropPlaceableEquippableData::AngularVelocity' has a wrong offset!");

// ScriptStruct Starbreeze.SBZEmoteMapping
// 0x0028 (0x0028 - 0x0000)
struct FSBZEmoteMapping final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Text;                                              // 0x0010(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZEmoteMapping) == 0x000008, "Wrong alignment on FSBZEmoteMapping");
static_assert(sizeof(FSBZEmoteMapping) == 0x000028, "Wrong size on FSBZEmoteMapping");
static_assert(offsetof(FSBZEmoteMapping, Tag) == 0x000000, "Member 'FSBZEmoteMapping::Tag' has a wrong offset!");
static_assert(offsetof(FSBZEmoteMapping, Text) == 0x000010, "Member 'FSBZEmoteMapping::Text' has a wrong offset!");

// ScriptStruct Starbreeze.SBZExplosionResult
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FSBZExplosionResult final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZExplosionResult) == 0x000008, "Wrong alignment on FSBZExplosionResult");
static_assert(sizeof(FSBZExplosionResult) == 0x000028, "Wrong size on FSBZExplosionResult");

// ScriptStruct Starbreeze.SBZFactionAttitude
// 0x001C (0x001C - 0x0000)
struct FSBZFactionAttitude final
{
public:
	struct FSBZFactionNameHelper                  SourceFaction;                                     // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSBZFactionNameHelper                  TargetFaction;                                     // 0x000C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZFactionAttitude                           Attitude;                                          // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZFactionAttitude) == 0x000004, "Wrong alignment on FSBZFactionAttitude");
static_assert(sizeof(FSBZFactionAttitude) == 0x00001C, "Wrong size on FSBZFactionAttitude");
static_assert(offsetof(FSBZFactionAttitude, SourceFaction) == 0x000000, "Member 'FSBZFactionAttitude::SourceFaction' has a wrong offset!");
static_assert(offsetof(FSBZFactionAttitude, TargetFaction) == 0x00000C, "Member 'FSBZFactionAttitude::TargetFaction' has a wrong offset!");
static_assert(offsetof(FSBZFactionAttitude, Attitude) == 0x000018, "Member 'FSBZFactionAttitude::Attitude' has a wrong offset!");

// ScriptStruct Starbreeze.SBZFactionIdHelper
// 0x0001 (0x0001 - 0x0000)
struct FSBZFactionIdHelper final
{
public:
	uint8                                         FactionId;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZFactionIdHelper) == 0x000001, "Wrong alignment on FSBZFactionIdHelper");
static_assert(sizeof(FSBZFactionIdHelper) == 0x000001, "Wrong size on FSBZFactionIdHelper");
static_assert(offsetof(FSBZFactionIdHelper, FactionId) == 0x000000, "Member 'FSBZFactionIdHelper::FactionId' has a wrong offset!");

// ScriptStruct Starbreeze.SBZReportPlayerInfo
// 0x0030 (0x0030 - 0x0000)
struct FSBZReportPlayerInfo final
{
public:
	class FString                                 UserId;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Comment;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Reason;                                            // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZReportPlayerInfo) == 0x000008, "Wrong alignment on FSBZReportPlayerInfo");
static_assert(sizeof(FSBZReportPlayerInfo) == 0x000030, "Wrong size on FSBZReportPlayerInfo");
static_assert(offsetof(FSBZReportPlayerInfo, UserId) == 0x000000, "Member 'FSBZReportPlayerInfo::UserId' has a wrong offset!");
static_assert(offsetof(FSBZReportPlayerInfo, Comment) == 0x000010, "Member 'FSBZReportPlayerInfo::Comment' has a wrong offset!");
static_assert(offsetof(FSBZReportPlayerInfo, Reason) == 0x000020, "Member 'FSBZReportPlayerInfo::Reason' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPlaceableToolPlacedData
// 0x0010 (0x0010 - 0x0000)
struct FSBZPlaceableToolPlacedData final : public FSBZGameEventStructBase
{
public:
	class ASBZCharacter*                          OwnerCharacter;                                    // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASBZPlaceableToolBase*                  PlaceableTool;                                     // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPlaceableToolPlacedData) == 0x000008, "Wrong alignment on FSBZPlaceableToolPlacedData");
static_assert(sizeof(FSBZPlaceableToolPlacedData) == 0x000010, "Wrong size on FSBZPlaceableToolPlacedData");
static_assert(offsetof(FSBZPlaceableToolPlacedData, OwnerCharacter) == 0x000000, "Member 'FSBZPlaceableToolPlacedData::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(FSBZPlaceableToolPlacedData, PlaceableTool) == 0x000008, "Member 'FSBZPlaceableToolPlacedData::PlaceableTool' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPlaceableChargesPlacedData
// 0x0010 (0x0010 - 0x0000)
struct FSBZPlaceableChargesPlacedData final : public FSBZGameEventStructBase
{
public:
	class ASBZCharacter*                          OwnerCharacter;                                    // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASBZPlaceableCharges*                   PlaceableCharge;                                   // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPlaceableChargesPlacedData) == 0x000008, "Wrong alignment on FSBZPlaceableChargesPlacedData");
static_assert(sizeof(FSBZPlaceableChargesPlacedData) == 0x000010, "Wrong size on FSBZPlaceableChargesPlacedData");
static_assert(offsetof(FSBZPlaceableChargesPlacedData, OwnerCharacter) == 0x000000, "Member 'FSBZPlaceableChargesPlacedData::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(FSBZPlaceableChargesPlacedData, PlaceableCharge) == 0x000008, "Member 'FSBZPlaceableChargesPlacedData::PlaceableCharge' has a wrong offset!");

// ScriptStruct Starbreeze.SBZLastAttackerData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FSBZLastAttackerData final : public FSBZGameEventStructBase
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZLastAttackerData) == 0x000008, "Wrong alignment on FSBZLastAttackerData");
static_assert(sizeof(FSBZLastAttackerData) == 0x000018, "Wrong size on FSBZLastAttackerData");

// ScriptStruct Starbreeze.SBZGamepadBindingsPreset
// 0x0038 (0x0038 - 0x0000)
struct FSBZGamepadBindingsPreset final
{
public:
	class FText                                   NameLocalized;                                     // 0x0000(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0018(0x000C)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSBZGamepadBinding>             Bindings;                                          // 0x0028(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZGamepadBindingsPreset) == 0x000008, "Wrong alignment on FSBZGamepadBindingsPreset");
static_assert(sizeof(FSBZGamepadBindingsPreset) == 0x000038, "Wrong size on FSBZGamepadBindingsPreset");
static_assert(offsetof(FSBZGamepadBindingsPreset, NameLocalized) == 0x000000, "Member 'FSBZGamepadBindingsPreset::NameLocalized' has a wrong offset!");
static_assert(offsetof(FSBZGamepadBindingsPreset, Name) == 0x000018, "Member 'FSBZGamepadBindingsPreset::Name' has a wrong offset!");
static_assert(offsetof(FSBZGamepadBindingsPreset, Bindings) == 0x000028, "Member 'FSBZGamepadBindingsPreset::Bindings' has a wrong offset!");

// ScriptStruct Starbreeze.SBZGameplayAbilityActorInfo
// 0x0000 (0x0050 - 0x0050)
struct FSBZGameplayAbilityActorInfo final : public FGameplayAbilityActorInfo
{
};
static_assert(alignof(FSBZGameplayAbilityActorInfo) == 0x000008, "Wrong alignment on FSBZGameplayAbilityActorInfo");
static_assert(sizeof(FSBZGameplayAbilityActorInfo) == 0x000050, "Wrong size on FSBZGameplayAbilityActorInfo");

// ScriptStruct Starbreeze.SBZGameplayEffectData
// 0x0010 (0x0010 - 0x0000)
struct FSBZGameplayEffectData final
{
public:
	TSubclassOf<class UGameplayEffect>            GameplayEffectClass;                               // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Level;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StackCount;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZGameplayEffectData) == 0x000008, "Wrong alignment on FSBZGameplayEffectData");
static_assert(sizeof(FSBZGameplayEffectData) == 0x000010, "Wrong size on FSBZGameplayEffectData");
static_assert(offsetof(FSBZGameplayEffectData, GameplayEffectClass) == 0x000000, "Member 'FSBZGameplayEffectData::GameplayEffectClass' has a wrong offset!");
static_assert(offsetof(FSBZGameplayEffectData, Level) == 0x000008, "Member 'FSBZGameplayEffectData::Level' has a wrong offset!");
static_assert(offsetof(FSBZGameplayEffectData, StackCount) == 0x00000C, "Member 'FSBZGameplayEffectData::StackCount' has a wrong offset!");

// ScriptStruct Starbreeze.SBZGameplayEffectContext
// 0x0028 (0x0098 - 0x0070)
struct FSBZGameplayEffectContext final : public FGameplayEffectContext
{
public:
	uint8                                         Pad_70[0x28];                                      // 0x0070(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZGameplayEffectContext) == 0x000008, "Wrong alignment on FSBZGameplayEffectContext");
static_assert(sizeof(FSBZGameplayEffectContext) == 0x000098, "Wrong size on FSBZGameplayEffectContext");

// ScriptStruct Starbreeze.SBZClientConfiguration
// 0x0060 (0x0060 - 0x0000)
struct FSBZClientConfiguration final
{
public:
	TArray<struct FSBZItemRewardConfiguration>    ItemRewardConfigurationArray;                      // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FString, int32>                    LoadProgressionValueMap;                           // 0x0010(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZClientConfiguration) == 0x000008, "Wrong alignment on FSBZClientConfiguration");
static_assert(sizeof(FSBZClientConfiguration) == 0x000060, "Wrong size on FSBZClientConfiguration");
static_assert(offsetof(FSBZClientConfiguration, ItemRewardConfigurationArray) == 0x000000, "Member 'FSBZClientConfiguration::ItemRewardConfigurationArray' has a wrong offset!");
static_assert(offsetof(FSBZClientConfiguration, LoadProgressionValueMap) == 0x000010, "Member 'FSBZClientConfiguration::LoadProgressionValueMap' has a wrong offset!");

// ScriptStruct Starbreeze.SBZFeatureToggleMap
// 0x0050 (0x0050 - 0x0000)
struct FSBZFeatureToggleMap final
{
public:
	TMap<class FString, bool>                     FeatureToggleMapping;                              // 0x0000(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZFeatureToggleMap) == 0x000008, "Wrong alignment on FSBZFeatureToggleMap");
static_assert(sizeof(FSBZFeatureToggleMap) == 0x000050, "Wrong size on FSBZFeatureToggleMap");
static_assert(offsetof(FSBZFeatureToggleMap, FeatureToggleMapping) == 0x000000, "Member 'FSBZFeatureToggleMap::FeatureToggleMapping' has a wrong offset!");

// ScriptStruct Starbreeze.SBZChallengeRecommandationSettings
// 0x0010 (0x0010 - 0x0000)
struct FSBZChallengeRecommandationSettings final
{
public:
	TArray<struct FSBZChallengeRecommandationBlock> BlockArray;                                      // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZChallengeRecommandationSettings) == 0x000008, "Wrong alignment on FSBZChallengeRecommandationSettings");
static_assert(sizeof(FSBZChallengeRecommandationSettings) == 0x000010, "Wrong size on FSBZChallengeRecommandationSettings");
static_assert(offsetof(FSBZChallengeRecommandationSettings, BlockArray) == 0x000000, "Member 'FSBZChallengeRecommandationSettings::BlockArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZRewardRecuctionData
// 0x000C (0x000C - 0x0000)
struct FSBZRewardRecuctionData final
{
public:
	ESBZRewardReductionType                       RewardReductionType;                               // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReductionPercentage;                               // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxReductionPercentage;                            // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZRewardRecuctionData) == 0x000004, "Wrong alignment on FSBZRewardRecuctionData");
static_assert(sizeof(FSBZRewardRecuctionData) == 0x00000C, "Wrong size on FSBZRewardRecuctionData");
static_assert(offsetof(FSBZRewardRecuctionData, RewardReductionType) == 0x000000, "Member 'FSBZRewardRecuctionData::RewardReductionType' has a wrong offset!");
static_assert(offsetof(FSBZRewardRecuctionData, ReductionPercentage) == 0x000004, "Member 'FSBZRewardRecuctionData::ReductionPercentage' has a wrong offset!");
static_assert(offsetof(FSBZRewardRecuctionData, MaxReductionPercentage) == 0x000008, "Member 'FSBZRewardRecuctionData::MaxReductionPercentage' has a wrong offset!");

// ScriptStruct Starbreeze.SBZTitleData
// 0x0010 (0x0010 - 0x0000)
struct FSBZTitleData final
{
public:
	class FString                                 TitleData;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZTitleData) == 0x000008, "Wrong alignment on FSBZTitleData");
static_assert(sizeof(FSBZTitleData) == 0x000010, "Wrong size on FSBZTitleData");
static_assert(offsetof(FSBZTitleData, TitleData) == 0x000000, "Member 'FSBZTitleData::TitleData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZHeistCollection
// 0x0030 (0x0030 - 0x0000)
struct FSBZHeistCollection final
{
public:
	class FText                                   HeistCollectionName;                               // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                LevelPaths;                                        // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bContainsStoryModeContent;                         // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZHeistCollection) == 0x000008, "Wrong alignment on FSBZHeistCollection");
static_assert(sizeof(FSBZHeistCollection) == 0x000030, "Wrong size on FSBZHeistCollection");
static_assert(offsetof(FSBZHeistCollection, HeistCollectionName) == 0x000000, "Member 'FSBZHeistCollection::HeistCollectionName' has a wrong offset!");
static_assert(offsetof(FSBZHeistCollection, LevelPaths) == 0x000018, "Member 'FSBZHeistCollection::LevelPaths' has a wrong offset!");
static_assert(offsetof(FSBZHeistCollection, bContainsStoryModeContent) == 0x000028, "Member 'FSBZHeistCollection::bContainsStoryModeContent' has a wrong offset!");

// ScriptStruct Starbreeze.SBZBackendSettings
// 0x0018 (0x0018 - 0x0000)
struct FSBZBackendSettings final
{
public:
	class FString                                 Platform;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGameSenseEnabled;                               // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTelemetryEnabled;                               // 0x0011(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        PopupsShownBitmask;                                // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZBackendSettings) == 0x000008, "Wrong alignment on FSBZBackendSettings");
static_assert(sizeof(FSBZBackendSettings) == 0x000018, "Wrong size on FSBZBackendSettings");
static_assert(offsetof(FSBZBackendSettings, Platform) == 0x000000, "Member 'FSBZBackendSettings::Platform' has a wrong offset!");
static_assert(offsetof(FSBZBackendSettings, bIsGameSenseEnabled) == 0x000010, "Member 'FSBZBackendSettings::bIsGameSenseEnabled' has a wrong offset!");
static_assert(offsetof(FSBZBackendSettings, bIsTelemetryEnabled) == 0x000011, "Member 'FSBZBackendSettings::bIsTelemetryEnabled' has a wrong offset!");
static_assert(offsetof(FSBZBackendSettings, PopupsShownBitmask) == 0x000014, "Member 'FSBZBackendSettings::PopupsShownBitmask' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPlatformsBackendSettingsInfo
// 0x0010 (0x0010 - 0x0000)
struct FSBZPlatformsBackendSettingsInfo final
{
public:
	TArray<struct FSBZBackendSettings>            PlatformBackendSettings;                           // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPlatformsBackendSettingsInfo) == 0x000008, "Wrong alignment on FSBZPlatformsBackendSettingsInfo");
static_assert(sizeof(FSBZPlatformsBackendSettingsInfo) == 0x000010, "Wrong size on FSBZPlatformsBackendSettingsInfo");
static_assert(offsetof(FSBZPlatformsBackendSettingsInfo, PlatformBackendSettings) == 0x000000, "Member 'FSBZPlatformsBackendSettingsInfo::PlatformBackendSettings' has a wrong offset!");

// ScriptStruct Starbreeze.SBZReplicatedGasVolumeComponentData
// 0x0010 (0x0010 - 0x0000)
struct FSBZReplicatedGasVolumeComponentData final
{
public:
	bool                                          bInit;                                             // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExpansionScalar;                                   // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZReplicatedGasVolumeComponentData) == 0x000004, "Wrong alignment on FSBZReplicatedGasVolumeComponentData");
static_assert(sizeof(FSBZReplicatedGasVolumeComponentData) == 0x000010, "Wrong size on FSBZReplicatedGasVolumeComponentData");
static_assert(offsetof(FSBZReplicatedGasVolumeComponentData, bInit) == 0x000000, "Member 'FSBZReplicatedGasVolumeComponentData::bInit' has a wrong offset!");
static_assert(offsetof(FSBZReplicatedGasVolumeComponentData, Duration) == 0x000004, "Member 'FSBZReplicatedGasVolumeComponentData::Duration' has a wrong offset!");
static_assert(offsetof(FSBZReplicatedGasVolumeComponentData, ExpansionScalar) == 0x000008, "Member 'FSBZReplicatedGasVolumeComponentData::ExpansionScalar' has a wrong offset!");
static_assert(offsetof(FSBZReplicatedGasVolumeComponentData, Radius) == 0x00000C, "Member 'FSBZReplicatedGasVolumeComponentData::Radius' has a wrong offset!");

// ScriptStruct Starbreeze.SBZGateExplosionData
// 0x0040 (0x0040 - 0x0000)
struct FSBZGateExplosionData final
{
public:
	bool                                          bIsCalculated;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CalculatedClosePaddingX;                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSBZExplosionBox>               BoxArray;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                ForceOrigin;                                       // 0x0018(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            GameplayEffectClass;                               // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerImpulse;                                     // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZDamageWeight                              DamageWeight;                                      // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageWeightModifier;                              // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZGateExplosionData) == 0x000008, "Wrong alignment on FSBZGateExplosionData");
static_assert(sizeof(FSBZGateExplosionData) == 0x000040, "Wrong size on FSBZGateExplosionData");
static_assert(offsetof(FSBZGateExplosionData, bIsCalculated) == 0x000000, "Member 'FSBZGateExplosionData::bIsCalculated' has a wrong offset!");
static_assert(offsetof(FSBZGateExplosionData, CalculatedClosePaddingX) == 0x000004, "Member 'FSBZGateExplosionData::CalculatedClosePaddingX' has a wrong offset!");
static_assert(offsetof(FSBZGateExplosionData, BoxArray) == 0x000008, "Member 'FSBZGateExplosionData::BoxArray' has a wrong offset!");
static_assert(offsetof(FSBZGateExplosionData, ForceOrigin) == 0x000018, "Member 'FSBZGateExplosionData::ForceOrigin' has a wrong offset!");
static_assert(offsetof(FSBZGateExplosionData, GameplayEffectClass) == 0x000028, "Member 'FSBZGateExplosionData::GameplayEffectClass' has a wrong offset!");
static_assert(offsetof(FSBZGateExplosionData, PlayerImpulse) == 0x000030, "Member 'FSBZGateExplosionData::PlayerImpulse' has a wrong offset!");
static_assert(offsetof(FSBZGateExplosionData, DamageWeight) == 0x000034, "Member 'FSBZGateExplosionData::DamageWeight' has a wrong offset!");
static_assert(offsetof(FSBZGateExplosionData, DamageWeightModifier) == 0x000038, "Member 'FSBZGateExplosionData::DamageWeightModifier' has a wrong offset!");

// ScriptStruct Starbreeze.ECommerenceRewardNotifPayload
// 0x0050 (0x0050 - 0x0000)
struct FECommerenceRewardNotifPayload final
{
public:
	class FString                                 rewardTopic;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 rewardCode;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 rewardCondition;                                   // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAccelByteModelsEntitlementSummary> EntitlementSummaries;                          // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAccelByteModelsCreditSummary>  CreditSummaries;                                   // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FECommerenceRewardNotifPayload) == 0x000008, "Wrong alignment on FECommerenceRewardNotifPayload");
static_assert(sizeof(FECommerenceRewardNotifPayload) == 0x000050, "Wrong size on FECommerenceRewardNotifPayload");
static_assert(offsetof(FECommerenceRewardNotifPayload, rewardTopic) == 0x000000, "Member 'FECommerenceRewardNotifPayload::rewardTopic' has a wrong offset!");
static_assert(offsetof(FECommerenceRewardNotifPayload, rewardCode) == 0x000010, "Member 'FECommerenceRewardNotifPayload::rewardCode' has a wrong offset!");
static_assert(offsetof(FECommerenceRewardNotifPayload, rewardCondition) == 0x000020, "Member 'FECommerenceRewardNotifPayload::rewardCondition' has a wrong offset!");
static_assert(offsetof(FECommerenceRewardNotifPayload, EntitlementSummaries) == 0x000030, "Member 'FECommerenceRewardNotifPayload::EntitlementSummaries' has a wrong offset!");
static_assert(offsetof(FECommerenceRewardNotifPayload, CreditSummaries) == 0x000040, "Member 'FECommerenceRewardNotifPayload::CreditSummaries' has a wrong offset!");

// ScriptStruct Starbreeze.SBZHackableDisplayText
// 0x0060 (0x0060 - 0x0000)
struct FSBZHackableDisplayText final
{
public:
	class FText                                   Header;                                            // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ImportantInfo;                                     // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   AdditionalText;                                    // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZHackableDisplayText) == 0x000008, "Wrong alignment on FSBZHackableDisplayText");
static_assert(sizeof(FSBZHackableDisplayText) == 0x000060, "Wrong size on FSBZHackableDisplayText");
static_assert(offsetof(FSBZHackableDisplayText, Header) == 0x000000, "Member 'FSBZHackableDisplayText::Header' has a wrong offset!");
static_assert(offsetof(FSBZHackableDisplayText, Description) == 0x000018, "Member 'FSBZHackableDisplayText::Description' has a wrong offset!");
static_assert(offsetof(FSBZHackableDisplayText, ImportantInfo) == 0x000030, "Member 'FSBZHackableDisplayText::ImportantInfo' has a wrong offset!");
static_assert(offsetof(FSBZHackableDisplayText, AdditionalText) == 0x000048, "Member 'FSBZHackableDisplayText::AdditionalText' has a wrong offset!");

// ScriptStruct Starbreeze.SBZHackableToolTargetData
// 0x0010 (0x0018 - 0x0008)
struct FSBZHackableToolTargetData final : public FGameplayAbilityTargetData
{
public:
	class AActor*                                 HackableActor;                                     // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZHackableToolTargetData) == 0x000008, "Wrong alignment on FSBZHackableToolTargetData");
static_assert(sizeof(FSBZHackableToolTargetData) == 0x000018, "Wrong size on FSBZHackableToolTargetData");
static_assert(offsetof(FSBZHackableToolTargetData, HackableActor) == 0x000008, "Member 'FSBZHackableToolTargetData::HackableActor' has a wrong offset!");

// ScriptStruct Starbreeze.SBZHeightTransitionCameraSettings
// 0x0010 (0x0010 - 0x0000)
struct FSBZHeightTransitionCameraSettings final
{
public:
	float                                         TransitionSpeed;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             BlendOption;                                       // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            BlendCustomCurve;                                  // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZHeightTransitionCameraSettings) == 0x000008, "Wrong alignment on FSBZHeightTransitionCameraSettings");
static_assert(sizeof(FSBZHeightTransitionCameraSettings) == 0x000010, "Wrong size on FSBZHeightTransitionCameraSettings");
static_assert(offsetof(FSBZHeightTransitionCameraSettings, TransitionSpeed) == 0x000000, "Member 'FSBZHeightTransitionCameraSettings::TransitionSpeed' has a wrong offset!");
static_assert(offsetof(FSBZHeightTransitionCameraSettings, BlendOption) == 0x000004, "Member 'FSBZHeightTransitionCameraSettings::BlendOption' has a wrong offset!");
static_assert(offsetof(FSBZHeightTransitionCameraSettings, BlendCustomCurve) == 0x000008, "Member 'FSBZHeightTransitionCameraSettings::BlendCustomCurve' has a wrong offset!");

// ScriptStruct Starbreeze.SBZHeistDataLevelPair
// 0x0028 (0x0028 - 0x0000)
struct FSBZHeistDataLevelPair final
{
public:
	class UPD3HeistDataAsset*                     HeistData;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        LevelPath;                                         // 0x0008(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZHeistDataLevelPair) == 0x000008, "Wrong alignment on FSBZHeistDataLevelPair");
static_assert(sizeof(FSBZHeistDataLevelPair) == 0x000028, "Wrong size on FSBZHeistDataLevelPair");
static_assert(offsetof(FSBZHeistDataLevelPair, HeistData) == 0x000000, "Member 'FSBZHeistDataLevelPair::HeistData' has a wrong offset!");
static_assert(offsetof(FSBZHeistDataLevelPair, LevelPath) == 0x000008, "Member 'FSBZHeistDataLevelPair::LevelPath' has a wrong offset!");

// ScriptStruct Starbreeze.SBZHitIndicatorSettings
// 0x0034 (0x0034 - 0x0000)
struct FSBZHitIndicatorSettings final
{
public:
	struct FLinearColor                           HitIndicatorColorHit;                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           HitIndicatorColorCrit;                             // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           HitIndicatorColorKill;                             // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitIndicatorScale;                                 // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZHitIndicatorSettings) == 0x000004, "Wrong alignment on FSBZHitIndicatorSettings");
static_assert(sizeof(FSBZHitIndicatorSettings) == 0x000034, "Wrong size on FSBZHitIndicatorSettings");
static_assert(offsetof(FSBZHitIndicatorSettings, HitIndicatorColorHit) == 0x000000, "Member 'FSBZHitIndicatorSettings::HitIndicatorColorHit' has a wrong offset!");
static_assert(offsetof(FSBZHitIndicatorSettings, HitIndicatorColorCrit) == 0x000010, "Member 'FSBZHitIndicatorSettings::HitIndicatorColorCrit' has a wrong offset!");
static_assert(offsetof(FSBZHitIndicatorSettings, HitIndicatorColorKill) == 0x000020, "Member 'FSBZHitIndicatorSettings::HitIndicatorColorKill' has a wrong offset!");
static_assert(offsetof(FSBZHitIndicatorSettings, HitIndicatorScale) == 0x000030, "Member 'FSBZHitIndicatorSettings::HitIndicatorScale' has a wrong offset!");

// ScriptStruct Starbreeze.SBZHitResult
// 0x0030 (0x0030 - 0x0000)
struct FSBZHitResult final
{
public:
	TWeakObjectPtr<class UPrimitiveComponent>     ComponentPtr;                                      // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UPhysicalMaterial>       PhysMaterialPtr;                                   // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x20];                                      // 0x0010(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZHitResult) == 0x000004, "Wrong alignment on FSBZHitResult");
static_assert(sizeof(FSBZHitResult) == 0x000030, "Wrong size on FSBZHitResult");
static_assert(offsetof(FSBZHitResult, ComponentPtr) == 0x000000, "Member 'FSBZHitResult::ComponentPtr' has a wrong offset!");
static_assert(offsetof(FSBZHitResult, PhysMaterialPtr) == 0x000008, "Member 'FSBZHitResult::PhysMaterialPtr' has a wrong offset!");

// ScriptStruct Starbreeze.SBZHoldOutTimedEventData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FSBZHoldOutTimedEventData final
{
public:
	float                                         TriggerDelay;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EventTag;                                          // 0x0004(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZHoldOutTimedEventData) == 0x000008, "Wrong alignment on FSBZHoldOutTimedEventData");
static_assert(sizeof(FSBZHoldOutTimedEventData) == 0x000018, "Wrong size on FSBZHoldOutTimedEventData");
static_assert(offsetof(FSBZHoldOutTimedEventData, TriggerDelay) == 0x000000, "Member 'FSBZHoldOutTimedEventData::TriggerDelay' has a wrong offset!");
static_assert(offsetof(FSBZHoldOutTimedEventData, EventTag) == 0x000004, "Member 'FSBZHoldOutTimedEventData::EventTag' has a wrong offset!");

// ScriptStruct Starbreeze.SBZHoldOutDroneSoundAndPriority
// 0x0010 (0x0010 - 0x0000)
struct FSBZHoldOutDroneSoundAndPriority final
{
public:
	class UAkAudioEvent*                          Sound;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoolDown;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZHoldOutDroneSoundAndPriority) == 0x000008, "Wrong alignment on FSBZHoldOutDroneSoundAndPriority");
static_assert(sizeof(FSBZHoldOutDroneSoundAndPriority) == 0x000010, "Wrong size on FSBZHoldOutDroneSoundAndPriority");
static_assert(offsetof(FSBZHoldOutDroneSoundAndPriority, Sound) == 0x000000, "Member 'FSBZHoldOutDroneSoundAndPriority::Sound' has a wrong offset!");
static_assert(offsetof(FSBZHoldOutDroneSoundAndPriority, Priority) == 0x000008, "Member 'FSBZHoldOutDroneSoundAndPriority::Priority' has a wrong offset!");
static_assert(offsetof(FSBZHoldOutDroneSoundAndPriority, CoolDown) == 0x00000C, "Member 'FSBZHoldOutDroneSoundAndPriority::CoolDown' has a wrong offset!");

// ScriptStruct Starbreeze.SBZDroneVoiceInfoCallback
// 0x0008 (0x0008 - 0x0000)
struct FSBZDroneVoiceInfoCallback final
{
public:
	class USBZHoldOutDroneVoiceComponent*         VoiceComponent;                                    // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZDroneVoiceInfoCallback) == 0x000008, "Wrong alignment on FSBZDroneVoiceInfoCallback");
static_assert(sizeof(FSBZDroneVoiceInfoCallback) == 0x000008, "Wrong size on FSBZDroneVoiceInfoCallback");
static_assert(offsetof(FSBZDroneVoiceInfoCallback, VoiceComponent) == 0x000000, "Member 'FSBZDroneVoiceInfoCallback::VoiceComponent' has a wrong offset!");

// ScriptStruct Starbreeze.SBZHoldOutTrackedBagEventData
// 0x0028 (0x0028 - 0x0000)
struct FSBZHoldOutTrackedBagEventData final
{
public:
	float                                         DistanceFromQuerier;                               // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  Tags;                                              // 0x0008(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZHoldOutTrackedBagEventData) == 0x000008, "Wrong alignment on FSBZHoldOutTrackedBagEventData");
static_assert(sizeof(FSBZHoldOutTrackedBagEventData) == 0x000028, "Wrong size on FSBZHoldOutTrackedBagEventData");
static_assert(offsetof(FSBZHoldOutTrackedBagEventData, DistanceFromQuerier) == 0x000000, "Member 'FSBZHoldOutTrackedBagEventData::DistanceFromQuerier' has a wrong offset!");
static_assert(offsetof(FSBZHoldOutTrackedBagEventData, Tags) == 0x000008, "Member 'FSBZHoldOutTrackedBagEventData::Tags' has a wrong offset!");

// ScriptStruct Starbreeze.SBZHoldOutBagTrackerData
// 0x0010 (0x0010 - 0x0000)
struct FSBZHoldOutBagTrackerData final
{
public:
	class ASBZBagItem*                            Bag;                                               // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZHoldOutBagTrackerData) == 0x000008, "Wrong alignment on FSBZHoldOutBagTrackerData");
static_assert(sizeof(FSBZHoldOutBagTrackerData) == 0x000010, "Wrong size on FSBZHoldOutBagTrackerData");
static_assert(offsetof(FSBZHoldOutBagTrackerData, Bag) == 0x000000, "Member 'FSBZHoldOutBagTrackerData::Bag' has a wrong offset!");

// ScriptStruct Starbreeze.SBZHoldOutDamageEventData
// 0x00B8 (0x00B8 - 0x0000)
struct FSBZHoldOutDamageEventData final
{
public:
	struct FSBZHoldOutDamageEventFilter           Filter;                                            // 0x0000(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  Tags;                                              // 0x0048(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FGameplayTagContainer> TagsPerVictimType;                       // 0x0068(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZHoldOutDamageEventData) == 0x000008, "Wrong alignment on FSBZHoldOutDamageEventData");
static_assert(sizeof(FSBZHoldOutDamageEventData) == 0x0000B8, "Wrong size on FSBZHoldOutDamageEventData");
static_assert(offsetof(FSBZHoldOutDamageEventData, Filter) == 0x000000, "Member 'FSBZHoldOutDamageEventData::Filter' has a wrong offset!");
static_assert(offsetof(FSBZHoldOutDamageEventData, Tags) == 0x000048, "Member 'FSBZHoldOutDamageEventData::Tags' has a wrong offset!");
static_assert(offsetof(FSBZHoldOutDamageEventData, TagsPerVictimType) == 0x000068, "Member 'FSBZHoldOutDamageEventData::TagsPerVictimType' has a wrong offset!");

// ScriptStruct Starbreeze.SBZHoldOutDroneTagReactionConfigArray
// 0x0010 (0x0010 - 0x0000)
struct FSBZHoldOutDroneTagReactionConfigArray final
{
public:
	TArray<struct FSBZHoldOutDroneTagReactionConfig> Configs;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZHoldOutDroneTagReactionConfigArray) == 0x000008, "Wrong alignment on FSBZHoldOutDroneTagReactionConfigArray");
static_assert(sizeof(FSBZHoldOutDroneTagReactionConfigArray) == 0x000010, "Wrong size on FSBZHoldOutDroneTagReactionConfigArray");
static_assert(offsetof(FSBZHoldOutDroneTagReactionConfigArray, Configs) == 0x000000, "Member 'FSBZHoldOutDroneTagReactionConfigArray::Configs' has a wrong offset!");

// ScriptStruct Starbreeze.SBZHoldOutModifiers
// 0x0050 (0x0050 - 0x0000)
struct FSBZHoldOutModifiers final
{
public:
	TMap<struct FGameplayTag, int32>              ModifierCounts;                                    // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZHoldOutModifiers) == 0x000008, "Wrong alignment on FSBZHoldOutModifiers");
static_assert(sizeof(FSBZHoldOutModifiers) == 0x000050, "Wrong size on FSBZHoldOutModifiers");
static_assert(offsetof(FSBZHoldOutModifiers, ModifierCounts) == 0x000000, "Member 'FSBZHoldOutModifiers::ModifierCounts' has a wrong offset!");

// ScriptStruct Starbreeze.SBZHurtReactionPrediction
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FSBZHurtReactionPrediction final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZHurtReactionPrediction) == 0x000004, "Wrong alignment on FSBZHurtReactionPrediction");
static_assert(sizeof(FSBZHurtReactionPrediction) == 0x000010, "Wrong size on FSBZHurtReactionPrediction");

// ScriptStruct Starbreeze.SBZHurtReactionArray
// 0x0010 (0x0010 - 0x0000)
struct FSBZHurtReactionArray final
{
public:
	TArray<struct FSBZHurtReactionAnimation>      MontageArray;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZHurtReactionArray) == 0x000008, "Wrong alignment on FSBZHurtReactionArray");
static_assert(sizeof(FSBZHurtReactionArray) == 0x000010, "Wrong size on FSBZHurtReactionArray");
static_assert(offsetof(FSBZHurtReactionArray, MontageArray) == 0x000000, "Member 'FSBZHurtReactionArray::MontageArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZHurtReactionPose
// 0x0180 (0x0180 - 0x0000)
struct FSBZHurtReactionPose final
{
public:
	struct FSBZBoneHurtReaction                   Standing;                                          // 0x0000(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSBZBoneHurtReaction                   Crouching;                                         // 0x0060(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSBZBoneHurtReaction                   LyingOnFront;                                      // 0x00C0(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSBZBoneHurtReaction                   LyingOnBack;                                       // 0x0120(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZHurtReactionPose) == 0x000008, "Wrong alignment on FSBZHurtReactionPose");
static_assert(sizeof(FSBZHurtReactionPose) == 0x000180, "Wrong size on FSBZHurtReactionPose");
static_assert(offsetof(FSBZHurtReactionPose, Standing) == 0x000000, "Member 'FSBZHurtReactionPose::Standing' has a wrong offset!");
static_assert(offsetof(FSBZHurtReactionPose, Crouching) == 0x000060, "Member 'FSBZHurtReactionPose::Crouching' has a wrong offset!");
static_assert(offsetof(FSBZHurtReactionPose, LyingOnFront) == 0x0000C0, "Member 'FSBZHurtReactionPose::LyingOnFront' has a wrong offset!");
static_assert(offsetof(FSBZHurtReactionPose, LyingOnBack) == 0x000120, "Member 'FSBZHurtReactionPose::LyingOnBack' has a wrong offset!");

// ScriptStruct Starbreeze.SBZHurtReactionData
// 0x0018 (0x0018 - 0x0000)
struct FSBZHurtReactionData final
{
public:
	class UCurveVector*                           HurtReactionWeightCurve;                           // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HurtReactionWeightModifier;                        // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZDamageWeight                              DesiredHurtReactionWeight;                         // 0x000C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HurtReactionWeightBuildupModifier;                 // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalHurtReactionWeightBuildupModifier;         // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZHurtReactionData) == 0x000008, "Wrong alignment on FSBZHurtReactionData");
static_assert(sizeof(FSBZHurtReactionData) == 0x000018, "Wrong size on FSBZHurtReactionData");
static_assert(offsetof(FSBZHurtReactionData, HurtReactionWeightCurve) == 0x000000, "Member 'FSBZHurtReactionData::HurtReactionWeightCurve' has a wrong offset!");
static_assert(offsetof(FSBZHurtReactionData, HurtReactionWeightModifier) == 0x000008, "Member 'FSBZHurtReactionData::HurtReactionWeightModifier' has a wrong offset!");
static_assert(offsetof(FSBZHurtReactionData, DesiredHurtReactionWeight) == 0x00000C, "Member 'FSBZHurtReactionData::DesiredHurtReactionWeight' has a wrong offset!");
static_assert(offsetof(FSBZHurtReactionData, HurtReactionWeightBuildupModifier) == 0x000010, "Member 'FSBZHurtReactionData::HurtReactionWeightBuildupModifier' has a wrong offset!");
static_assert(offsetof(FSBZHurtReactionData, CriticalHurtReactionWeightBuildupModifier) == 0x000014, "Member 'FSBZHurtReactionData::CriticalHurtReactionWeightBuildupModifier' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMeleeImpactData
// 0x0060 (0x00A0 - 0x0040)
struct FSBZMeleeImpactData final : public FSBZStandardImpactData
{
public:
	TMap<ESBZMeleeAttackCategory, float>          CategoryDecalScale;                                // 0x0040(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bIsBloodSplatter;                                  // 0x0090(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsExtraBloodSpawned;                              // 0x0091(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x6];                                       // 0x0092(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class USBZBloodSplatterImpactConfig*          BloodSplatterImpactConfig;                         // 0x0098(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZMeleeImpactData) == 0x000008, "Wrong alignment on FSBZMeleeImpactData");
static_assert(sizeof(FSBZMeleeImpactData) == 0x0000A0, "Wrong size on FSBZMeleeImpactData");
static_assert(offsetof(FSBZMeleeImpactData, CategoryDecalScale) == 0x000040, "Member 'FSBZMeleeImpactData::CategoryDecalScale' has a wrong offset!");
static_assert(offsetof(FSBZMeleeImpactData, bIsBloodSplatter) == 0x000090, "Member 'FSBZMeleeImpactData::bIsBloodSplatter' has a wrong offset!");
static_assert(offsetof(FSBZMeleeImpactData, bIsExtraBloodSpawned) == 0x000091, "Member 'FSBZMeleeImpactData::bIsExtraBloodSpawned' has a wrong offset!");
static_assert(offsetof(FSBZMeleeImpactData, BloodSplatterImpactConfig) == 0x000098, "Member 'FSBZMeleeImpactData::BloodSplatterImpactConfig' has a wrong offset!");

// ScriptStruct Starbreeze.SBZProjectileTypeImpactData
// 0x0008 (0x0030 - 0x0028)
struct FSBZProjectileTypeImpactData final : public FSBZBaseImpactData
{
public:
	ESBZProjectileImpactType                      ImpactType;                                        // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DecalMultiplier;                                   // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZProjectileTypeImpactData) == 0x000008, "Wrong alignment on FSBZProjectileTypeImpactData");
static_assert(sizeof(FSBZProjectileTypeImpactData) == 0x000030, "Wrong size on FSBZProjectileTypeImpactData");
static_assert(offsetof(FSBZProjectileTypeImpactData, ImpactType) == 0x000028, "Member 'FSBZProjectileTypeImpactData::ImpactType' has a wrong offset!");
static_assert(offsetof(FSBZProjectileTypeImpactData, DecalMultiplier) == 0x00002C, "Member 'FSBZProjectileTypeImpactData::DecalMultiplier' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInfamyLevelData
// 0x0038 (0x0038 - 0x0000)
struct FSBZInfamyLevelData final
{
public:
	int32                                         AdditionalInfamyPoints;                            // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 GrantedSkillPointCountArray;                       // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         TotalInfamyPoints;                                 // 0x0018(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 TotalSkillPointCountArray;                         // 0x0020(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0030(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZInfamyLevelData) == 0x000008, "Wrong alignment on FSBZInfamyLevelData");
static_assert(sizeof(FSBZInfamyLevelData) == 0x000038, "Wrong size on FSBZInfamyLevelData");
static_assert(offsetof(FSBZInfamyLevelData, AdditionalInfamyPoints) == 0x000000, "Member 'FSBZInfamyLevelData::AdditionalInfamyPoints' has a wrong offset!");
static_assert(offsetof(FSBZInfamyLevelData, GrantedSkillPointCountArray) == 0x000008, "Member 'FSBZInfamyLevelData::GrantedSkillPointCountArray' has a wrong offset!");
static_assert(offsetof(FSBZInfamyLevelData, TotalInfamyPoints) == 0x000018, "Member 'FSBZInfamyLevelData::TotalInfamyPoints' has a wrong offset!");
static_assert(offsetof(FSBZInfamyLevelData, TotalSkillPointCountArray) == 0x000020, "Member 'FSBZInfamyLevelData::TotalSkillPointCountArray' has a wrong offset!");
static_assert(offsetof(FSBZInfamyLevelData, Level) == 0x000030, "Member 'FSBZInfamyLevelData::Level' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInteractableLocalizedAnimatedInteractionData
// 0x0020 (0x0020 - 0x0000)
struct FSBZInteractableLocalizedAnimatedInteractionData final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	class USBZAnimatedInteractionData*            AnimatedInteractionData;                           // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZInteractableLocalizedAnimatedInteractionData) == 0x000008, "Wrong alignment on FSBZInteractableLocalizedAnimatedInteractionData");
static_assert(sizeof(FSBZInteractableLocalizedAnimatedInteractionData) == 0x000020, "Wrong size on FSBZInteractableLocalizedAnimatedInteractionData");
static_assert(offsetof(FSBZInteractableLocalizedAnimatedInteractionData, Text) == 0x000000, "Member 'FSBZInteractableLocalizedAnimatedInteractionData::Text' has a wrong offset!");
static_assert(offsetof(FSBZInteractableLocalizedAnimatedInteractionData, AnimatedInteractionData) == 0x000018, "Member 'FSBZInteractableLocalizedAnimatedInteractionData::AnimatedInteractionData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZReplicatedInteractionData
// 0x0010 (0x0010 - 0x0000)
struct FSBZReplicatedInteractionData final
{
public:
	class USBZBaseInteractableComponent*          CurrentInteraction;                                // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          ModeIndex;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZReplicatedInteractionData) == 0x000008, "Wrong alignment on FSBZReplicatedInteractionData");
static_assert(sizeof(FSBZReplicatedInteractionData) == 0x000010, "Wrong size on FSBZReplicatedInteractionData");
static_assert(offsetof(FSBZReplicatedInteractionData, CurrentInteraction) == 0x000000, "Member 'FSBZReplicatedInteractionData::CurrentInteraction' has a wrong offset!");
static_assert(offsetof(FSBZReplicatedInteractionData, ModeIndex) == 0x000008, "Member 'FSBZReplicatedInteractionData::ModeIndex' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSuitConfigInventorySaveData
// 0x0020 (0x0020 - 0x0000)
struct FSBZSuitConfigInventorySaveData final
{
public:
	TArray<struct FSBZSuitInventorySlot>          SuitConfigSlots;                                   // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FSBZSuitInventorySlot>          CheckedSuitConfigSlots;                            // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSuitConfigInventorySaveData) == 0x000008, "Wrong alignment on FSBZSuitConfigInventorySaveData");
static_assert(sizeof(FSBZSuitConfigInventorySaveData) == 0x000020, "Wrong size on FSBZSuitConfigInventorySaveData");
static_assert(offsetof(FSBZSuitConfigInventorySaveData, SuitConfigSlots) == 0x000000, "Member 'FSBZSuitConfigInventorySaveData::SuitConfigSlots' has a wrong offset!");
static_assert(offsetof(FSBZSuitConfigInventorySaveData, CheckedSuitConfigSlots) == 0x000010, "Member 'FSBZSuitConfigInventorySaveData::CheckedSuitConfigSlots' has a wrong offset!");

// ScriptStruct Starbreeze.SBZArmorConfigInventorySaveData
// 0x0020 (0x0020 - 0x0000)
struct FSBZArmorConfigInventorySaveData final
{
public:
	TArray<struct FSBZArmorInventorySlot>         ArmorConfigSlots;                                  // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FSBZArmorInventorySlot>         CheckedArmorConfigSlots;                           // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZArmorConfigInventorySaveData) == 0x000008, "Wrong alignment on FSBZArmorConfigInventorySaveData");
static_assert(sizeof(FSBZArmorConfigInventorySaveData) == 0x000020, "Wrong size on FSBZArmorConfigInventorySaveData");
static_assert(offsetof(FSBZArmorConfigInventorySaveData, ArmorConfigSlots) == 0x000000, "Member 'FSBZArmorConfigInventorySaveData::ArmorConfigSlots' has a wrong offset!");
static_assert(offsetof(FSBZArmorConfigInventorySaveData, CheckedArmorConfigSlots) == 0x000010, "Member 'FSBZArmorConfigInventorySaveData::CheckedArmorConfigSlots' has a wrong offset!");

// ScriptStruct Starbreeze.SBZItemConfigInventorySaveData
// 0x0040 (0x0040 - 0x0000)
struct FSBZItemConfigInventorySaveData final
{
public:
	TArray<struct FSBZWeaponInventorySlot>        PrimaryWeaponConfigSlots;                          // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FSBZWeaponInventorySlot>        SecondaryWeaponConfigSlots;                        // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FSBZWeaponInventorySlot>        CheckedPrimaryWeaponConfigSlots;                   // 0x0020(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FSBZWeaponInventorySlot>        CheckedSecondaryWeaponConfigSlots;                 // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZItemConfigInventorySaveData) == 0x000008, "Wrong alignment on FSBZItemConfigInventorySaveData");
static_assert(sizeof(FSBZItemConfigInventorySaveData) == 0x000040, "Wrong size on FSBZItemConfigInventorySaveData");
static_assert(offsetof(FSBZItemConfigInventorySaveData, PrimaryWeaponConfigSlots) == 0x000000, "Member 'FSBZItemConfigInventorySaveData::PrimaryWeaponConfigSlots' has a wrong offset!");
static_assert(offsetof(FSBZItemConfigInventorySaveData, SecondaryWeaponConfigSlots) == 0x000010, "Member 'FSBZItemConfigInventorySaveData::SecondaryWeaponConfigSlots' has a wrong offset!");
static_assert(offsetof(FSBZItemConfigInventorySaveData, CheckedPrimaryWeaponConfigSlots) == 0x000020, "Member 'FSBZItemConfigInventorySaveData::CheckedPrimaryWeaponConfigSlots' has a wrong offset!");
static_assert(offsetof(FSBZItemConfigInventorySaveData, CheckedSecondaryWeaponConfigSlots) == 0x000030, "Member 'FSBZItemConfigInventorySaveData::CheckedSecondaryWeaponConfigSlots' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPlayerItemInfo
// 0x0018 (0x0018 - 0x0000)
struct FSBZPlayerItemInfo final
{
public:
	struct FSBZChallengeObjectiveInfo             ChallengeObjectiveInfo;                            // 0x0000(0x0010)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	class USBZInventoryBaseData*                  InventoryBaseData;                                 // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPlayerItemInfo) == 0x000008, "Wrong alignment on FSBZPlayerItemInfo");
static_assert(sizeof(FSBZPlayerItemInfo) == 0x000018, "Wrong size on FSBZPlayerItemInfo");
static_assert(offsetof(FSBZPlayerItemInfo, ChallengeObjectiveInfo) == 0x000000, "Member 'FSBZPlayerItemInfo::ChallengeObjectiveInfo' has a wrong offset!");
static_assert(offsetof(FSBZPlayerItemInfo, InventoryBaseData) == 0x000010, "Member 'FSBZPlayerItemInfo::InventoryBaseData' has a wrong offset!");

// ScriptStruct Starbreeze.PlayerWaitingForReady
// 0x0030 (0x0030 - 0x0000)
struct FPlayerWaitingForReady final
{
public:
	struct FTimerHandle                           AutoReadyTimer;                                    // 0x0000(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUniqueNetIdRepl                       PlayerId;                                          // 0x0008(0x0028)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerWaitingForReady) == 0x000008, "Wrong alignment on FPlayerWaitingForReady");
static_assert(sizeof(FPlayerWaitingForReady) == 0x000030, "Wrong size on FPlayerWaitingForReady");
static_assert(offsetof(FPlayerWaitingForReady, AutoReadyTimer) == 0x000000, "Member 'FPlayerWaitingForReady::AutoReadyTimer' has a wrong offset!");
static_assert(offsetof(FPlayerWaitingForReady, PlayerId) == 0x000008, "Member 'FPlayerWaitingForReady::PlayerId' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCodeViewerSet
// 0x0028 (0x0028 - 0x0000)
struct FSBZCodeViewerSet final
{
public:
	TArray<class AActor*>                         PossibleCodeViewers;                               // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   Identifier;                                        // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZCodeViewerSet) == 0x000008, "Wrong alignment on FSBZCodeViewerSet");
static_assert(sizeof(FSBZCodeViewerSet) == 0x000028, "Wrong size on FSBZCodeViewerSet");
static_assert(offsetof(FSBZCodeViewerSet, PossibleCodeViewers) == 0x000000, "Member 'FSBZCodeViewerSet::PossibleCodeViewers' has a wrong offset!");
static_assert(offsetof(FSBZCodeViewerSet, Identifier) == 0x000010, "Member 'FSBZCodeViewerSet::Identifier' has a wrong offset!");

// ScriptStruct Starbreeze.SBZKnifeProjectileTargetData
// 0x0010 (0x5BB0 - 0x5BA0)
struct FSBZKnifeProjectileTargetData final : public FSBZProjectileTargetData
{
public:
	uint8                                         Pad_5BA0[0x10];                                    // 0x5BA0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZKnifeProjectileTargetData) == 0x000008, "Wrong alignment on FSBZKnifeProjectileTargetData");
static_assert(sizeof(FSBZKnifeProjectileTargetData) == 0x005BB0, "Wrong size on FSBZKnifeProjectileTargetData");

// ScriptStruct Starbreeze.SBZLaserPattern
// 0x0010 (0x0010 - 0x0000)
struct FSBZLaserPattern final
{
public:
	TArray<int32>                                 LaserIndexes;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZLaserPattern) == 0x000008, "Wrong alignment on FSBZLaserPattern");
static_assert(sizeof(FSBZLaserPattern) == 0x000010, "Wrong size on FSBZLaserPattern");
static_assert(offsetof(FSBZLaserPattern, LaserIndexes) == 0x000000, "Member 'FSBZLaserPattern::LaserIndexes' has a wrong offset!");

// ScriptStruct Starbreeze.SBZFetchStatItemsValueQuery
// 0x0040 (0x0040 - 0x0000)
struct FSBZFetchStatItemsValueQuery final
{
public:
	TScriptInterface<class ISBZLazyObject>        Object;                                            // 0x0000(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x30];                                      // 0x0010(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZFetchStatItemsValueQuery) == 0x000008, "Wrong alignment on FSBZFetchStatItemsValueQuery");
static_assert(sizeof(FSBZFetchStatItemsValueQuery) == 0x000040, "Wrong size on FSBZFetchStatItemsValueQuery");
static_assert(offsetof(FSBZFetchStatItemsValueQuery, Object) == 0x000000, "Member 'FSBZFetchStatItemsValueQuery::Object' has a wrong offset!");

// ScriptStruct Starbreeze.SBZFetchStatItemsValueQueryArray
// 0x0010 (0x0010 - 0x0000)
struct FSBZFetchStatItemsValueQueryArray final
{
public:
	TArray<struct FSBZFetchStatItemsValueQuery>   Data;                                              // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZFetchStatItemsValueQueryArray) == 0x000008, "Wrong alignment on FSBZFetchStatItemsValueQueryArray");
static_assert(sizeof(FSBZFetchStatItemsValueQueryArray) == 0x000010, "Wrong size on FSBZFetchStatItemsValueQueryArray");
static_assert(offsetof(FSBZFetchStatItemsValueQueryArray, Data) == 0x000000, "Member 'FSBZFetchStatItemsValueQueryArray::Data' has a wrong offset!");

// ScriptStruct Starbreeze.SBZRemoteEventWithActorsArrayParams
// 0x0010 (0x0010 - 0x0000)
struct FSBZRemoteEventWithActorsArrayParams final
{
public:
	TArray<class AActor*>                         Actor;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZRemoteEventWithActorsArrayParams) == 0x000008, "Wrong alignment on FSBZRemoteEventWithActorsArrayParams");
static_assert(sizeof(FSBZRemoteEventWithActorsArrayParams) == 0x000010, "Wrong size on FSBZRemoteEventWithActorsArrayParams");
static_assert(offsetof(FSBZRemoteEventWithActorsArrayParams, Actor) == 0x000000, "Member 'FSBZRemoteEventWithActorsArrayParams::Actor' has a wrong offset!");

// ScriptStruct Starbreeze.SBZLifeActionAffinity
// 0x0038 (0x0038 - 0x0000)
struct FSBZLifeActionAffinity final
{
public:
	class FName                                   AffinityName;                                      // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  Actions;                                           // 0x0010(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FFloatInterval                         CharacterScale;                                    // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZLifeActionAffinity) == 0x000008, "Wrong alignment on FSBZLifeActionAffinity");
static_assert(sizeof(FSBZLifeActionAffinity) == 0x000038, "Wrong size on FSBZLifeActionAffinity");
static_assert(offsetof(FSBZLifeActionAffinity, AffinityName) == 0x000000, "Member 'FSBZLifeActionAffinity::AffinityName' has a wrong offset!");
static_assert(offsetof(FSBZLifeActionAffinity, Actions) == 0x000010, "Member 'FSBZLifeActionAffinity::Actions' has a wrong offset!");
static_assert(offsetof(FSBZLifeActionAffinity, CharacterScale) == 0x000030, "Member 'FSBZLifeActionAffinity::CharacterScale' has a wrong offset!");

// ScriptStruct Starbreeze.SBZLifeActionAffinityList
// 0x0010 (0x0010 - 0x0000)
struct FSBZLifeActionAffinityList final
{
public:
	TArray<struct FSBZLifeActionAffinity>         Affinities;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZLifeActionAffinityList) == 0x000008, "Wrong alignment on FSBZLifeActionAffinityList");
static_assert(sizeof(FSBZLifeActionAffinityList) == 0x000010, "Wrong size on FSBZLifeActionAffinityList");
static_assert(offsetof(FSBZLifeActionAffinityList, Affinities) == 0x000000, "Member 'FSBZLifeActionAffinityList::Affinities' has a wrong offset!");

// ScriptStruct Starbreeze.SBZLifeActionRequest
// 0x0040 (0x0040 - 0x0000)
struct FSBZLifeActionRequest final
{
public:
	class AActor*                                 SpecificActionComponentOwner;                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZLifeActionComponent*                SpecificActionComponent;                           // 0x0008(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZLifeActionInstance*                 SpecificActionInstance;                            // 0x0010(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZLifeActionSlot*                     SpecificActionSlot;                                // 0x0018(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActionTag;                                         // 0x0020(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SlotTag;                                           // 0x002C(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZLifeActionAffinitytData*            SpecificAffinityData;                              // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZLifeActionRequest) == 0x000008, "Wrong alignment on FSBZLifeActionRequest");
static_assert(sizeof(FSBZLifeActionRequest) == 0x000040, "Wrong size on FSBZLifeActionRequest");
static_assert(offsetof(FSBZLifeActionRequest, SpecificActionComponentOwner) == 0x000000, "Member 'FSBZLifeActionRequest::SpecificActionComponentOwner' has a wrong offset!");
static_assert(offsetof(FSBZLifeActionRequest, SpecificActionComponent) == 0x000008, "Member 'FSBZLifeActionRequest::SpecificActionComponent' has a wrong offset!");
static_assert(offsetof(FSBZLifeActionRequest, SpecificActionInstance) == 0x000010, "Member 'FSBZLifeActionRequest::SpecificActionInstance' has a wrong offset!");
static_assert(offsetof(FSBZLifeActionRequest, SpecificActionSlot) == 0x000018, "Member 'FSBZLifeActionRequest::SpecificActionSlot' has a wrong offset!");
static_assert(offsetof(FSBZLifeActionRequest, ActionTag) == 0x000020, "Member 'FSBZLifeActionRequest::ActionTag' has a wrong offset!");
static_assert(offsetof(FSBZLifeActionRequest, SlotTag) == 0x00002C, "Member 'FSBZLifeActionRequest::SlotTag' has a wrong offset!");
static_assert(offsetof(FSBZLifeActionRequest, SpecificAffinityData) == 0x000038, "Member 'FSBZLifeActionRequest::SpecificAffinityData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZLifeActionActorTagEvent
// 0x0020 (0x0020 - 0x0000)
struct FSBZLifeActionActorTagEvent final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Actor;                                             // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHandleEventStart;                                 // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHandleEventEnd;                                   // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZLifeActionActorTagEvent) == 0x000008, "Wrong alignment on FSBZLifeActionActorTagEvent");
static_assert(sizeof(FSBZLifeActionActorTagEvent) == 0x000020, "Wrong size on FSBZLifeActionActorTagEvent");
static_assert(offsetof(FSBZLifeActionActorTagEvent, EventTag) == 0x000000, "Member 'FSBZLifeActionActorTagEvent::EventTag' has a wrong offset!");
static_assert(offsetof(FSBZLifeActionActorTagEvent, Actor) == 0x000010, "Member 'FSBZLifeActionActorTagEvent::Actor' has a wrong offset!");
static_assert(offsetof(FSBZLifeActionActorTagEvent, bHandleEventStart) == 0x000018, "Member 'FSBZLifeActionActorTagEvent::bHandleEventStart' has a wrong offset!");
static_assert(offsetof(FSBZLifeActionActorTagEvent, bHandleEventEnd) == 0x000019, "Member 'FSBZLifeActionActorTagEvent::bHandleEventEnd' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInfoPopupText
// 0x0070 (0x0070 - 0x0000)
struct FSBZInfoPopupText final
{
public:
	class FText                                   HeaderText;                                        // 0x0000(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   BodyText;                                          // 0x0018(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bHasPlaystationSpecificBodyText;                   // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   BodyTextPlaystation;                               // 0x0038(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bHasXboxSpecificBodyText;                          // 0x0050(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   BodyTextXbox;                                      // 0x0058(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZInfoPopupText) == 0x000008, "Wrong alignment on FSBZInfoPopupText");
static_assert(sizeof(FSBZInfoPopupText) == 0x000070, "Wrong size on FSBZInfoPopupText");
static_assert(offsetof(FSBZInfoPopupText, HeaderText) == 0x000000, "Member 'FSBZInfoPopupText::HeaderText' has a wrong offset!");
static_assert(offsetof(FSBZInfoPopupText, BodyText) == 0x000018, "Member 'FSBZInfoPopupText::BodyText' has a wrong offset!");
static_assert(offsetof(FSBZInfoPopupText, bHasPlaystationSpecificBodyText) == 0x000030, "Member 'FSBZInfoPopupText::bHasPlaystationSpecificBodyText' has a wrong offset!");
static_assert(offsetof(FSBZInfoPopupText, BodyTextPlaystation) == 0x000038, "Member 'FSBZInfoPopupText::BodyTextPlaystation' has a wrong offset!");
static_assert(offsetof(FSBZInfoPopupText, bHasXboxSpecificBodyText) == 0x000050, "Member 'FSBZInfoPopupText::bHasXboxSpecificBodyText' has a wrong offset!");
static_assert(offsetof(FSBZInfoPopupText, BodyTextXbox) == 0x000058, "Member 'FSBZInfoPopupText::BodyTextXbox' has a wrong offset!");

// ScriptStruct Starbreeze.SBZStatData
// 0x0004 (0x0004 - 0x0000)
struct FSBZStatData final
{
public:
	float                                         Progress;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZStatData) == 0x000004, "Wrong alignment on FSBZStatData");
static_assert(sizeof(FSBZStatData) == 0x000004, "Wrong size on FSBZStatData");
static_assert(offsetof(FSBZStatData, Progress) == 0x000000, "Member 'FSBZStatData::Progress' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCosmeticPanelDefaultParams
// 0x0020 (0x0020 - 0x0000)
struct FSBZCosmeticPanelDefaultParams final
{
public:
	bool                                          HasDefault;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZCosmeticPanelDefaultParams) == 0x000008, "Wrong alignment on FSBZCosmeticPanelDefaultParams");
static_assert(sizeof(FSBZCosmeticPanelDefaultParams) == 0x000020, "Wrong size on FSBZCosmeticPanelDefaultParams");
static_assert(offsetof(FSBZCosmeticPanelDefaultParams, HasDefault) == 0x000000, "Member 'FSBZCosmeticPanelDefaultParams::HasDefault' has a wrong offset!");
static_assert(offsetof(FSBZCosmeticPanelDefaultParams, DisplayName) == 0x000008, "Member 'FSBZCosmeticPanelDefaultParams::DisplayName' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCosmeticsInventoryItem
// 0x0008 (0x0020 - 0x0018)
struct FSBZCosmeticsInventoryItem final : public FSBZInventoryItem
{
public:
	class USBZCosmeticsDataAsset*                 CosmeticsDataAsset;                                // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZCosmeticsInventoryItem) == 0x000008, "Wrong alignment on FSBZCosmeticsInventoryItem");
static_assert(sizeof(FSBZCosmeticsInventoryItem) == 0x000020, "Wrong size on FSBZCosmeticsInventoryItem");
static_assert(offsetof(FSBZCosmeticsInventoryItem, CosmeticsDataAsset) == 0x000018, "Member 'FSBZCosmeticsInventoryItem::CosmeticsDataAsset' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCosmeticPanelInitParams
// 0x0030 (0x0030 - 0x0000)
struct FSBZCosmeticPanelInitParams final
{
public:
	struct FSBZCosmeticPanelDefaultParams         DefaultItem;                                       // 0x0000(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FSBZCosmeticsInventoryItem>     CosmeticInventoryItems;                            // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZCosmeticPanelInitParams) == 0x000008, "Wrong alignment on FSBZCosmeticPanelInitParams");
static_assert(sizeof(FSBZCosmeticPanelInitParams) == 0x000030, "Wrong size on FSBZCosmeticPanelInitParams");
static_assert(offsetof(FSBZCosmeticPanelInitParams, DefaultItem) == 0x000000, "Member 'FSBZCosmeticPanelInitParams::DefaultItem' has a wrong offset!");
static_assert(offsetof(FSBZCosmeticPanelInitParams, CosmeticInventoryItems) == 0x000020, "Member 'FSBZCosmeticPanelInitParams::CosmeticInventoryItems' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCreditsText
// 0x0028 (0x0028 - 0x0000)
struct FSBZCreditsText final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FString                                 String;                                            // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZCreditsText) == 0x000008, "Wrong alignment on FSBZCreditsText");
static_assert(sizeof(FSBZCreditsText) == 0x000028, "Wrong size on FSBZCreditsText");
static_assert(offsetof(FSBZCreditsText, Text) == 0x000000, "Member 'FSBZCreditsText::Text' has a wrong offset!");
static_assert(offsetof(FSBZCreditsText, String) == 0x000018, "Member 'FSBZCreditsText::String' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCashRewardModifier
// 0x0008 (0x0008 - 0x0000)
struct FSBZCashRewardModifier final
{
public:
	int32                                         BaseReward;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxReward;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZCashRewardModifier) == 0x000004, "Wrong alignment on FSBZCashRewardModifier");
static_assert(sizeof(FSBZCashRewardModifier) == 0x000008, "Wrong size on FSBZCashRewardModifier");
static_assert(offsetof(FSBZCashRewardModifier, BaseReward) == 0x000000, "Member 'FSBZCashRewardModifier::BaseReward' has a wrong offset!");
static_assert(offsetof(FSBZCashRewardModifier, MaxReward) == 0x000004, "Member 'FSBZCashRewardModifier::MaxReward' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInfamyPointPayout
// 0x000C (0x000C - 0x0000)
struct FSBZInfamyPointPayout final
{
public:
	int32                                         Completion;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StealthBonus;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AllBagsBonus;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZInfamyPointPayout) == 0x000004, "Wrong alignment on FSBZInfamyPointPayout");
static_assert(sizeof(FSBZInfamyPointPayout) == 0x00000C, "Wrong size on FSBZInfamyPointPayout");
static_assert(offsetof(FSBZInfamyPointPayout, Completion) == 0x000000, "Member 'FSBZInfamyPointPayout::Completion' has a wrong offset!");
static_assert(offsetof(FSBZInfamyPointPayout, StealthBonus) == 0x000004, "Member 'FSBZInfamyPointPayout::StealthBonus' has a wrong offset!");
static_assert(offsetof(FSBZInfamyPointPayout, AllBagsBonus) == 0x000008, "Member 'FSBZInfamyPointPayout::AllBagsBonus' has a wrong offset!");

// ScriptStruct Starbreeze.SBZTickingLootValues
// 0x0040 (0x0040 - 0x0000)
struct FSBZTickingLootValues final
{
public:
	TArray<int32>                                 StealthMaxPayoutArray;                             // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 LoudMaxPayoutArray;                                // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 StealthMaxInfamyArray;                             // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 LoudMaxInfamyArray;                                // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZTickingLootValues) == 0x000008, "Wrong alignment on FSBZTickingLootValues");
static_assert(sizeof(FSBZTickingLootValues) == 0x000040, "Wrong size on FSBZTickingLootValues");
static_assert(offsetof(FSBZTickingLootValues, StealthMaxPayoutArray) == 0x000000, "Member 'FSBZTickingLootValues::StealthMaxPayoutArray' has a wrong offset!");
static_assert(offsetof(FSBZTickingLootValues, LoudMaxPayoutArray) == 0x000010, "Member 'FSBZTickingLootValues::LoudMaxPayoutArray' has a wrong offset!");
static_assert(offsetof(FSBZTickingLootValues, StealthMaxInfamyArray) == 0x000020, "Member 'FSBZTickingLootValues::StealthMaxInfamyArray' has a wrong offset!");
static_assert(offsetof(FSBZTickingLootValues, LoudMaxInfamyArray) == 0x000030, "Member 'FSBZTickingLootValues::LoudMaxInfamyArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPerformanceBonusArray
// 0x0010 (0x0010 - 0x0000)
struct FSBZPerformanceBonusArray final
{
public:
	TArray<struct FSBZPerformanceBonusEntry>      PerformanceBonusEntryArray;                        // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPerformanceBonusArray) == 0x000008, "Wrong alignment on FSBZPerformanceBonusArray");
static_assert(sizeof(FSBZPerformanceBonusArray) == 0x000010, "Wrong size on FSBZPerformanceBonusArray");
static_assert(offsetof(FSBZPerformanceBonusArray, PerformanceBonusEntryArray) == 0x000000, "Member 'FSBZPerformanceBonusArray::PerformanceBonusEntryArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPlayerStatisticArray
// 0x0010 (0x0010 - 0x0000)
struct FSBZPlayerStatisticArray final
{
public:
	TArray<class FString>                         PlayerStatisticEntryArray;                         // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPlayerStatisticArray) == 0x000008, "Wrong alignment on FSBZPlayerStatisticArray");
static_assert(sizeof(FSBZPlayerStatisticArray) == 0x000010, "Wrong size on FSBZPlayerStatisticArray");
static_assert(offsetof(FSBZPlayerStatisticArray, PlayerStatisticEntryArray) == 0x000000, "Member 'FSBZPlayerStatisticArray::PlayerStatisticEntryArray' has a wrong offset!");

// ScriptStruct Starbreeze.MapConfigurationData
// 0x0428 (0x0428 - 0x0000)
struct FMapConfigurationData final
{
public:
	int32                                         LoudBaseExperience;                                // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StealthBaseExperience;                             // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoudBaseInfamyPointsOnFail;                        // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StealthBaseInfamyPointsOnFail;                     // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 LoudInfamyPointsOnSurvivingOneAssultDifficultyArray; // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 LoudInfamyPointsOnSurvivingFinalAssultDifficultyArray; // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<float>                                 DifficultyExperienceModifierArray;                 // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<float>                                 DifficultyInfamyPointsOnFailModifierArray;         // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSBZCashRewardModifier>         StealthDifficultyCashRewardModifierArray;          // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSBZCashRewardModifier>         LoudDifficultyCashRewardModifierArray;             // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSBZLootValueArray>             LoudLootValuesArray;                               // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSBZLootValueArray>             StealthLootValuesArray;                            // 0x0080(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSBZInstantLootValues                  InstantLootValues;                                 // 0x0090(0x0078)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSBZTickingLootValues                  TickingLootValues;                                 // 0x0108(0x0040)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FString, float>                    ObjectivesToExperienceRewardMap;                   // 0x0148(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FString, float>                    LoudMilestoneToExperienceRewardMap;                // 0x0198(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FString, float>                    StealthMilestoneToExperienceRewardMap;             // 0x01E8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FString, float>                    LoudMilestoneToInfamyPointsOnFailRewardMap;        // 0x0238(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FString, float>                    StealthMilestoneToInfamyPointsOnFailRewardMap;     // 0x0288(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZPerformanceBonusArray> PerformanceBonusMap;                       // 0x02D8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FString, float>                    ItemIdRewardMap;                                   // 0x0328(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZPlayerStatisticArray> LoudLevelCompletedStatistics;               // 0x0378(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZPlayerStatisticArray> StealthLevelCompletedStatistics;            // 0x03C8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSBZInfamyPointPayout>          InfamyPointPayoutArray;                            // 0x0418(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapConfigurationData) == 0x000008, "Wrong alignment on FMapConfigurationData");
static_assert(sizeof(FMapConfigurationData) == 0x000428, "Wrong size on FMapConfigurationData");
static_assert(offsetof(FMapConfigurationData, LoudBaseExperience) == 0x000000, "Member 'FMapConfigurationData::LoudBaseExperience' has a wrong offset!");
static_assert(offsetof(FMapConfigurationData, StealthBaseExperience) == 0x000004, "Member 'FMapConfigurationData::StealthBaseExperience' has a wrong offset!");
static_assert(offsetof(FMapConfigurationData, LoudBaseInfamyPointsOnFail) == 0x000008, "Member 'FMapConfigurationData::LoudBaseInfamyPointsOnFail' has a wrong offset!");
static_assert(offsetof(FMapConfigurationData, StealthBaseInfamyPointsOnFail) == 0x00000C, "Member 'FMapConfigurationData::StealthBaseInfamyPointsOnFail' has a wrong offset!");
static_assert(offsetof(FMapConfigurationData, LoudInfamyPointsOnSurvivingOneAssultDifficultyArray) == 0x000010, "Member 'FMapConfigurationData::LoudInfamyPointsOnSurvivingOneAssultDifficultyArray' has a wrong offset!");
static_assert(offsetof(FMapConfigurationData, LoudInfamyPointsOnSurvivingFinalAssultDifficultyArray) == 0x000020, "Member 'FMapConfigurationData::LoudInfamyPointsOnSurvivingFinalAssultDifficultyArray' has a wrong offset!");
static_assert(offsetof(FMapConfigurationData, DifficultyExperienceModifierArray) == 0x000030, "Member 'FMapConfigurationData::DifficultyExperienceModifierArray' has a wrong offset!");
static_assert(offsetof(FMapConfigurationData, DifficultyInfamyPointsOnFailModifierArray) == 0x000040, "Member 'FMapConfigurationData::DifficultyInfamyPointsOnFailModifierArray' has a wrong offset!");
static_assert(offsetof(FMapConfigurationData, StealthDifficultyCashRewardModifierArray) == 0x000050, "Member 'FMapConfigurationData::StealthDifficultyCashRewardModifierArray' has a wrong offset!");
static_assert(offsetof(FMapConfigurationData, LoudDifficultyCashRewardModifierArray) == 0x000060, "Member 'FMapConfigurationData::LoudDifficultyCashRewardModifierArray' has a wrong offset!");
static_assert(offsetof(FMapConfigurationData, LoudLootValuesArray) == 0x000070, "Member 'FMapConfigurationData::LoudLootValuesArray' has a wrong offset!");
static_assert(offsetof(FMapConfigurationData, StealthLootValuesArray) == 0x000080, "Member 'FMapConfigurationData::StealthLootValuesArray' has a wrong offset!");
static_assert(offsetof(FMapConfigurationData, InstantLootValues) == 0x000090, "Member 'FMapConfigurationData::InstantLootValues' has a wrong offset!");
static_assert(offsetof(FMapConfigurationData, TickingLootValues) == 0x000108, "Member 'FMapConfigurationData::TickingLootValues' has a wrong offset!");
static_assert(offsetof(FMapConfigurationData, ObjectivesToExperienceRewardMap) == 0x000148, "Member 'FMapConfigurationData::ObjectivesToExperienceRewardMap' has a wrong offset!");
static_assert(offsetof(FMapConfigurationData, LoudMilestoneToExperienceRewardMap) == 0x000198, "Member 'FMapConfigurationData::LoudMilestoneToExperienceRewardMap' has a wrong offset!");
static_assert(offsetof(FMapConfigurationData, StealthMilestoneToExperienceRewardMap) == 0x0001E8, "Member 'FMapConfigurationData::StealthMilestoneToExperienceRewardMap' has a wrong offset!");
static_assert(offsetof(FMapConfigurationData, LoudMilestoneToInfamyPointsOnFailRewardMap) == 0x000238, "Member 'FMapConfigurationData::LoudMilestoneToInfamyPointsOnFailRewardMap' has a wrong offset!");
static_assert(offsetof(FMapConfigurationData, StealthMilestoneToInfamyPointsOnFailRewardMap) == 0x000288, "Member 'FMapConfigurationData::StealthMilestoneToInfamyPointsOnFailRewardMap' has a wrong offset!");
static_assert(offsetof(FMapConfigurationData, PerformanceBonusMap) == 0x0002D8, "Member 'FMapConfigurationData::PerformanceBonusMap' has a wrong offset!");
static_assert(offsetof(FMapConfigurationData, ItemIdRewardMap) == 0x000328, "Member 'FMapConfigurationData::ItemIdRewardMap' has a wrong offset!");
static_assert(offsetof(FMapConfigurationData, LoudLevelCompletedStatistics) == 0x000378, "Member 'FMapConfigurationData::LoudLevelCompletedStatistics' has a wrong offset!");
static_assert(offsetof(FMapConfigurationData, StealthLevelCompletedStatistics) == 0x0003C8, "Member 'FMapConfigurationData::StealthLevelCompletedStatistics' has a wrong offset!");
static_assert(offsetof(FMapConfigurationData, InfamyPointPayoutArray) == 0x000418, "Member 'FMapConfigurationData::InfamyPointPayoutArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZQueuedJoinLobby
// 0x0010 (0x0010 - 0x0000)
struct FSBZQueuedJoinLobby final
{
public:
	class USBZStateMachineDataMatchmaking*        MatchmakingData;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasQueuedJoinLobby;                               // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZQueuedJoinLobby) == 0x000008, "Wrong alignment on FSBZQueuedJoinLobby");
static_assert(sizeof(FSBZQueuedJoinLobby) == 0x000010, "Wrong size on FSBZQueuedJoinLobby");
static_assert(offsetof(FSBZQueuedJoinLobby, MatchmakingData) == 0x000000, "Member 'FSBZQueuedJoinLobby::MatchmakingData' has a wrong offset!");
static_assert(offsetof(FSBZQueuedJoinLobby, bHasQueuedJoinLobby) == 0x000008, "Member 'FSBZQueuedJoinLobby::bHasQueuedJoinLobby' has a wrong offset!");

// ScriptStruct Starbreeze.SBZNavButtonParameters
// 0x0070 (0x0070 - 0x0000)
struct FSBZNavButtonParameters final
{
public:
	class FName                                   StackValue;                                        // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayValue;                                      // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bHasPlaystationSpecificDisplayValue;               // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayValuePlaystation;                           // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          bHasXBoxSpecificDisplayValue;                      // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayValueXBox;                                  // 0x0050(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          bShowOnlyOnWindowsPlatform;                        // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZNavButtonParameters) == 0x000008, "Wrong alignment on FSBZNavButtonParameters");
static_assert(sizeof(FSBZNavButtonParameters) == 0x000070, "Wrong size on FSBZNavButtonParameters");
static_assert(offsetof(FSBZNavButtonParameters, StackValue) == 0x000000, "Member 'FSBZNavButtonParameters::StackValue' has a wrong offset!");
static_assert(offsetof(FSBZNavButtonParameters, DisplayValue) == 0x000010, "Member 'FSBZNavButtonParameters::DisplayValue' has a wrong offset!");
static_assert(offsetof(FSBZNavButtonParameters, bHasPlaystationSpecificDisplayValue) == 0x000028, "Member 'FSBZNavButtonParameters::bHasPlaystationSpecificDisplayValue' has a wrong offset!");
static_assert(offsetof(FSBZNavButtonParameters, DisplayValuePlaystation) == 0x000030, "Member 'FSBZNavButtonParameters::DisplayValuePlaystation' has a wrong offset!");
static_assert(offsetof(FSBZNavButtonParameters, bHasXBoxSpecificDisplayValue) == 0x000048, "Member 'FSBZNavButtonParameters::bHasXBoxSpecificDisplayValue' has a wrong offset!");
static_assert(offsetof(FSBZNavButtonParameters, DisplayValueXBox) == 0x000050, "Member 'FSBZNavButtonParameters::DisplayValueXBox' has a wrong offset!");
static_assert(offsetof(FSBZNavButtonParameters, bShowOnlyOnWindowsPlatform) == 0x000068, "Member 'FSBZNavButtonParameters::bShowOnlyOnWindowsPlatform' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMergePartyPlayerInfo
// 0x0018 (0x0018 - 0x0000)
struct FSBZMergePartyPlayerInfo final
{
public:
	bool                                          bIsMergePartySelected;                             // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumberOfMembersInPartyManagersParty;               // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASBZPlayerController*                   MergePartyMemberPlayerController;                  // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSelectedAsMergePartyLeader;                     // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZMergePartyPlayerInfo) == 0x000008, "Wrong alignment on FSBZMergePartyPlayerInfo");
static_assert(sizeof(FSBZMergePartyPlayerInfo) == 0x000018, "Wrong size on FSBZMergePartyPlayerInfo");
static_assert(offsetof(FSBZMergePartyPlayerInfo, bIsMergePartySelected) == 0x000000, "Member 'FSBZMergePartyPlayerInfo::bIsMergePartySelected' has a wrong offset!");
static_assert(offsetof(FSBZMergePartyPlayerInfo, NumberOfMembersInPartyManagersParty) == 0x000004, "Member 'FSBZMergePartyPlayerInfo::NumberOfMembersInPartyManagersParty' has a wrong offset!");
static_assert(offsetof(FSBZMergePartyPlayerInfo, MergePartyMemberPlayerController) == 0x000008, "Member 'FSBZMergePartyPlayerInfo::MergePartyMemberPlayerController' has a wrong offset!");
static_assert(offsetof(FSBZMergePartyPlayerInfo, bIsSelectedAsMergePartyLeader) == 0x000010, "Member 'FSBZMergePartyPlayerInfo::bIsSelectedAsMergePartyLeader' has a wrong offset!");

// ScriptStruct Starbreeze.SkelMeshMergeSectionMapping_BP
// 0x0010 (0x0010 - 0x0000)
struct FSkelMeshMergeSectionMapping_BP final
{
public:
	TArray<int32>                                 SectionIDs;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkelMeshMergeSectionMapping_BP) == 0x000008, "Wrong alignment on FSkelMeshMergeSectionMapping_BP");
static_assert(sizeof(FSkelMeshMergeSectionMapping_BP) == 0x000010, "Wrong size on FSkelMeshMergeSectionMapping_BP");
static_assert(offsetof(FSkelMeshMergeSectionMapping_BP, SectionIDs) == 0x000000, "Member 'FSkelMeshMergeSectionMapping_BP::SectionIDs' has a wrong offset!");

// ScriptStruct Starbreeze.SrcMesh_BP
// 0x0010 (0x0010 - 0x0000)
struct FSrcMesh_BP final
{
public:
	class USkeletalMesh*                          SrcSkeletalMesh;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkinnedMeshComponent*                  SrcSkinnedSkeletalMesh;                            // 0x0008(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSrcMesh_BP) == 0x000008, "Wrong alignment on FSrcMesh_BP");
static_assert(sizeof(FSrcMesh_BP) == 0x000010, "Wrong size on FSrcMesh_BP");
static_assert(offsetof(FSrcMesh_BP, SrcSkeletalMesh) == 0x000000, "Member 'FSrcMesh_BP::SrcSkeletalMesh' has a wrong offset!");
static_assert(offsetof(FSrcMesh_BP, SrcSkinnedSkeletalMesh) == 0x000008, "Member 'FSrcMesh_BP::SrcSkinnedSkeletalMesh' has a wrong offset!");

// ScriptStruct Starbreeze.SkeletalMeshMergeParams
// 0x0040 (0x0040 - 0x0000)
struct FSkeletalMeshMergeParams final
{
public:
	TArray<struct FSkelMeshMergeSectionMapping_BP> MeshSectionMappings;                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSkelMeshMergeUVTransformMapping> UVTransformsPerMesh;                             // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSrcMesh_BP>                    MeshesToMerge;                                     // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         StripTopLODS;                                      // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bNeedsCpuAccess : 1;                               // 0x0034(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSkeletonBefore : 1;                               // 0x0034(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeleton*                              Skeleton;                                          // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkeletalMeshMergeParams) == 0x000008, "Wrong alignment on FSkeletalMeshMergeParams");
static_assert(sizeof(FSkeletalMeshMergeParams) == 0x000040, "Wrong size on FSkeletalMeshMergeParams");
static_assert(offsetof(FSkeletalMeshMergeParams, MeshSectionMappings) == 0x000000, "Member 'FSkeletalMeshMergeParams::MeshSectionMappings' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshMergeParams, UVTransformsPerMesh) == 0x000010, "Member 'FSkeletalMeshMergeParams::UVTransformsPerMesh' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshMergeParams, MeshesToMerge) == 0x000020, "Member 'FSkeletalMeshMergeParams::MeshesToMerge' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshMergeParams, StripTopLODS) == 0x000030, "Member 'FSkeletalMeshMergeParams::StripTopLODS' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshMergeParams, Skeleton) == 0x000038, "Member 'FSkeletalMeshMergeParams::Skeleton' has a wrong offset!");

// ScriptStruct Starbreeze.SBZStatisticCriteriaDataCollection
// 0x0060 (0x0060 - 0x0000)
struct FSBZStatisticCriteriaDataCollection final
{
public:
	class USBZStatisticCriteriaData*              PutOnMask;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZStatisticCriteriaData*              InsurancePolicy;                                   // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZStatisticCriteriaData*              CrowdControl;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZStatisticCriteriaData*              UnlimitedPower;                                    // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZTaserPackStunsCriteriaData*         TaserPackStuns;                                    // 0x0020(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZSmashAndGrabStatisticCriteriaData*  SmashAndGrab;                                      // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZSentryKillsStatisticCriteriaData*   SentryKills;                                       // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZAssaultCountStatisticCriteriaData*  AfterParty;                                        // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZStatisticCriteriaData*              ColorMeSurprised;                                  // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZStatisticCriteriaData*              SpecOps;                                           // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZStatisticCriteriaData*              NoBagOnGround;                                     // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZStatisticCriteriaData*              BranchBankNoDyePackExploded;                       // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZStatisticCriteriaDataCollection) == 0x000008, "Wrong alignment on FSBZStatisticCriteriaDataCollection");
static_assert(sizeof(FSBZStatisticCriteriaDataCollection) == 0x000060, "Wrong size on FSBZStatisticCriteriaDataCollection");
static_assert(offsetof(FSBZStatisticCriteriaDataCollection, PutOnMask) == 0x000000, "Member 'FSBZStatisticCriteriaDataCollection::PutOnMask' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCriteriaDataCollection, InsurancePolicy) == 0x000008, "Member 'FSBZStatisticCriteriaDataCollection::InsurancePolicy' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCriteriaDataCollection, CrowdControl) == 0x000010, "Member 'FSBZStatisticCriteriaDataCollection::CrowdControl' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCriteriaDataCollection, UnlimitedPower) == 0x000018, "Member 'FSBZStatisticCriteriaDataCollection::UnlimitedPower' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCriteriaDataCollection, TaserPackStuns) == 0x000020, "Member 'FSBZStatisticCriteriaDataCollection::TaserPackStuns' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCriteriaDataCollection, SmashAndGrab) == 0x000028, "Member 'FSBZStatisticCriteriaDataCollection::SmashAndGrab' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCriteriaDataCollection, SentryKills) == 0x000030, "Member 'FSBZStatisticCriteriaDataCollection::SentryKills' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCriteriaDataCollection, AfterParty) == 0x000038, "Member 'FSBZStatisticCriteriaDataCollection::AfterParty' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCriteriaDataCollection, ColorMeSurprised) == 0x000040, "Member 'FSBZStatisticCriteriaDataCollection::ColorMeSurprised' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCriteriaDataCollection, SpecOps) == 0x000048, "Member 'FSBZStatisticCriteriaDataCollection::SpecOps' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCriteriaDataCollection, NoBagOnGround) == 0x000050, "Member 'FSBZStatisticCriteriaDataCollection::NoBagOnGround' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCriteriaDataCollection, BranchBankNoDyePackExploded) == 0x000058, "Member 'FSBZStatisticCriteriaDataCollection::BranchBankNoDyePackExploded' has a wrong offset!");

// ScriptStruct Starbreeze.SBZStatisticCodeCollection
// 0x0360 (0x0360 - 0x0000)
struct FSBZStatisticCodeCollection final
{
public:
	class FString                                 ReviveCrewmate;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SlideDistance;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SlideKills;                                        // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SlideHeadshotKills;                                // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 JumpKills;                                         // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 JumpHeadshotKills;                                 // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HumanShieldTime;                                   // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HumanShieldKills;                                  // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HumanShieldHeadshotKills;                          // 0x0080(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DozerFaceplate;                                    // 0x0090(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DestroyTaserBattery;                               // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DestroyGrenadeBelt;                                // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BreakShieldVisor;                                  // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BreakDisplayCase;                                  // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HostagesTraded;                                    // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DoorSprint;                                        // 0x00F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CloakerSave;                                       // 0x0100(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TaserSave;                                         // 0x0110(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CutObjects;                                        // 0x0120(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LockPicked;                                        // 0x0130(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DetectedKills;                                     // 0x0140(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DevicesHacked;                                     // 0x0150(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SpecialEnemyKills;                                 // 0x0160(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EnemyKillsOverkillWeapon;                          // 0x0170(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EnemyDoubleKillsMarksmanWeapon;                    // 0x0180(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EnemyKillsLastBullet;                              // 0x0190(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EnemyKillsNoReload;                                // 0x01A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ZipTie;                                            // 0x01B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EnemyStuns;                                        // 0x01C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GainDamage;                                        // 0x01D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GainMitigation;                                    // 0x01E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GainSpeed;                                         // 0x01F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UseLures;                                          // 0x0200(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DestroyDoorLocks;                                  // 0x0210(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HackCameras;                                       // 0x0220(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SpecialEnemyKillsHumanShield;                      // 0x0230(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SecureBags;                                        // 0x0240(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SecureBagsAssaultStarted;                          // 0x0250(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SecureBagsNoAlarm;                                 // 0x0260(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RappellingEnemyKills;                              // 0x0270(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PickupAmmo;                                        // 0x0280(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EnemyKillsSilencedWeapon;                          // 0x0290(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CompletedHeists;                                   // 0x02A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CompletedHeistsAssaultStarted;                     // 0x02B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CompletedHeistsNoAlarm;                            // 0x02C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CompletedHeistsVeryHardAndAbove;                   // 0x02D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CompletedHeistsSecuredBags;                        // 0x02E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CompletedHeistsInstantLootTaken;                   // 0x02F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CompletedHeistsNoAlarmNoSilencedWeapon;            // 0x0300(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CompletedHeistsNoCustody;                          // 0x0310(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CompletedHeistsSurviveThreeAssault;                // 0x0320(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CompletedHeistsHeadshotKilled30;                   // 0x0330(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CutWindows;                                        // 0x0340(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EnemyGrenadeMultiKill;                             // 0x0350(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZStatisticCodeCollection) == 0x000008, "Wrong alignment on FSBZStatisticCodeCollection");
static_assert(sizeof(FSBZStatisticCodeCollection) == 0x000360, "Wrong size on FSBZStatisticCodeCollection");
static_assert(offsetof(FSBZStatisticCodeCollection, ReviveCrewmate) == 0x000000, "Member 'FSBZStatisticCodeCollection::ReviveCrewmate' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, SlideDistance) == 0x000010, "Member 'FSBZStatisticCodeCollection::SlideDistance' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, SlideKills) == 0x000020, "Member 'FSBZStatisticCodeCollection::SlideKills' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, SlideHeadshotKills) == 0x000030, "Member 'FSBZStatisticCodeCollection::SlideHeadshotKills' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, JumpKills) == 0x000040, "Member 'FSBZStatisticCodeCollection::JumpKills' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, JumpHeadshotKills) == 0x000050, "Member 'FSBZStatisticCodeCollection::JumpHeadshotKills' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, HumanShieldTime) == 0x000060, "Member 'FSBZStatisticCodeCollection::HumanShieldTime' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, HumanShieldKills) == 0x000070, "Member 'FSBZStatisticCodeCollection::HumanShieldKills' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, HumanShieldHeadshotKills) == 0x000080, "Member 'FSBZStatisticCodeCollection::HumanShieldHeadshotKills' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, DozerFaceplate) == 0x000090, "Member 'FSBZStatisticCodeCollection::DozerFaceplate' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, DestroyTaserBattery) == 0x0000A0, "Member 'FSBZStatisticCodeCollection::DestroyTaserBattery' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, DestroyGrenadeBelt) == 0x0000B0, "Member 'FSBZStatisticCodeCollection::DestroyGrenadeBelt' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, BreakShieldVisor) == 0x0000C0, "Member 'FSBZStatisticCodeCollection::BreakShieldVisor' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, BreakDisplayCase) == 0x0000D0, "Member 'FSBZStatisticCodeCollection::BreakDisplayCase' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, HostagesTraded) == 0x0000E0, "Member 'FSBZStatisticCodeCollection::HostagesTraded' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, DoorSprint) == 0x0000F0, "Member 'FSBZStatisticCodeCollection::DoorSprint' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, CloakerSave) == 0x000100, "Member 'FSBZStatisticCodeCollection::CloakerSave' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, TaserSave) == 0x000110, "Member 'FSBZStatisticCodeCollection::TaserSave' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, CutObjects) == 0x000120, "Member 'FSBZStatisticCodeCollection::CutObjects' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, LockPicked) == 0x000130, "Member 'FSBZStatisticCodeCollection::LockPicked' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, DetectedKills) == 0x000140, "Member 'FSBZStatisticCodeCollection::DetectedKills' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, DevicesHacked) == 0x000150, "Member 'FSBZStatisticCodeCollection::DevicesHacked' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, SpecialEnemyKills) == 0x000160, "Member 'FSBZStatisticCodeCollection::SpecialEnemyKills' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, EnemyKillsOverkillWeapon) == 0x000170, "Member 'FSBZStatisticCodeCollection::EnemyKillsOverkillWeapon' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, EnemyDoubleKillsMarksmanWeapon) == 0x000180, "Member 'FSBZStatisticCodeCollection::EnemyDoubleKillsMarksmanWeapon' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, EnemyKillsLastBullet) == 0x000190, "Member 'FSBZStatisticCodeCollection::EnemyKillsLastBullet' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, EnemyKillsNoReload) == 0x0001A0, "Member 'FSBZStatisticCodeCollection::EnemyKillsNoReload' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, ZipTie) == 0x0001B0, "Member 'FSBZStatisticCodeCollection::ZipTie' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, EnemyStuns) == 0x0001C0, "Member 'FSBZStatisticCodeCollection::EnemyStuns' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, GainDamage) == 0x0001D0, "Member 'FSBZStatisticCodeCollection::GainDamage' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, GainMitigation) == 0x0001E0, "Member 'FSBZStatisticCodeCollection::GainMitigation' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, GainSpeed) == 0x0001F0, "Member 'FSBZStatisticCodeCollection::GainSpeed' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, UseLures) == 0x000200, "Member 'FSBZStatisticCodeCollection::UseLures' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, DestroyDoorLocks) == 0x000210, "Member 'FSBZStatisticCodeCollection::DestroyDoorLocks' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, HackCameras) == 0x000220, "Member 'FSBZStatisticCodeCollection::HackCameras' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, SpecialEnemyKillsHumanShield) == 0x000230, "Member 'FSBZStatisticCodeCollection::SpecialEnemyKillsHumanShield' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, SecureBags) == 0x000240, "Member 'FSBZStatisticCodeCollection::SecureBags' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, SecureBagsAssaultStarted) == 0x000250, "Member 'FSBZStatisticCodeCollection::SecureBagsAssaultStarted' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, SecureBagsNoAlarm) == 0x000260, "Member 'FSBZStatisticCodeCollection::SecureBagsNoAlarm' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, RappellingEnemyKills) == 0x000270, "Member 'FSBZStatisticCodeCollection::RappellingEnemyKills' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, PickupAmmo) == 0x000280, "Member 'FSBZStatisticCodeCollection::PickupAmmo' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, EnemyKillsSilencedWeapon) == 0x000290, "Member 'FSBZStatisticCodeCollection::EnemyKillsSilencedWeapon' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, CompletedHeists) == 0x0002A0, "Member 'FSBZStatisticCodeCollection::CompletedHeists' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, CompletedHeistsAssaultStarted) == 0x0002B0, "Member 'FSBZStatisticCodeCollection::CompletedHeistsAssaultStarted' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, CompletedHeistsNoAlarm) == 0x0002C0, "Member 'FSBZStatisticCodeCollection::CompletedHeistsNoAlarm' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, CompletedHeistsVeryHardAndAbove) == 0x0002D0, "Member 'FSBZStatisticCodeCollection::CompletedHeistsVeryHardAndAbove' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, CompletedHeistsSecuredBags) == 0x0002E0, "Member 'FSBZStatisticCodeCollection::CompletedHeistsSecuredBags' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, CompletedHeistsInstantLootTaken) == 0x0002F0, "Member 'FSBZStatisticCodeCollection::CompletedHeistsInstantLootTaken' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, CompletedHeistsNoAlarmNoSilencedWeapon) == 0x000300, "Member 'FSBZStatisticCodeCollection::CompletedHeistsNoAlarmNoSilencedWeapon' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, CompletedHeistsNoCustody) == 0x000310, "Member 'FSBZStatisticCodeCollection::CompletedHeistsNoCustody' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, CompletedHeistsSurviveThreeAssault) == 0x000320, "Member 'FSBZStatisticCodeCollection::CompletedHeistsSurviveThreeAssault' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, CompletedHeistsHeadshotKilled30) == 0x000330, "Member 'FSBZStatisticCodeCollection::CompletedHeistsHeadshotKilled30' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, CutWindows) == 0x000340, "Member 'FSBZStatisticCodeCollection::CutWindows' has a wrong offset!");
static_assert(offsetof(FSBZStatisticCodeCollection, EnemyGrenadeMultiKill) == 0x000350, "Member 'FSBZStatisticCodeCollection::EnemyGrenadeMultiKill' has a wrong offset!");

// ScriptStruct Starbreeze.SBZRepSharedKeyItemTags
// 0x0010 (0x0010 - 0x0000)
struct FSBZRepSharedKeyItemTags final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x000C)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZRepSharedKeyItemTags) == 0x000004, "Wrong alignment on FSBZRepSharedKeyItemTags");
static_assert(sizeof(FSBZRepSharedKeyItemTags) == 0x000010, "Wrong size on FSBZRepSharedKeyItemTags");
static_assert(offsetof(FSBZRepSharedKeyItemTags, Tag) == 0x000000, "Member 'FSBZRepSharedKeyItemTags::Tag' has a wrong offset!");
static_assert(offsetof(FSBZRepSharedKeyItemTags, Count) == 0x00000C, "Member 'FSBZRepSharedKeyItemTags::Count' has a wrong offset!");

// ScriptStruct Starbreeze.SBZModularMeshVisibility
// 0x0018 (0x0018 - 0x0000)
struct FSBZModularMeshVisibility final
{
public:
	class USkeletalMeshComponent*                 ModularMesh;                                       // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0008(0x000C)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVisibilityState;                                  // 0x0014(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZModularMeshVisibility) == 0x000008, "Wrong alignment on FSBZModularMeshVisibility");
static_assert(sizeof(FSBZModularMeshVisibility) == 0x000018, "Wrong size on FSBZModularMeshVisibility");
static_assert(offsetof(FSBZModularMeshVisibility, ModularMesh) == 0x000000, "Member 'FSBZModularMeshVisibility::ModularMesh' has a wrong offset!");
static_assert(offsetof(FSBZModularMeshVisibility, Tag) == 0x000008, "Member 'FSBZModularMeshVisibility::Tag' has a wrong offset!");
static_assert(offsetof(FSBZModularMeshVisibility, bVisibilityState) == 0x000014, "Member 'FSBZModularMeshVisibility::bVisibilityState' has a wrong offset!");

// ScriptStruct Starbreeze.SBZModularMeshData
// 0x0168 (0x0168 - 0x0000)
struct FSBZModularMeshData final
{
public:
	TSoftObjectPtr<class USkeletalMesh>           SkeletalMesh;                                      // 0x0000(0x0030)(Edit, DisableEditOnTemplate, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class USkeletalMeshComponent>     SkeletalMeshClass;                                 // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZModularPartSlotBase*                SpawnSlot;                                         // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZModularMeshSpawnStep                      SpawnStep;                                         // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bModifiesBaseMesh;                                 // 0x0041(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           AppliedPartBoneToRig;                              // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<class FName>                           DontApplyPartBone;                                 // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<class FName>                           DontApplyPartBoneIfAlreadyChanged;                 // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TMap<class FName, class FName>                MapPartBoneToRigBone;                              // 0x0078(0x0050)(Edit, BlueprintVisible, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<struct FSBZBoneAnimContraint>          RigBoneAnimConstraints;                            // 0x00C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class FName                                   AttachBoneParentOverride;                          // 0x00D8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotAnimatedPart;                                  // 0x00E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  SpawnOnlyIfAllTagsArePresent;                      // 0x00E8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  DontSpawnIfTagIsPresent;                           // 0x0108(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           VisibilityTag;                                     // 0x0128(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVisibilityTagState;                               // 0x0134(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_135[0x3];                                      // 0x0135(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  TagContainer;                                      // 0x0138(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class USBZModularPartSlotBase*                ParentSlot;                                        // 0x0158(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZModularPartDataAsset*               ParentPart;                                        // 0x0160(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZModularMeshData) == 0x000008, "Wrong alignment on FSBZModularMeshData");
static_assert(sizeof(FSBZModularMeshData) == 0x000168, "Wrong size on FSBZModularMeshData");
static_assert(offsetof(FSBZModularMeshData, SkeletalMesh) == 0x000000, "Member 'FSBZModularMeshData::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(FSBZModularMeshData, SkeletalMeshClass) == 0x000030, "Member 'FSBZModularMeshData::SkeletalMeshClass' has a wrong offset!");
static_assert(offsetof(FSBZModularMeshData, SpawnSlot) == 0x000038, "Member 'FSBZModularMeshData::SpawnSlot' has a wrong offset!");
static_assert(offsetof(FSBZModularMeshData, SpawnStep) == 0x000040, "Member 'FSBZModularMeshData::SpawnStep' has a wrong offset!");
static_assert(offsetof(FSBZModularMeshData, bModifiesBaseMesh) == 0x000041, "Member 'FSBZModularMeshData::bModifiesBaseMesh' has a wrong offset!");
static_assert(offsetof(FSBZModularMeshData, AppliedPartBoneToRig) == 0x000048, "Member 'FSBZModularMeshData::AppliedPartBoneToRig' has a wrong offset!");
static_assert(offsetof(FSBZModularMeshData, DontApplyPartBone) == 0x000058, "Member 'FSBZModularMeshData::DontApplyPartBone' has a wrong offset!");
static_assert(offsetof(FSBZModularMeshData, DontApplyPartBoneIfAlreadyChanged) == 0x000068, "Member 'FSBZModularMeshData::DontApplyPartBoneIfAlreadyChanged' has a wrong offset!");
static_assert(offsetof(FSBZModularMeshData, MapPartBoneToRigBone) == 0x000078, "Member 'FSBZModularMeshData::MapPartBoneToRigBone' has a wrong offset!");
static_assert(offsetof(FSBZModularMeshData, RigBoneAnimConstraints) == 0x0000C8, "Member 'FSBZModularMeshData::RigBoneAnimConstraints' has a wrong offset!");
static_assert(offsetof(FSBZModularMeshData, AttachBoneParentOverride) == 0x0000D8, "Member 'FSBZModularMeshData::AttachBoneParentOverride' has a wrong offset!");
static_assert(offsetof(FSBZModularMeshData, bNotAnimatedPart) == 0x0000E4, "Member 'FSBZModularMeshData::bNotAnimatedPart' has a wrong offset!");
static_assert(offsetof(FSBZModularMeshData, SpawnOnlyIfAllTagsArePresent) == 0x0000E8, "Member 'FSBZModularMeshData::SpawnOnlyIfAllTagsArePresent' has a wrong offset!");
static_assert(offsetof(FSBZModularMeshData, DontSpawnIfTagIsPresent) == 0x000108, "Member 'FSBZModularMeshData::DontSpawnIfTagIsPresent' has a wrong offset!");
static_assert(offsetof(FSBZModularMeshData, VisibilityTag) == 0x000128, "Member 'FSBZModularMeshData::VisibilityTag' has a wrong offset!");
static_assert(offsetof(FSBZModularMeshData, bVisibilityTagState) == 0x000134, "Member 'FSBZModularMeshData::bVisibilityTagState' has a wrong offset!");
static_assert(offsetof(FSBZModularMeshData, TagContainer) == 0x000138, "Member 'FSBZModularMeshData::TagContainer' has a wrong offset!");
static_assert(offsetof(FSBZModularMeshData, ParentSlot) == 0x000158, "Member 'FSBZModularMeshData::ParentSlot' has a wrong offset!");
static_assert(offsetof(FSBZModularMeshData, ParentPart) == 0x000160, "Member 'FSBZModularMeshData::ParentPart' has a wrong offset!");

// ScriptStruct Starbreeze.SBZModularPartSlotConfiguration
// 0x0028 (0x0028 - 0x0000)
struct FSBZModularPartSlotConfiguration final
{
public:
	class USBZModularPartDataAsset*               DefaultPart;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USBZModularPartDataAsset*>       UniqueModParts;                                    // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class USBZSharedPartList*>             SharedParts;                                       // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZModularPartSlotConfiguration) == 0x000008, "Wrong alignment on FSBZModularPartSlotConfiguration");
static_assert(sizeof(FSBZModularPartSlotConfiguration) == 0x000028, "Wrong size on FSBZModularPartSlotConfiguration");
static_assert(offsetof(FSBZModularPartSlotConfiguration, DefaultPart) == 0x000000, "Member 'FSBZModularPartSlotConfiguration::DefaultPart' has a wrong offset!");
static_assert(offsetof(FSBZModularPartSlotConfiguration, UniqueModParts) == 0x000008, "Member 'FSBZModularPartSlotConfiguration::UniqueModParts' has a wrong offset!");
static_assert(offsetof(FSBZModularPartSlotConfiguration, SharedParts) == 0x000018, "Member 'FSBZModularPartSlotConfiguration::SharedParts' has a wrong offset!");

// ScriptStruct Starbreeze.SBZModularSlotPart
// 0x0010 (0x0010 - 0x0000)
struct FSBZModularSlotPart final
{
public:
	class USBZModularPartSlotBase*                PartSlot;                                          // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZModularPartDataAsset*               PartDataAsset;                                     // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZModularSlotPart) == 0x000008, "Wrong alignment on FSBZModularSlotPart");
static_assert(sizeof(FSBZModularSlotPart) == 0x000010, "Wrong size on FSBZModularSlotPart");
static_assert(offsetof(FSBZModularSlotPart, PartSlot) == 0x000000, "Member 'FSBZModularSlotPart::PartSlot' has a wrong offset!");
static_assert(offsetof(FSBZModularSlotPart, PartDataAsset) == 0x000008, "Member 'FSBZModularSlotPart::PartDataAsset' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCodeAndIdentifier
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FSBZCodeAndIdentifier final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZCodeAndIdentifier) == 0x000008, "Wrong alignment on FSBZCodeAndIdentifier");
static_assert(sizeof(FSBZCodeAndIdentifier) == 0x000020, "Wrong size on FSBZCodeAndIdentifier");

// ScriptStruct Starbreeze.SBZCachedNavLinkPoints
// 0x0028 (0x0028 - 0x0000)
struct FSBZCachedNavLinkPoints final
{
public:
	TScriptInterface<class ISBZBlockableNavlinkInterface> NavLink;                                   // 0x0000(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x18];                                      // 0x0010(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZCachedNavLinkPoints) == 0x000008, "Wrong alignment on FSBZCachedNavLinkPoints");
static_assert(sizeof(FSBZCachedNavLinkPoints) == 0x000028, "Wrong size on FSBZCachedNavLinkPoints");
static_assert(offsetof(FSBZCachedNavLinkPoints, NavLink) == 0x000000, "Member 'FSBZCachedNavLinkPoints::NavLink' has a wrong offset!");

// ScriptStruct Starbreeze.SBZNegotiationDifficultySettings
// 0x0028 (0x0028 - 0x0000)
struct FSBZNegotiationDifficultySettings final
{
public:
	uint32                                        BaseNrHostagesRequired;                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        NrHostagesToAddPerDemand;                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseTime;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BonusTime;                                         // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DemandInterval;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemainingTimeDemandThreshold;                      // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayAssaultSeconds;                               // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReducePlayerSpectateSeconds;                       // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CivilianKilledExtraTime;                           // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxExtraCustodyTime;                               // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZNegotiationDifficultySettings) == 0x000004, "Wrong alignment on FSBZNegotiationDifficultySettings");
static_assert(sizeof(FSBZNegotiationDifficultySettings) == 0x000028, "Wrong size on FSBZNegotiationDifficultySettings");
static_assert(offsetof(FSBZNegotiationDifficultySettings, BaseNrHostagesRequired) == 0x000000, "Member 'FSBZNegotiationDifficultySettings::BaseNrHostagesRequired' has a wrong offset!");
static_assert(offsetof(FSBZNegotiationDifficultySettings, NrHostagesToAddPerDemand) == 0x000004, "Member 'FSBZNegotiationDifficultySettings::NrHostagesToAddPerDemand' has a wrong offset!");
static_assert(offsetof(FSBZNegotiationDifficultySettings, BaseTime) == 0x000008, "Member 'FSBZNegotiationDifficultySettings::BaseTime' has a wrong offset!");
static_assert(offsetof(FSBZNegotiationDifficultySettings, BonusTime) == 0x00000C, "Member 'FSBZNegotiationDifficultySettings::BonusTime' has a wrong offset!");
static_assert(offsetof(FSBZNegotiationDifficultySettings, DemandInterval) == 0x000010, "Member 'FSBZNegotiationDifficultySettings::DemandInterval' has a wrong offset!");
static_assert(offsetof(FSBZNegotiationDifficultySettings, RemainingTimeDemandThreshold) == 0x000014, "Member 'FSBZNegotiationDifficultySettings::RemainingTimeDemandThreshold' has a wrong offset!");
static_assert(offsetof(FSBZNegotiationDifficultySettings, DelayAssaultSeconds) == 0x000018, "Member 'FSBZNegotiationDifficultySettings::DelayAssaultSeconds' has a wrong offset!");
static_assert(offsetof(FSBZNegotiationDifficultySettings, ReducePlayerSpectateSeconds) == 0x00001C, "Member 'FSBZNegotiationDifficultySettings::ReducePlayerSpectateSeconds' has a wrong offset!");
static_assert(offsetof(FSBZNegotiationDifficultySettings, CivilianKilledExtraTime) == 0x000020, "Member 'FSBZNegotiationDifficultySettings::CivilianKilledExtraTime' has a wrong offset!");
static_assert(offsetof(FSBZNegotiationDifficultySettings, MaxExtraCustodyTime) == 0x000024, "Member 'FSBZNegotiationDifficultySettings::MaxExtraCustodyTime' has a wrong offset!");

// ScriptStruct Starbreeze.SBZNewsDataEntry
// 0x0058 (0x0058 - 0x0000)
struct FSBZNewsDataEntry final
{
public:
	class FString                                 NewsId;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StackName;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Title;                                             // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Subtitle;                                          // 0x0038(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UPaperSprite*                           Image;                                             // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZNewsDataEntry) == 0x000008, "Wrong alignment on FSBZNewsDataEntry");
static_assert(sizeof(FSBZNewsDataEntry) == 0x000058, "Wrong size on FSBZNewsDataEntry");
static_assert(offsetof(FSBZNewsDataEntry, NewsId) == 0x000000, "Member 'FSBZNewsDataEntry::NewsId' has a wrong offset!");
static_assert(offsetof(FSBZNewsDataEntry, StackName) == 0x000010, "Member 'FSBZNewsDataEntry::StackName' has a wrong offset!");
static_assert(offsetof(FSBZNewsDataEntry, Title) == 0x000020, "Member 'FSBZNewsDataEntry::Title' has a wrong offset!");
static_assert(offsetof(FSBZNewsDataEntry, Subtitle) == 0x000038, "Member 'FSBZNewsDataEntry::Subtitle' has a wrong offset!");
static_assert(offsetof(FSBZNewsDataEntry, Image) == 0x000050, "Member 'FSBZNewsDataEntry::Image' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMergePlayerData
// 0x0018 (0x0018 - 0x0000)
struct FSBZMergePlayerData final
{
public:
	class FString                                 PlayerDisplayName;                                 // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMergePartySelecter;                             // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZMergePlayerData) == 0x000008, "Wrong alignment on FSBZMergePlayerData");
static_assert(sizeof(FSBZMergePlayerData) == 0x000018, "Wrong size on FSBZMergePlayerData");
static_assert(offsetof(FSBZMergePlayerData, PlayerDisplayName) == 0x000000, "Member 'FSBZMergePlayerData::PlayerDisplayName' has a wrong offset!");
static_assert(offsetof(FSBZMergePlayerData, bIsMergePartySelecter) == 0x000010, "Member 'FSBZMergePlayerData::bIsMergePartySelecter' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSessionSettingQueueItem
// 0x0070 (0x0070 - 0x0000)
struct alignas(0x10) FSBZSessionSettingQueueItem final
{
public:
	uint8                                         Pad_0[0x70];                                       // 0x0000(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZSessionSettingQueueItem) == 0x000010, "Wrong alignment on FSBZSessionSettingQueueItem");
static_assert(sizeof(FSBZSessionSettingQueueItem) == 0x000070, "Wrong size on FSBZSessionSettingQueueItem");

// ScriptStruct Starbreeze.SBZUserActivity
// 0x00B8 (0x00B8 - 0x0000)
struct FSBZUserActivity final
{
public:
	class FString                                 IP;                                                // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Port;                                              // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PortBeacon;                                        // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MatchID;                                           // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServerVersion;                                     // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelIdx;                                          // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PartyCode;                                         // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameSessionCode;                                   // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NetVersion;                                        // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCrossPlayEnabled;                                 // 0x0070(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInCrossPlayLobby;                                 // 0x0071(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInCrossPlayAllowedLobby;                          // 0x0072(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZOnlineJoinType                            JoinType;                                          // 0x0073(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GameState;                                         // 0x0074(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GameSessionMembers;                                // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PartySessionMembers;                               // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAreInfamyPointsValid;                             // 0x0088(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InfamyPoints;                                      // 0x008C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRenownLevelValid;                               // 0x0090(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RenownLevel;                                       // 0x0094(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZHostingProvider                           HostingProvider;                                   // 0x0098(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHost;                                           // 0x0099(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 HeistOwner;                                        // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DifficultyIdx;                                     // 0x00B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZOnlineTacticType                          TacticIdx;                                         // 0x00B4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZUserActivity) == 0x000008, "Wrong alignment on FSBZUserActivity");
static_assert(sizeof(FSBZUserActivity) == 0x0000B8, "Wrong size on FSBZUserActivity");
static_assert(offsetof(FSBZUserActivity, IP) == 0x000000, "Member 'FSBZUserActivity::IP' has a wrong offset!");
static_assert(offsetof(FSBZUserActivity, Port) == 0x000010, "Member 'FSBZUserActivity::Port' has a wrong offset!");
static_assert(offsetof(FSBZUserActivity, PortBeacon) == 0x000014, "Member 'FSBZUserActivity::PortBeacon' has a wrong offset!");
static_assert(offsetof(FSBZUserActivity, MatchID) == 0x000018, "Member 'FSBZUserActivity::MatchID' has a wrong offset!");
static_assert(offsetof(FSBZUserActivity, ServerVersion) == 0x000028, "Member 'FSBZUserActivity::ServerVersion' has a wrong offset!");
static_assert(offsetof(FSBZUserActivity, LevelIdx) == 0x000038, "Member 'FSBZUserActivity::LevelIdx' has a wrong offset!");
static_assert(offsetof(FSBZUserActivity, PartyCode) == 0x000040, "Member 'FSBZUserActivity::PartyCode' has a wrong offset!");
static_assert(offsetof(FSBZUserActivity, GameSessionCode) == 0x000050, "Member 'FSBZUserActivity::GameSessionCode' has a wrong offset!");
static_assert(offsetof(FSBZUserActivity, NetVersion) == 0x000060, "Member 'FSBZUserActivity::NetVersion' has a wrong offset!");
static_assert(offsetof(FSBZUserActivity, bCrossPlayEnabled) == 0x000070, "Member 'FSBZUserActivity::bCrossPlayEnabled' has a wrong offset!");
static_assert(offsetof(FSBZUserActivity, bInCrossPlayLobby) == 0x000071, "Member 'FSBZUserActivity::bInCrossPlayLobby' has a wrong offset!");
static_assert(offsetof(FSBZUserActivity, bInCrossPlayAllowedLobby) == 0x000072, "Member 'FSBZUserActivity::bInCrossPlayAllowedLobby' has a wrong offset!");
static_assert(offsetof(FSBZUserActivity, JoinType) == 0x000073, "Member 'FSBZUserActivity::JoinType' has a wrong offset!");
static_assert(offsetof(FSBZUserActivity, GameState) == 0x000074, "Member 'FSBZUserActivity::GameState' has a wrong offset!");
static_assert(offsetof(FSBZUserActivity, GameSessionMembers) == 0x000080, "Member 'FSBZUserActivity::GameSessionMembers' has a wrong offset!");
static_assert(offsetof(FSBZUserActivity, PartySessionMembers) == 0x000084, "Member 'FSBZUserActivity::PartySessionMembers' has a wrong offset!");
static_assert(offsetof(FSBZUserActivity, bAreInfamyPointsValid) == 0x000088, "Member 'FSBZUserActivity::bAreInfamyPointsValid' has a wrong offset!");
static_assert(offsetof(FSBZUserActivity, InfamyPoints) == 0x00008C, "Member 'FSBZUserActivity::InfamyPoints' has a wrong offset!");
static_assert(offsetof(FSBZUserActivity, bIsRenownLevelValid) == 0x000090, "Member 'FSBZUserActivity::bIsRenownLevelValid' has a wrong offset!");
static_assert(offsetof(FSBZUserActivity, RenownLevel) == 0x000094, "Member 'FSBZUserActivity::RenownLevel' has a wrong offset!");
static_assert(offsetof(FSBZUserActivity, HostingProvider) == 0x000098, "Member 'FSBZUserActivity::HostingProvider' has a wrong offset!");
static_assert(offsetof(FSBZUserActivity, bIsHost) == 0x000099, "Member 'FSBZUserActivity::bIsHost' has a wrong offset!");
static_assert(offsetof(FSBZUserActivity, HeistOwner) == 0x0000A0, "Member 'FSBZUserActivity::HeistOwner' has a wrong offset!");
static_assert(offsetof(FSBZUserActivity, DifficultyIdx) == 0x0000B0, "Member 'FSBZUserActivity::DifficultyIdx' has a wrong offset!");
static_assert(offsetof(FSBZUserActivity, TacticIdx) == 0x0000B4, "Member 'FSBZUserActivity::TacticIdx' has a wrong offset!");

// ScriptStruct Starbreeze.SBZFriendListEntry
// 0x01B0 (0x01B0 - 0x0000)
struct FSBZFriendListEntry final
{
public:
	class FText                                   FriendName;                                        // 0x0000(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   HiddenFriendName;                                  // 0x0018(0x0018)(NativeAccessSpecifierPublic)
	class FString                                 UserId;                                            // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlatformUserId;                                    // 0x0040(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   PlatformFriendName;                                // 0x0050(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 PlatformId;                                        // 0x0068(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZFirstPartyPlatform                        FirstPartyPlatform;                                // 0x0078(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFriendStatus                                 FriendStatus;                                      // 0x0079(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x2];                                       // 0x007A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LevelIdx;                                          // 0x007C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InfamyLevel;                                       // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RenownLevel;                                       // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlatformBlocked;                                  // 0x0088(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlatformPlayer;                                   // 0x0089(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A[0x6];                                       // 0x008A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class FString>            PlatformUserIds;                                   // 0x0090(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	class UPaperSprite*                           PlatformIcon;                                      // 0x00E0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPaperSprite*                           NebulaIcon;                                        // 0x00E8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSBZUserActivity                       UserActivity;                                      // 0x00F0(0x00B8)(BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bCanCommunicateWith;                               // 0x01A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A9[0x7];                                      // 0x01A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZFriendListEntry) == 0x000008, "Wrong alignment on FSBZFriendListEntry");
static_assert(sizeof(FSBZFriendListEntry) == 0x0001B0, "Wrong size on FSBZFriendListEntry");
static_assert(offsetof(FSBZFriendListEntry, FriendName) == 0x000000, "Member 'FSBZFriendListEntry::FriendName' has a wrong offset!");
static_assert(offsetof(FSBZFriendListEntry, HiddenFriendName) == 0x000018, "Member 'FSBZFriendListEntry::HiddenFriendName' has a wrong offset!");
static_assert(offsetof(FSBZFriendListEntry, UserId) == 0x000030, "Member 'FSBZFriendListEntry::UserId' has a wrong offset!");
static_assert(offsetof(FSBZFriendListEntry, PlatformUserId) == 0x000040, "Member 'FSBZFriendListEntry::PlatformUserId' has a wrong offset!");
static_assert(offsetof(FSBZFriendListEntry, PlatformFriendName) == 0x000050, "Member 'FSBZFriendListEntry::PlatformFriendName' has a wrong offset!");
static_assert(offsetof(FSBZFriendListEntry, PlatformId) == 0x000068, "Member 'FSBZFriendListEntry::PlatformId' has a wrong offset!");
static_assert(offsetof(FSBZFriendListEntry, FirstPartyPlatform) == 0x000078, "Member 'FSBZFriendListEntry::FirstPartyPlatform' has a wrong offset!");
static_assert(offsetof(FSBZFriendListEntry, FriendStatus) == 0x000079, "Member 'FSBZFriendListEntry::FriendStatus' has a wrong offset!");
static_assert(offsetof(FSBZFriendListEntry, LevelIdx) == 0x00007C, "Member 'FSBZFriendListEntry::LevelIdx' has a wrong offset!");
static_assert(offsetof(FSBZFriendListEntry, InfamyLevel) == 0x000080, "Member 'FSBZFriendListEntry::InfamyLevel' has a wrong offset!");
static_assert(offsetof(FSBZFriendListEntry, RenownLevel) == 0x000084, "Member 'FSBZFriendListEntry::RenownLevel' has a wrong offset!");
static_assert(offsetof(FSBZFriendListEntry, bPlatformBlocked) == 0x000088, "Member 'FSBZFriendListEntry::bPlatformBlocked' has a wrong offset!");
static_assert(offsetof(FSBZFriendListEntry, bPlatformPlayer) == 0x000089, "Member 'FSBZFriendListEntry::bPlatformPlayer' has a wrong offset!");
static_assert(offsetof(FSBZFriendListEntry, PlatformUserIds) == 0x000090, "Member 'FSBZFriendListEntry::PlatformUserIds' has a wrong offset!");
static_assert(offsetof(FSBZFriendListEntry, PlatformIcon) == 0x0000E0, "Member 'FSBZFriendListEntry::PlatformIcon' has a wrong offset!");
static_assert(offsetof(FSBZFriendListEntry, NebulaIcon) == 0x0000E8, "Member 'FSBZFriendListEntry::NebulaIcon' has a wrong offset!");
static_assert(offsetof(FSBZFriendListEntry, UserActivity) == 0x0000F0, "Member 'FSBZFriendListEntry::UserActivity' has a wrong offset!");
static_assert(offsetof(FSBZFriendListEntry, bCanCommunicateWith) == 0x0001A8, "Member 'FSBZFriendListEntry::bCanCommunicateWith' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSelectedMissionInfo
// 0x0008 (0x0008 - 0x0000)
struct FSBZSelectedMissionInfo final
{
public:
	int32                                         LevelSchematicIdx;                                 // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DifficultyIdx;                                     // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSelectedMissionInfo) == 0x000004, "Wrong alignment on FSBZSelectedMissionInfo");
static_assert(sizeof(FSBZSelectedMissionInfo) == 0x000008, "Wrong size on FSBZSelectedMissionInfo");
static_assert(offsetof(FSBZSelectedMissionInfo, LevelSchematicIdx) == 0x000000, "Member 'FSBZSelectedMissionInfo::LevelSchematicIdx' has a wrong offset!");
static_assert(offsetof(FSBZSelectedMissionInfo, DifficultyIdx) == 0x000004, "Member 'FSBZSelectedMissionInfo::DifficultyIdx' has a wrong offset!");

// ScriptStruct Starbreeze.SBZOnlineMatchmakingParams
// 0x0028 (0x0028 - 0x0000)
struct FSBZOnlineMatchmakingParams final
{
public:
	bool                                          bQuickMatch;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LevelIdx;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DifficultyIdx;                                     // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ESBZSecurityCompany>                   SecurityCompanies;                                 // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         MatchmakingRandomSeed;                             // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZMatchmakingCommand                        Command;                                           // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHost;                                           // 0x0025(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZOnlineTacticType                          TacticType;                                        // 0x0026(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsServerBrowserJoin;                              // 0x0027(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZOnlineMatchmakingParams) == 0x000008, "Wrong alignment on FSBZOnlineMatchmakingParams");
static_assert(sizeof(FSBZOnlineMatchmakingParams) == 0x000028, "Wrong size on FSBZOnlineMatchmakingParams");
static_assert(offsetof(FSBZOnlineMatchmakingParams, bQuickMatch) == 0x000000, "Member 'FSBZOnlineMatchmakingParams::bQuickMatch' has a wrong offset!");
static_assert(offsetof(FSBZOnlineMatchmakingParams, LevelIdx) == 0x000004, "Member 'FSBZOnlineMatchmakingParams::LevelIdx' has a wrong offset!");
static_assert(offsetof(FSBZOnlineMatchmakingParams, DifficultyIdx) == 0x000008, "Member 'FSBZOnlineMatchmakingParams::DifficultyIdx' has a wrong offset!");
static_assert(offsetof(FSBZOnlineMatchmakingParams, SecurityCompanies) == 0x000010, "Member 'FSBZOnlineMatchmakingParams::SecurityCompanies' has a wrong offset!");
static_assert(offsetof(FSBZOnlineMatchmakingParams, MatchmakingRandomSeed) == 0x000020, "Member 'FSBZOnlineMatchmakingParams::MatchmakingRandomSeed' has a wrong offset!");
static_assert(offsetof(FSBZOnlineMatchmakingParams, Command) == 0x000024, "Member 'FSBZOnlineMatchmakingParams::Command' has a wrong offset!");
static_assert(offsetof(FSBZOnlineMatchmakingParams, bIsHost) == 0x000025, "Member 'FSBZOnlineMatchmakingParams::bIsHost' has a wrong offset!");
static_assert(offsetof(FSBZOnlineMatchmakingParams, TacticType) == 0x000026, "Member 'FSBZOnlineMatchmakingParams::TacticType' has a wrong offset!");
static_assert(offsetof(FSBZOnlineMatchmakingParams, bIsServerBrowserJoin) == 0x000027, "Member 'FSBZOnlineMatchmakingParams::bIsServerBrowserJoin' has a wrong offset!");

// ScriptStruct Starbreeze.SBZLobbyCharacterInfo
// 0x0058 (0x0058 - 0x0000)
struct FSBZLobbyCharacterInfo final
{
public:
	struct FUniqueNetIdRepl                       PlayerUid;                                         // 0x0000(0x0028)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EOSProdUId;                                        // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPlayerReady;                                    // 0x0038(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerAcceptedMatch;                              // 0x0039(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LevelIdx;                                          // 0x003C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PowerLevel;                                        // 0x0040(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Nickname;                                          // 0x0048(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZLobbyCharacterInfo) == 0x000008, "Wrong alignment on FSBZLobbyCharacterInfo");
static_assert(sizeof(FSBZLobbyCharacterInfo) == 0x000058, "Wrong size on FSBZLobbyCharacterInfo");
static_assert(offsetof(FSBZLobbyCharacterInfo, PlayerUid) == 0x000000, "Member 'FSBZLobbyCharacterInfo::PlayerUid' has a wrong offset!");
static_assert(offsetof(FSBZLobbyCharacterInfo, EOSProdUId) == 0x000028, "Member 'FSBZLobbyCharacterInfo::EOSProdUId' has a wrong offset!");
static_assert(offsetof(FSBZLobbyCharacterInfo, bIsPlayerReady) == 0x000038, "Member 'FSBZLobbyCharacterInfo::bIsPlayerReady' has a wrong offset!");
static_assert(offsetof(FSBZLobbyCharacterInfo, bPlayerAcceptedMatch) == 0x000039, "Member 'FSBZLobbyCharacterInfo::bPlayerAcceptedMatch' has a wrong offset!");
static_assert(offsetof(FSBZLobbyCharacterInfo, LevelIdx) == 0x00003C, "Member 'FSBZLobbyCharacterInfo::LevelIdx' has a wrong offset!");
static_assert(offsetof(FSBZLobbyCharacterInfo, PowerLevel) == 0x000040, "Member 'FSBZLobbyCharacterInfo::PowerLevel' has a wrong offset!");
static_assert(offsetof(FSBZLobbyCharacterInfo, Nickname) == 0x000048, "Member 'FSBZLobbyCharacterInfo::Nickname' has a wrong offset!");

// ScriptStruct Starbreeze.SBZOnlinePartyParamsUi
// 0x0001 (0x0001 - 0x0000)
struct FSBZOnlinePartyParamsUi final
{
public:
	ESBZOnlineJoinType                            PartyType;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZOnlinePartyParamsUi) == 0x000001, "Wrong alignment on FSBZOnlinePartyParamsUi");
static_assert(sizeof(FSBZOnlinePartyParamsUi) == 0x000001, "Wrong size on FSBZOnlinePartyParamsUi");
static_assert(offsetof(FSBZOnlinePartyParamsUi, PartyType) == 0x000000, "Member 'FSBZOnlinePartyParamsUi::PartyType' has a wrong offset!");

// ScriptStruct Starbreeze.MigratableHost
// 0x0040 (0x0040 - 0x0000)
struct FMigratableHost final
{
public:
	struct FUniqueNetIdRepl                       PlayerUniqueId;                                    // 0x0000(0x0028)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HostAddress;                                       // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMigratableHost) == 0x000008, "Wrong alignment on FMigratableHost");
static_assert(sizeof(FMigratableHost) == 0x000040, "Wrong size on FMigratableHost");
static_assert(offsetof(FMigratableHost, PlayerUniqueId) == 0x000000, "Member 'FMigratableHost::PlayerUniqueId' has a wrong offset!");
static_assert(offsetof(FMigratableHost, HostAddress) == 0x000028, "Member 'FMigratableHost::HostAddress' has a wrong offset!");

// ScriptStruct Starbreeze.HostMigrationInfo
// 0x0018 (0x0018 - 0x0000)
struct FHostMigrationInfo final
{
public:
	TArray<struct FMigratableHost>                MigratableHosts;                                   // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         MissionSeed;                                       // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHostMigrationInfo) == 0x000008, "Wrong alignment on FHostMigrationInfo");
static_assert(sizeof(FHostMigrationInfo) == 0x000018, "Wrong size on FHostMigrationInfo");
static_assert(offsetof(FHostMigrationInfo, MigratableHosts) == 0x000000, "Member 'FHostMigrationInfo::MigratableHosts' has a wrong offset!");
static_assert(offsetof(FHostMigrationInfo, MissionSeed) == 0x000010, "Member 'FHostMigrationInfo::MissionSeed' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPartyMemberInfo
// 0x0038 (0x0038 - 0x0000)
struct FSBZPartyMemberInfo final
{
public:
	struct FUniqueNetIdRepl                       PlayerUId;                                         // 0x0000(0x0028)(BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Nickname;                                          // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPartyMemberInfo) == 0x000008, "Wrong alignment on FSBZPartyMemberInfo");
static_assert(sizeof(FSBZPartyMemberInfo) == 0x000038, "Wrong size on FSBZPartyMemberInfo");
static_assert(offsetof(FSBZPartyMemberInfo, PlayerUId) == 0x000000, "Member 'FSBZPartyMemberInfo::PlayerUId' has a wrong offset!");
static_assert(offsetof(FSBZPartyMemberInfo, Nickname) == 0x000028, "Member 'FSBZPartyMemberInfo::Nickname' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPartyData
// 0x0050 (0x0050 - 0x0000)
struct FSBZPartyData final
{
public:
	int32                                         OwnerId;                                           // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OwnerIndex;                                        // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSBZPartyMemberInfo>            Members;                                           // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	ESBZOnlineSessionPhase                        HostState;                                         // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsQuickPlay;                                      // 0x0019(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MissionSchematicIdx;                               // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MissionDifficultyIdx;                              // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x2C];                                      // 0x0024(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZPartyData) == 0x000008, "Wrong alignment on FSBZPartyData");
static_assert(sizeof(FSBZPartyData) == 0x000050, "Wrong size on FSBZPartyData");
static_assert(offsetof(FSBZPartyData, OwnerId) == 0x000000, "Member 'FSBZPartyData::OwnerId' has a wrong offset!");
static_assert(offsetof(FSBZPartyData, OwnerIndex) == 0x000004, "Member 'FSBZPartyData::OwnerIndex' has a wrong offset!");
static_assert(offsetof(FSBZPartyData, Members) == 0x000008, "Member 'FSBZPartyData::Members' has a wrong offset!");
static_assert(offsetof(FSBZPartyData, HostState) == 0x000018, "Member 'FSBZPartyData::HostState' has a wrong offset!");
static_assert(offsetof(FSBZPartyData, bIsQuickPlay) == 0x000019, "Member 'FSBZPartyData::bIsQuickPlay' has a wrong offset!");
static_assert(offsetof(FSBZPartyData, MissionSchematicIdx) == 0x00001C, "Member 'FSBZPartyData::MissionSchematicIdx' has a wrong offset!");
static_assert(offsetof(FSBZPartyData, MissionDifficultyIdx) == 0x000020, "Member 'FSBZPartyData::MissionDifficultyIdx' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSlotData
// 0x02E8 (0x02E8 - 0x0000)
struct FSBZSlotData final
{
public:
	struct FSBZPlayerSlotInfo                     PlayerInfo;                                        // 0x0000(0x0060)(Transient, NativeAccessSpecifierPublic)
	class ASBZPlayerState*                        PlayerState;                                       // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZSlotStatus                                Status;                                            // 0x0068(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Nickname;                                          // 0x0070(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AccelByteUserName;                                 // 0x0080(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AccelByteDisplayName;                              // 0x0090(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMatchAccepted;                                    // 0x00A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreMatchReady;                                    // 0x00A1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJobOverviewReady;                                 // 0x00A2(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHaveGameState;                                    // 0x00A3(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReserved;                                         // 0x00A4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoadingComplete;                                  // 0x00A5(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraveling;                                        // 0x00A6(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVoiceSessionEnabled;                              // 0x00A7(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVoiceSessionInitiator;                            // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x2F];                                      // 0x00A9(0x002F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPD3PlayerLoadout                      ClientLoadout;                                     // 0x00D8(0x01C0)(Transient, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                PreferredCharacters;                               // 0x0298(0x0010)(ZeroConstructor, Transient, RepSkip, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                InventoryCharacters;                               // 0x02A8(0x0010)(ZeroConstructor, Transient, RepSkip, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SelectedCharacter;                                 // 0x02B8(0x0020)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasLoadoutData;                                   // 0x02D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStayAsParty;                                      // 0x02D9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZFirstPartyPlatform                        FirstPartyPlatform;                                // 0x02DA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZPlatform                                  Platform;                                          // 0x02DB(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InfamyLevel;                                       // 0x02DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RenownLevel;                                       // 0x02E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCrossPlayEnabled;                                 // 0x02E4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E5[0x3];                                      // 0x02E5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZSlotData) == 0x000008, "Wrong alignment on FSBZSlotData");
static_assert(sizeof(FSBZSlotData) == 0x0002E8, "Wrong size on FSBZSlotData");
static_assert(offsetof(FSBZSlotData, PlayerInfo) == 0x000000, "Member 'FSBZSlotData::PlayerInfo' has a wrong offset!");
static_assert(offsetof(FSBZSlotData, PlayerState) == 0x000060, "Member 'FSBZSlotData::PlayerState' has a wrong offset!");
static_assert(offsetof(FSBZSlotData, Status) == 0x000068, "Member 'FSBZSlotData::Status' has a wrong offset!");
static_assert(offsetof(FSBZSlotData, Nickname) == 0x000070, "Member 'FSBZSlotData::Nickname' has a wrong offset!");
static_assert(offsetof(FSBZSlotData, AccelByteUserName) == 0x000080, "Member 'FSBZSlotData::AccelByteUserName' has a wrong offset!");
static_assert(offsetof(FSBZSlotData, AccelByteDisplayName) == 0x000090, "Member 'FSBZSlotData::AccelByteDisplayName' has a wrong offset!");
static_assert(offsetof(FSBZSlotData, bMatchAccepted) == 0x0000A0, "Member 'FSBZSlotData::bMatchAccepted' has a wrong offset!");
static_assert(offsetof(FSBZSlotData, bPreMatchReady) == 0x0000A1, "Member 'FSBZSlotData::bPreMatchReady' has a wrong offset!");
static_assert(offsetof(FSBZSlotData, bJobOverviewReady) == 0x0000A2, "Member 'FSBZSlotData::bJobOverviewReady' has a wrong offset!");
static_assert(offsetof(FSBZSlotData, bHaveGameState) == 0x0000A3, "Member 'FSBZSlotData::bHaveGameState' has a wrong offset!");
static_assert(offsetof(FSBZSlotData, bReserved) == 0x0000A4, "Member 'FSBZSlotData::bReserved' has a wrong offset!");
static_assert(offsetof(FSBZSlotData, bLoadingComplete) == 0x0000A5, "Member 'FSBZSlotData::bLoadingComplete' has a wrong offset!");
static_assert(offsetof(FSBZSlotData, bTraveling) == 0x0000A6, "Member 'FSBZSlotData::bTraveling' has a wrong offset!");
static_assert(offsetof(FSBZSlotData, bVoiceSessionEnabled) == 0x0000A7, "Member 'FSBZSlotData::bVoiceSessionEnabled' has a wrong offset!");
static_assert(offsetof(FSBZSlotData, bVoiceSessionInitiator) == 0x0000A8, "Member 'FSBZSlotData::bVoiceSessionInitiator' has a wrong offset!");
static_assert(offsetof(FSBZSlotData, ClientLoadout) == 0x0000D8, "Member 'FSBZSlotData::ClientLoadout' has a wrong offset!");
static_assert(offsetof(FSBZSlotData, PreferredCharacters) == 0x000298, "Member 'FSBZSlotData::PreferredCharacters' has a wrong offset!");
static_assert(offsetof(FSBZSlotData, InventoryCharacters) == 0x0002A8, "Member 'FSBZSlotData::InventoryCharacters' has a wrong offset!");
static_assert(offsetof(FSBZSlotData, SelectedCharacter) == 0x0002B8, "Member 'FSBZSlotData::SelectedCharacter' has a wrong offset!");
static_assert(offsetof(FSBZSlotData, bHasLoadoutData) == 0x0002D8, "Member 'FSBZSlotData::bHasLoadoutData' has a wrong offset!");
static_assert(offsetof(FSBZSlotData, bStayAsParty) == 0x0002D9, "Member 'FSBZSlotData::bStayAsParty' has a wrong offset!");
static_assert(offsetof(FSBZSlotData, FirstPartyPlatform) == 0x0002DA, "Member 'FSBZSlotData::FirstPartyPlatform' has a wrong offset!");
static_assert(offsetof(FSBZSlotData, Platform) == 0x0002DB, "Member 'FSBZSlotData::Platform' has a wrong offset!");
static_assert(offsetof(FSBZSlotData, InfamyLevel) == 0x0002DC, "Member 'FSBZSlotData::InfamyLevel' has a wrong offset!");
static_assert(offsetof(FSBZSlotData, RenownLevel) == 0x0002E0, "Member 'FSBZSlotData::RenownLevel' has a wrong offset!");
static_assert(offsetof(FSBZSlotData, bCrossPlayEnabled) == 0x0002E4, "Member 'FSBZSlotData::bCrossPlayEnabled' has a wrong offset!");

// ScriptStruct Starbreeze.SBZVoiceSessionData
// 0x0068 (0x0068 - 0x0000)
struct FSBZVoiceSessionData final
{
public:
	class FString                                 Id;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZVoiceSessionDomain                        Domain;                                            // 0x0010(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUniqueNetIdRepl                       CreatorId;                                         // 0x0018(0x0028)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETLMVoiceSessionState                         State;                                             // 0x0040(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUniqueNetIdRepl>               Players;                                           // 0x0048(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FUniqueNetIdRepl>               PlayersFailedToCreate;                             // 0x0058(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZVoiceSessionData) == 0x000008, "Wrong alignment on FSBZVoiceSessionData");
static_assert(sizeof(FSBZVoiceSessionData) == 0x000068, "Wrong size on FSBZVoiceSessionData");
static_assert(offsetof(FSBZVoiceSessionData, Id) == 0x000000, "Member 'FSBZVoiceSessionData::Id' has a wrong offset!");
static_assert(offsetof(FSBZVoiceSessionData, Domain) == 0x000010, "Member 'FSBZVoiceSessionData::Domain' has a wrong offset!");
static_assert(offsetof(FSBZVoiceSessionData, CreatorId) == 0x000018, "Member 'FSBZVoiceSessionData::CreatorId' has a wrong offset!");
static_assert(offsetof(FSBZVoiceSessionData, State) == 0x000040, "Member 'FSBZVoiceSessionData::State' has a wrong offset!");
static_assert(offsetof(FSBZVoiceSessionData, Players) == 0x000048, "Member 'FSBZVoiceSessionData::Players' has a wrong offset!");
static_assert(offsetof(FSBZVoiceSessionData, PlayersFailedToCreate) == 0x000058, "Member 'FSBZVoiceSessionData::PlayersFailedToCreate' has a wrong offset!");

// ScriptStruct Starbreeze.SBZOverskillProgressResultData
// 0x0010 (0x0010 - 0x0000)
struct FSBZOverskillProgressResultData final
{
public:
	class USBZOverskillData*                      Data;                                              // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Level;                                             // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZOverskillProgressResultData) == 0x000008, "Wrong alignment on FSBZOverskillProgressResultData");
static_assert(sizeof(FSBZOverskillProgressResultData) == 0x000010, "Wrong size on FSBZOverskillProgressResultData");
static_assert(offsetof(FSBZOverskillProgressResultData, Data) == 0x000000, "Member 'FSBZOverskillProgressResultData::Data' has a wrong offset!");
static_assert(offsetof(FSBZOverskillProgressResultData, Level) == 0x000008, "Member 'FSBZOverskillProgressResultData::Level' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPartyInvitation
// 0x0058 (0x0058 - 0x0000)
struct FSBZPartyInvitation final
{
public:
	class FString                                 InvitationId;                                      // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PartyId;                                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerId;                                          // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           InviteExpirationTimer;                             // 0x0030(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZPartyInvitationType                       Type;                                              // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZPartyInvitationSystem                     System;                                            // 0x0039(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x17];                                      // 0x003A(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	ESBZPartyInviteStatus                         Status;                                            // 0x0051(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZPartyInvitation) == 0x000008, "Wrong alignment on FSBZPartyInvitation");
static_assert(sizeof(FSBZPartyInvitation) == 0x000058, "Wrong size on FSBZPartyInvitation");
static_assert(offsetof(FSBZPartyInvitation, InvitationId) == 0x000000, "Member 'FSBZPartyInvitation::InvitationId' has a wrong offset!");
static_assert(offsetof(FSBZPartyInvitation, PartyId) == 0x000010, "Member 'FSBZPartyInvitation::PartyId' has a wrong offset!");
static_assert(offsetof(FSBZPartyInvitation, PlayerId) == 0x000020, "Member 'FSBZPartyInvitation::PlayerId' has a wrong offset!");
static_assert(offsetof(FSBZPartyInvitation, InviteExpirationTimer) == 0x000030, "Member 'FSBZPartyInvitation::InviteExpirationTimer' has a wrong offset!");
static_assert(offsetof(FSBZPartyInvitation, Type) == 0x000038, "Member 'FSBZPartyInvitation::Type' has a wrong offset!");
static_assert(offsetof(FSBZPartyInvitation, System) == 0x000039, "Member 'FSBZPartyInvitation::System' has a wrong offset!");
static_assert(offsetof(FSBZPartyInvitation, Status) == 0x000051, "Member 'FSBZPartyInvitation::Status' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPartyMessageAB
// 0x0020 (0x0020 - 0x0000)
struct FSBZPartyMessageAB final
{
public:
	class FString                                 Topic;                                             // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Payload;                                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPartyMessageAB) == 0x000008, "Wrong alignment on FSBZPartyMessageAB");
static_assert(sizeof(FSBZPartyMessageAB) == 0x000020, "Wrong size on FSBZPartyMessageAB");
static_assert(offsetof(FSBZPartyMessageAB, Topic) == 0x000000, "Member 'FSBZPartyMessageAB::Topic' has a wrong offset!");
static_assert(offsetof(FSBZPartyMessageAB, Payload) == 0x000010, "Member 'FSBZPartyMessageAB::Payload' has a wrong offset!");

// ScriptStruct Starbreeze.SBZQueuedNativePartyInvite
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FSBZQueuedNativePartyInvite final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZQueuedNativePartyInvite) == 0x000008, "Wrong alignment on FSBZQueuedNativePartyInvite");
static_assert(sizeof(FSBZQueuedNativePartyInvite) == 0x000020, "Wrong size on FSBZQueuedNativePartyInvite");

// ScriptStruct Starbreeze.SBZPatrolNext
// 0x0008 (0x0008 - 0x0000)
struct FSBZPatrolNext final
{
public:
	class ASBZPatrolPoint*                        Point;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPatrolNext) == 0x000008, "Wrong alignment on FSBZPatrolNext");
static_assert(sizeof(FSBZPatrolNext) == 0x000008, "Wrong size on FSBZPatrolNext");
static_assert(offsetof(FSBZPatrolNext, Point) == 0x000000, "Member 'FSBZPatrolNext::Point' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSpawnRotationHandlingMethod
// 0x000C (0x000C - 0x0000)
struct FSBZSpawnRotationHandlingMethod final
{
public:
	float                                         MaximumAngleVariation;                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZSpawnRotationMethod                       Method;                                            // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeadingAngle;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSpawnRotationHandlingMethod) == 0x000004, "Wrong alignment on FSBZSpawnRotationHandlingMethod");
static_assert(sizeof(FSBZSpawnRotationHandlingMethod) == 0x00000C, "Wrong size on FSBZSpawnRotationHandlingMethod");
static_assert(offsetof(FSBZSpawnRotationHandlingMethod, MaximumAngleVariation) == 0x000000, "Member 'FSBZSpawnRotationHandlingMethod::MaximumAngleVariation' has a wrong offset!");
static_assert(offsetof(FSBZSpawnRotationHandlingMethod, Method) == 0x000004, "Member 'FSBZSpawnRotationHandlingMethod::Method' has a wrong offset!");
static_assert(offsetof(FSBZSpawnRotationHandlingMethod, HeadingAngle) == 0x000008, "Member 'FSBZSpawnRotationHandlingMethod::HeadingAngle' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPawnVariationData
// 0x0050 (0x0050 - 0x0000)
struct FSBZPawnVariationData final
{
public:
	TSubclassOf<class APawn>                      PawnClass;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideEquipmentData;                            // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USBZAIEquipmentData*                    EquipmentData;                                     // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideInitialEquippableIndex;                   // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InitialEquippableIndex;                            // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideVariationData;                            // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USBZVariationSetData*                   VariationData;                                     // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideVariationDataIntervals;                   // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInt32Interval                         VariationCategoryIndexIntervals[0x3];              // 0x0034(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZPawnVariationData) == 0x000008, "Wrong alignment on FSBZPawnVariationData");
static_assert(sizeof(FSBZPawnVariationData) == 0x000050, "Wrong size on FSBZPawnVariationData");
static_assert(offsetof(FSBZPawnVariationData, PawnClass) == 0x000000, "Member 'FSBZPawnVariationData::PawnClass' has a wrong offset!");
static_assert(offsetof(FSBZPawnVariationData, bOverrideEquipmentData) == 0x000008, "Member 'FSBZPawnVariationData::bOverrideEquipmentData' has a wrong offset!");
static_assert(offsetof(FSBZPawnVariationData, EquipmentData) == 0x000010, "Member 'FSBZPawnVariationData::EquipmentData' has a wrong offset!");
static_assert(offsetof(FSBZPawnVariationData, bOverrideInitialEquippableIndex) == 0x000018, "Member 'FSBZPawnVariationData::bOverrideInitialEquippableIndex' has a wrong offset!");
static_assert(offsetof(FSBZPawnVariationData, InitialEquippableIndex) == 0x00001C, "Member 'FSBZPawnVariationData::InitialEquippableIndex' has a wrong offset!");
static_assert(offsetof(FSBZPawnVariationData, bOverrideVariationData) == 0x000020, "Member 'FSBZPawnVariationData::bOverrideVariationData' has a wrong offset!");
static_assert(offsetof(FSBZPawnVariationData, VariationData) == 0x000028, "Member 'FSBZPawnVariationData::VariationData' has a wrong offset!");
static_assert(offsetof(FSBZPawnVariationData, bOverrideVariationDataIntervals) == 0x000030, "Member 'FSBZPawnVariationData::bOverrideVariationDataIntervals' has a wrong offset!");
static_assert(offsetof(FSBZPawnVariationData, VariationCategoryIndexIntervals) == 0x000034, "Member 'FSBZPawnVariationData::VariationCategoryIndexIntervals' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPawnPlatformSpawnSettings
// 0x0010 (0x0010 - 0x0000)
struct FSBZPawnPlatformSpawnSettings final
{
public:
	ESBZSpawnSignificance                         AllowedSpawnSignificance;                          // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PopulationLimit;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumSpawnsPerFrame;                             // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumDestroysPerFrame;                           // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPawnPlatformSpawnSettings) == 0x000004, "Wrong alignment on FSBZPawnPlatformSpawnSettings");
static_assert(sizeof(FSBZPawnPlatformSpawnSettings) == 0x000010, "Wrong size on FSBZPawnPlatformSpawnSettings");
static_assert(offsetof(FSBZPawnPlatformSpawnSettings, AllowedSpawnSignificance) == 0x000000, "Member 'FSBZPawnPlatformSpawnSettings::AllowedSpawnSignificance' has a wrong offset!");
static_assert(offsetof(FSBZPawnPlatformSpawnSettings, PopulationLimit) == 0x000004, "Member 'FSBZPawnPlatformSpawnSettings::PopulationLimit' has a wrong offset!");
static_assert(offsetof(FSBZPawnPlatformSpawnSettings, MaximumSpawnsPerFrame) == 0x000008, "Member 'FSBZPawnPlatformSpawnSettings::MaximumSpawnsPerFrame' has a wrong offset!");
static_assert(offsetof(FSBZPawnPlatformSpawnSettings, MaximumDestroysPerFrame) == 0x00000C, "Member 'FSBZPawnPlatformSpawnSettings::MaximumDestroysPerFrame' has a wrong offset!");

// ScriptStruct Starbreeze.SBZNavLinkWaitSlot
// 0x0018 (0x0018 - 0x0000)
struct FSBZNavLinkWaitSlot final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ASBZAIBaseCharacter>     Occupant;                                          // 0x000C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZNavLinkWaitSlot) == 0x000004, "Wrong alignment on FSBZNavLinkWaitSlot");
static_assert(sizeof(FSBZNavLinkWaitSlot) == 0x000018, "Wrong size on FSBZNavLinkWaitSlot");
static_assert(offsetof(FSBZNavLinkWaitSlot, Location) == 0x000000, "Member 'FSBZNavLinkWaitSlot::Location' has a wrong offset!");
static_assert(offsetof(FSBZNavLinkWaitSlot, Occupant) == 0x00000C, "Member 'FSBZNavLinkWaitSlot::Occupant' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMeshZones
// 0x0040 (0x0040 - 0x0000)
struct FSBZMeshZones final
{
public:
	TSoftObjectPtr<class UMeshComponent>          Mesh;                                              // 0x0000(0x0030)(ExportObject, InstancedReference, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class USBZPersistentWorldDamageZoneComponent>> Zones;                      // 0x0030(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZMeshZones) == 0x000008, "Wrong alignment on FSBZMeshZones");
static_assert(sizeof(FSBZMeshZones) == 0x000040, "Wrong size on FSBZMeshZones");
static_assert(offsetof(FSBZMeshZones, Mesh) == 0x000000, "Member 'FSBZMeshZones::Mesh' has a wrong offset!");
static_assert(offsetof(FSBZMeshZones, Zones) == 0x000030, "Member 'FSBZMeshZones::Zones' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPhoneHackingTargetData
// 0x0008 (0x0010 - 0x0008)
struct FSBZPhoneHackingTargetData final : public FGameplayAbilityTargetData
{
public:
	class AActor*                                 HackableActor;                                     // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FSBZPhoneHackingTargetData) == 0x000008, "Wrong alignment on FSBZPhoneHackingTargetData");
static_assert(sizeof(FSBZPhoneHackingTargetData) == 0x000010, "Wrong size on FSBZPhoneHackingTargetData");
static_assert(offsetof(FSBZPhoneHackingTargetData, HackableActor) == 0x000008, "Member 'FSBZPhoneHackingTargetData::HackableActor' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPlaceableToolActivationTargetData
// 0x0000 (0x0008 - 0x0008)
struct FSBZPlaceableToolActivationTargetData final : public FGameplayAbilityTargetData
{
};
static_assert(alignof(FSBZPlaceableToolActivationTargetData) == 0x000008, "Wrong alignment on FSBZPlaceableToolActivationTargetData");
static_assert(sizeof(FSBZPlaceableToolActivationTargetData) == 0x000008, "Wrong size on FSBZPlaceableToolActivationTargetData");

// ScriptStruct Starbreeze.SBZRespawnMinimumAttributeData
// 0x001C (0x001C - 0x0000)
struct FSBZRespawnMinimumAttributeData final
{
public:
	bool                                          bForceValues;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Health;                                            // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PercentOfMaxChunkCount;                            // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DownedCount;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponAmmoScale;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrowableAmmoScale;                                // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlaceableAmmoScale;                                // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZRespawnMinimumAttributeData) == 0x000004, "Wrong alignment on FSBZRespawnMinimumAttributeData");
static_assert(sizeof(FSBZRespawnMinimumAttributeData) == 0x00001C, "Wrong size on FSBZRespawnMinimumAttributeData");
static_assert(offsetof(FSBZRespawnMinimumAttributeData, bForceValues) == 0x000000, "Member 'FSBZRespawnMinimumAttributeData::bForceValues' has a wrong offset!");
static_assert(offsetof(FSBZRespawnMinimumAttributeData, Health) == 0x000004, "Member 'FSBZRespawnMinimumAttributeData::Health' has a wrong offset!");
static_assert(offsetof(FSBZRespawnMinimumAttributeData, PercentOfMaxChunkCount) == 0x000008, "Member 'FSBZRespawnMinimumAttributeData::PercentOfMaxChunkCount' has a wrong offset!");
static_assert(offsetof(FSBZRespawnMinimumAttributeData, DownedCount) == 0x00000C, "Member 'FSBZRespawnMinimumAttributeData::DownedCount' has a wrong offset!");
static_assert(offsetof(FSBZRespawnMinimumAttributeData, WeaponAmmoScale) == 0x000010, "Member 'FSBZRespawnMinimumAttributeData::WeaponAmmoScale' has a wrong offset!");
static_assert(offsetof(FSBZRespawnMinimumAttributeData, ThrowableAmmoScale) == 0x000014, "Member 'FSBZRespawnMinimumAttributeData::ThrowableAmmoScale' has a wrong offset!");
static_assert(offsetof(FSBZRespawnMinimumAttributeData, PlaceableAmmoScale) == 0x000018, "Member 'FSBZRespawnMinimumAttributeData::PlaceableAmmoScale' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAttributeGUIEffectData
// 0x0010 (0x0010 - 0x0000)
struct FSBZAttributeGUIEffectData final
{
public:
	class USBZCharacterEffectDataAsset*           Asset;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPercentage;                                     // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Default;                                           // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAttributeGUIEffectData) == 0x000008, "Wrong alignment on FSBZAttributeGUIEffectData");
static_assert(sizeof(FSBZAttributeGUIEffectData) == 0x000010, "Wrong size on FSBZAttributeGUIEffectData");
static_assert(offsetof(FSBZAttributeGUIEffectData, Asset) == 0x000000, "Member 'FSBZAttributeGUIEffectData::Asset' has a wrong offset!");
static_assert(offsetof(FSBZAttributeGUIEffectData, bIsPercentage) == 0x000008, "Member 'FSBZAttributeGUIEffectData::bIsPercentage' has a wrong offset!");
static_assert(offsetof(FSBZAttributeGUIEffectData, Default) == 0x00000C, "Member 'FSBZAttributeGUIEffectData::Default' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMontageContainer
// 0x0018 (0x0018 - 0x0000)
struct FSBZMontageContainer final
{
public:
	bool                                          bOverride;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAnimMontage*>                   Montages;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZMontageContainer) == 0x000008, "Wrong alignment on FSBZMontageContainer");
static_assert(sizeof(FSBZMontageContainer) == 0x000018, "Wrong size on FSBZMontageContainer");
static_assert(offsetof(FSBZMontageContainer, bOverride) == 0x000000, "Member 'FSBZMontageContainer::bOverride' has a wrong offset!");
static_assert(offsetof(FSBZMontageContainer, Montages) == 0x000008, "Member 'FSBZMontageContainer::Montages' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWallReactionData
// 0x0040 (0x0040 - 0x0000)
struct FSBZWallReactionData final
{
public:
	float                                         Alpha;                                             // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MaxOffset;                                         // 0x0004(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DetectionDistance;                                 // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitLocation;                                       // 0x0014(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitImpactPoint;                                    // 0x0020(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitDistance;                                       // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceDist;                                         // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpolationSpeed;                                // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpolationSpringFactor;                         // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastUpdateTime;                                    // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWallReactionData) == 0x000004, "Wrong alignment on FSBZWallReactionData");
static_assert(sizeof(FSBZWallReactionData) == 0x000040, "Wrong size on FSBZWallReactionData");
static_assert(offsetof(FSBZWallReactionData, Alpha) == 0x000000, "Member 'FSBZWallReactionData::Alpha' has a wrong offset!");
static_assert(offsetof(FSBZWallReactionData, MaxOffset) == 0x000004, "Member 'FSBZWallReactionData::MaxOffset' has a wrong offset!");
static_assert(offsetof(FSBZWallReactionData, DetectionDistance) == 0x000010, "Member 'FSBZWallReactionData::DetectionDistance' has a wrong offset!");
static_assert(offsetof(FSBZWallReactionData, HitLocation) == 0x000014, "Member 'FSBZWallReactionData::HitLocation' has a wrong offset!");
static_assert(offsetof(FSBZWallReactionData, HitImpactPoint) == 0x000020, "Member 'FSBZWallReactionData::HitImpactPoint' has a wrong offset!");
static_assert(offsetof(FSBZWallReactionData, HitDistance) == 0x00002C, "Member 'FSBZWallReactionData::HitDistance' has a wrong offset!");
static_assert(offsetof(FSBZWallReactionData, TraceDist) == 0x000030, "Member 'FSBZWallReactionData::TraceDist' has a wrong offset!");
static_assert(offsetof(FSBZWallReactionData, InterpolationSpeed) == 0x000034, "Member 'FSBZWallReactionData::InterpolationSpeed' has a wrong offset!");
static_assert(offsetof(FSBZWallReactionData, InterpolationSpringFactor) == 0x000038, "Member 'FSBZWallReactionData::InterpolationSpringFactor' has a wrong offset!");
static_assert(offsetof(FSBZWallReactionData, LastUpdateTime) == 0x00003C, "Member 'FSBZWallReactionData::LastUpdateTime' has a wrong offset!");

// ScriptStruct Starbreeze.SBZTankingData
// 0x0024 (0x0024 - 0x0000)
struct FSBZTankingData final
{
public:
	float                                         TankingAmount;                                     // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TankingAlpha;                                      // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TankingMinYawAngle;                                // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TankingMaxYawAngle;                                // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TankingMinRollAngle;                               // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TankingMaxRollAngle;                               // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TankingYawMultiplier;                              // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TankingRollMultiplier;                             // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TankingSensitivity;                                // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZTankingData) == 0x000004, "Wrong alignment on FSBZTankingData");
static_assert(sizeof(FSBZTankingData) == 0x000024, "Wrong size on FSBZTankingData");
static_assert(offsetof(FSBZTankingData, TankingAmount) == 0x000000, "Member 'FSBZTankingData::TankingAmount' has a wrong offset!");
static_assert(offsetof(FSBZTankingData, TankingAlpha) == 0x000004, "Member 'FSBZTankingData::TankingAlpha' has a wrong offset!");
static_assert(offsetof(FSBZTankingData, TankingMinYawAngle) == 0x000008, "Member 'FSBZTankingData::TankingMinYawAngle' has a wrong offset!");
static_assert(offsetof(FSBZTankingData, TankingMaxYawAngle) == 0x00000C, "Member 'FSBZTankingData::TankingMaxYawAngle' has a wrong offset!");
static_assert(offsetof(FSBZTankingData, TankingMinRollAngle) == 0x000010, "Member 'FSBZTankingData::TankingMinRollAngle' has a wrong offset!");
static_assert(offsetof(FSBZTankingData, TankingMaxRollAngle) == 0x000014, "Member 'FSBZTankingData::TankingMaxRollAngle' has a wrong offset!");
static_assert(offsetof(FSBZTankingData, TankingYawMultiplier) == 0x000018, "Member 'FSBZTankingData::TankingYawMultiplier' has a wrong offset!");
static_assert(offsetof(FSBZTankingData, TankingRollMultiplier) == 0x00001C, "Member 'FSBZTankingData::TankingRollMultiplier' has a wrong offset!");
static_assert(offsetof(FSBZTankingData, TankingSensitivity) == 0x000020, "Member 'FSBZTankingData::TankingSensitivity' has a wrong offset!");

// ScriptStruct Starbreeze.SBZLocalPlayerFeedbackParameters
// 0x0050 (0x0050 - 0x0000)
struct FSBZLocalPlayerFeedbackParameters final
{
public:
	TSubclassOf<class USBZLocalPlayerFeedback>    FeedbackClass;                                     // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Intensity;                                         // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAutoRemoved;                                    // 0x000C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCameraAsOrigin;                                   // 0x000D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Origin;                                            // 0x0010(0x0030)(BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SustainTime;                                       // 0x0040(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0xC];                                       // 0x0044(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZLocalPlayerFeedbackParameters) == 0x000010, "Wrong alignment on FSBZLocalPlayerFeedbackParameters");
static_assert(sizeof(FSBZLocalPlayerFeedbackParameters) == 0x000050, "Wrong size on FSBZLocalPlayerFeedbackParameters");
static_assert(offsetof(FSBZLocalPlayerFeedbackParameters, FeedbackClass) == 0x000000, "Member 'FSBZLocalPlayerFeedbackParameters::FeedbackClass' has a wrong offset!");
static_assert(offsetof(FSBZLocalPlayerFeedbackParameters, Intensity) == 0x000008, "Member 'FSBZLocalPlayerFeedbackParameters::Intensity' has a wrong offset!");
static_assert(offsetof(FSBZLocalPlayerFeedbackParameters, bIsAutoRemoved) == 0x00000C, "Member 'FSBZLocalPlayerFeedbackParameters::bIsAutoRemoved' has a wrong offset!");
static_assert(offsetof(FSBZLocalPlayerFeedbackParameters, bCameraAsOrigin) == 0x00000D, "Member 'FSBZLocalPlayerFeedbackParameters::bCameraAsOrigin' has a wrong offset!");
static_assert(offsetof(FSBZLocalPlayerFeedbackParameters, Origin) == 0x000010, "Member 'FSBZLocalPlayerFeedbackParameters::Origin' has a wrong offset!");
static_assert(offsetof(FSBZLocalPlayerFeedbackParameters, SustainTime) == 0x000040, "Member 'FSBZLocalPlayerFeedbackParameters::SustainTime' has a wrong offset!");

// ScriptStruct Starbreeze.SBZEventReactionData
// 0x0010 (0x0010 - 0x0000)
struct FSBZEventReactionData final
{
public:
	class UAkAudioEvent*                          EventToPlay;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EventCooldown;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastPlayedTime;                                    // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZEventReactionData) == 0x000008, "Wrong alignment on FSBZEventReactionData");
static_assert(sizeof(FSBZEventReactionData) == 0x000010, "Wrong size on FSBZEventReactionData");
static_assert(offsetof(FSBZEventReactionData, EventToPlay) == 0x000000, "Member 'FSBZEventReactionData::EventToPlay' has a wrong offset!");
static_assert(offsetof(FSBZEventReactionData, EventCooldown) == 0x000008, "Member 'FSBZEventReactionData::EventCooldown' has a wrong offset!");
static_assert(offsetof(FSBZEventReactionData, LastPlayedTime) == 0x00000C, "Member 'FSBZEventReactionData::LastPlayedTime' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInteractModeDisplayData
// 0x0020 (0x0020 - 0x0000)
struct FSBZInteractModeDisplayData final
{
public:
	bool                                          bIsInstant;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFailed;                                         // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAllowed;                                        // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsIllegal;                                        // 0x0003(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Text;                                              // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZInteractModeDisplayData) == 0x000008, "Wrong alignment on FSBZInteractModeDisplayData");
static_assert(sizeof(FSBZInteractModeDisplayData) == 0x000020, "Wrong size on FSBZInteractModeDisplayData");
static_assert(offsetof(FSBZInteractModeDisplayData, bIsInstant) == 0x000000, "Member 'FSBZInteractModeDisplayData::bIsInstant' has a wrong offset!");
static_assert(offsetof(FSBZInteractModeDisplayData, bIsFailed) == 0x000001, "Member 'FSBZInteractModeDisplayData::bIsFailed' has a wrong offset!");
static_assert(offsetof(FSBZInteractModeDisplayData, bIsAllowed) == 0x000002, "Member 'FSBZInteractModeDisplayData::bIsAllowed' has a wrong offset!");
static_assert(offsetof(FSBZInteractModeDisplayData, bIsIllegal) == 0x000003, "Member 'FSBZInteractModeDisplayData::bIsIllegal' has a wrong offset!");
static_assert(offsetof(FSBZInteractModeDisplayData, Text) == 0x000008, "Member 'FSBZInteractModeDisplayData::Text' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInteractDisplayData
// 0x0030 (0x0030 - 0x0000)
struct FSBZInteractDisplayData final
{
public:
	bool                                          bCanInteract;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSBZInteractModeDisplayData>    ModeArray;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	class USBZBaseInteractableComponent*          Component;                                         // 0x0018(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Prio;                                              // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FailPrio;                                          // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZInteractDisplayData) == 0x000008, "Wrong alignment on FSBZInteractDisplayData");
static_assert(sizeof(FSBZInteractDisplayData) == 0x000030, "Wrong size on FSBZInteractDisplayData");
static_assert(offsetof(FSBZInteractDisplayData, bCanInteract) == 0x000000, "Member 'FSBZInteractDisplayData::bCanInteract' has a wrong offset!");
static_assert(offsetof(FSBZInteractDisplayData, ModeArray) == 0x000008, "Member 'FSBZInteractDisplayData::ModeArray' has a wrong offset!");
static_assert(offsetof(FSBZInteractDisplayData, Component) == 0x000018, "Member 'FSBZInteractDisplayData::Component' has a wrong offset!");
static_assert(offsetof(FSBZInteractDisplayData, Prio) == 0x000020, "Member 'FSBZInteractDisplayData::Prio' has a wrong offset!");
static_assert(offsetof(FSBZInteractDisplayData, FailPrio) == 0x000024, "Member 'FSBZInteractDisplayData::FailPrio' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInteractDisplayDataCollection
// 0x0060 (0x0060 - 0x0000)
struct FSBZInteractDisplayDataCollection final
{
public:
	struct FSBZInteractDisplayData                FrontData;                                         // 0x0000(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FSBZInteractDisplayData                SelfData;                                          // 0x0030(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZInteractDisplayDataCollection) == 0x000008, "Wrong alignment on FSBZInteractDisplayDataCollection");
static_assert(sizeof(FSBZInteractDisplayDataCollection) == 0x000060, "Wrong size on FSBZInteractDisplayDataCollection");
static_assert(offsetof(FSBZInteractDisplayDataCollection, FrontData) == 0x000000, "Member 'FSBZInteractDisplayDataCollection::FrontData' has a wrong offset!");
static_assert(offsetof(FSBZInteractDisplayDataCollection, SelfData) == 0x000030, "Member 'FSBZInteractDisplayDataCollection::SelfData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPlayerCharacterInventoryItem
// 0x0008 (0x0020 - 0x0018)
struct FSBZPlayerCharacterInventoryItem final : public FSBZInventoryItem
{
public:
	class USBZPlayerCharacterData*                PlayerCharacterData;                               // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPlayerCharacterInventoryItem) == 0x000008, "Wrong alignment on FSBZPlayerCharacterInventoryItem");
static_assert(sizeof(FSBZPlayerCharacterInventoryItem) == 0x000020, "Wrong size on FSBZPlayerCharacterInventoryItem");
static_assert(offsetof(FSBZPlayerCharacterInventoryItem, PlayerCharacterData) == 0x000018, "Member 'FSBZPlayerCharacterInventoryItem::PlayerCharacterData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZGloveInventoryItem
// 0x0008 (0x0020 - 0x0018)
struct FSBZGloveInventoryItem final : public FSBZInventoryItem
{
public:
	class USBZGloveData*                          GloveData;                                         // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZGloveInventoryItem) == 0x000008, "Wrong alignment on FSBZGloveInventoryItem");
static_assert(sizeof(FSBZGloveInventoryItem) == 0x000020, "Wrong size on FSBZGloveInventoryItem");
static_assert(offsetof(FSBZGloveInventoryItem, GloveData) == 0x000018, "Member 'FSBZGloveInventoryItem::GloveData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZThrowableInventoryItem
// 0x0008 (0x0020 - 0x0018)
struct FSBZThrowableInventoryItem final : public FSBZInventoryItem
{
public:
	class USBZThrowableData*                      ThrowableData;                                     // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZThrowableInventoryItem) == 0x000008, "Wrong alignment on FSBZThrowableInventoryItem");
static_assert(sizeof(FSBZThrowableInventoryItem) == 0x000020, "Wrong size on FSBZThrowableInventoryItem");
static_assert(offsetof(FSBZThrowableInventoryItem, ThrowableData) == 0x000018, "Member 'FSBZThrowableInventoryItem::ThrowableData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZArmorInventoryItem
// 0x0008 (0x0020 - 0x0018)
struct FSBZArmorInventoryItem final : public FSBZInventoryItem
{
public:
	class USBZArmorData*                          ArmorData;                                         // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZArmorInventoryItem) == 0x000008, "Wrong alignment on FSBZArmorInventoryItem");
static_assert(sizeof(FSBZArmorInventoryItem) == 0x000020, "Wrong size on FSBZArmorInventoryItem");
static_assert(offsetof(FSBZArmorInventoryItem, ArmorData) == 0x000018, "Member 'FSBZArmorInventoryItem::ArmorData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZToolInventoryItem
// 0x0008 (0x0020 - 0x0018)
struct FSBZToolInventoryItem final : public FSBZInventoryItem
{
public:
	class USBZToolData*                           ToolData;                                          // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZToolInventoryItem) == 0x000008, "Wrong alignment on FSBZToolInventoryItem");
static_assert(sizeof(FSBZToolInventoryItem) == 0x000020, "Wrong size on FSBZToolInventoryItem");
static_assert(offsetof(FSBZToolInventoryItem, ToolData) == 0x000018, "Member 'FSBZToolInventoryItem::ToolData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPlaceableInventoryItem
// 0x0008 (0x0020 - 0x0018)
struct FSBZPlaceableInventoryItem final : public FSBZInventoryItem
{
public:
	class USBZPlaceableData*                      PlaceableData;                                     // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPlaceableInventoryItem) == 0x000008, "Wrong alignment on FSBZPlaceableInventoryItem");
static_assert(sizeof(FSBZPlaceableInventoryItem) == 0x000020, "Wrong size on FSBZPlaceableInventoryItem");
static_assert(offsetof(FSBZPlaceableInventoryItem, PlaceableData) == 0x000018, "Member 'FSBZPlaceableInventoryItem::PlaceableData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZOverskillLoadoutInventoryItem
// 0x0008 (0x0020 - 0x0018)
struct FSBZOverskillLoadoutInventoryItem final : public FSBZInventoryItem
{
public:
	class USBZOverskillLoadoutData*               OverskillLoadoutData;                              // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZOverskillLoadoutInventoryItem) == 0x000008, "Wrong alignment on FSBZOverskillLoadoutInventoryItem");
static_assert(sizeof(FSBZOverskillLoadoutInventoryItem) == 0x000020, "Wrong size on FSBZOverskillLoadoutInventoryItem");
static_assert(offsetof(FSBZOverskillLoadoutInventoryItem, OverskillLoadoutData) == 0x000018, "Member 'FSBZOverskillLoadoutInventoryItem::OverskillLoadoutData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZOverkillWeaponInventoryItem
// 0x0008 (0x0020 - 0x0018)
struct FSBZOverkillWeaponInventoryItem final : public FSBZInventoryItem
{
public:
	class USBZEquippableData*                     OverkillWeaponData;                                // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZOverkillWeaponInventoryItem) == 0x000008, "Wrong alignment on FSBZOverkillWeaponInventoryItem");
static_assert(sizeof(FSBZOverkillWeaponInventoryItem) == 0x000020, "Wrong size on FSBZOverkillWeaponInventoryItem");
static_assert(offsetof(FSBZOverkillWeaponInventoryItem, OverkillWeaponData) == 0x000018, "Member 'FSBZOverkillWeaponInventoryItem::OverkillWeaponData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPreplanningInventoryItem
// 0x0008 (0x0020 - 0x0018)
struct FSBZPreplanningInventoryItem final : public FSBZInventoryItem
{
public:
	class USBZPreplanningAssetData*               PreplanningData;                                   // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPreplanningInventoryItem) == 0x000008, "Wrong alignment on FSBZPreplanningInventoryItem");
static_assert(sizeof(FSBZPreplanningInventoryItem) == 0x000020, "Wrong size on FSBZPreplanningInventoryItem");
static_assert(offsetof(FSBZPreplanningInventoryItem, PreplanningData) == 0x000018, "Member 'FSBZPreplanningInventoryItem::PreplanningData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPlayerLookAtData
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FSBZPlayerLookAtData final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZPlayerLookAtData) == 0x000004, "Wrong alignment on FSBZPlayerLookAtData");
static_assert(sizeof(FSBZPlayerLookAtData) == 0x00000C, "Wrong size on FSBZPlayerLookAtData");

// ScriptStruct Starbreeze.SBZKeyPropertyModeData
// 0x0004 (0x0004 - 0x0000)
struct FSBZKeyPropertyModeData final
{
public:
	float                                         DeadZoneArray;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZKeyPropertyModeData) == 0x000004, "Wrong alignment on FSBZKeyPropertyModeData");
static_assert(sizeof(FSBZKeyPropertyModeData) == 0x000004, "Wrong size on FSBZKeyPropertyModeData");
static_assert(offsetof(FSBZKeyPropertyModeData, DeadZoneArray) == 0x000000, "Member 'FSBZKeyPropertyModeData::DeadZoneArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZLookInputStanceSettings
// 0x0128 (0x0128 - 0x0000)
struct FSBZLookInputStanceSettings final
{
public:
	float                                         CardinalDeadZoneForXInput;                         // 0x0000(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CardinalDeadZoneForYInput;                         // 0x0004(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     HorizontalSensitivityCurve;                        // 0x0008(0x0088)(Edit, Config, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     VerticalSensitivityCurve;                          // 0x0090(0x0088)(Edit, Config, NativeAccessSpecifierPublic)
	float                                         AccelerationDeadZone;                              // 0x0118(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationMultiplier;                            // 0x011C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationTime;                                  // 0x0120(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZLookInputStanceSettings) == 0x000008, "Wrong alignment on FSBZLookInputStanceSettings");
static_assert(sizeof(FSBZLookInputStanceSettings) == 0x000128, "Wrong size on FSBZLookInputStanceSettings");
static_assert(offsetof(FSBZLookInputStanceSettings, CardinalDeadZoneForXInput) == 0x000000, "Member 'FSBZLookInputStanceSettings::CardinalDeadZoneForXInput' has a wrong offset!");
static_assert(offsetof(FSBZLookInputStanceSettings, CardinalDeadZoneForYInput) == 0x000004, "Member 'FSBZLookInputStanceSettings::CardinalDeadZoneForYInput' has a wrong offset!");
static_assert(offsetof(FSBZLookInputStanceSettings, HorizontalSensitivityCurve) == 0x000008, "Member 'FSBZLookInputStanceSettings::HorizontalSensitivityCurve' has a wrong offset!");
static_assert(offsetof(FSBZLookInputStanceSettings, VerticalSensitivityCurve) == 0x000090, "Member 'FSBZLookInputStanceSettings::VerticalSensitivityCurve' has a wrong offset!");
static_assert(offsetof(FSBZLookInputStanceSettings, AccelerationDeadZone) == 0x000118, "Member 'FSBZLookInputStanceSettings::AccelerationDeadZone' has a wrong offset!");
static_assert(offsetof(FSBZLookInputStanceSettings, AccelerationMultiplier) == 0x00011C, "Member 'FSBZLookInputStanceSettings::AccelerationMultiplier' has a wrong offset!");
static_assert(offsetof(FSBZLookInputStanceSettings, AccelerationTime) == 0x000120, "Member 'FSBZLookInputStanceSettings::AccelerationTime' has a wrong offset!");

// ScriptStruct Starbreeze.SBZLookInputSettings
// 0x0260 (0x0260 - 0x0000)
struct FSBZLookInputSettings final
{
public:
	struct FFloatInterval                         InputDeadZone;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSensitivityCurveEnabled;                        // 0x0008(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSBZLookInputStanceSettings            NormalStance;                                      // 0x0010(0x0128)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSBZLookInputStanceSettings            TargetingStance;                                   // 0x0138(0x0128)(Edit, Config, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZLookInputSettings) == 0x000008, "Wrong alignment on FSBZLookInputSettings");
static_assert(sizeof(FSBZLookInputSettings) == 0x000260, "Wrong size on FSBZLookInputSettings");
static_assert(offsetof(FSBZLookInputSettings, InputDeadZone) == 0x000000, "Member 'FSBZLookInputSettings::InputDeadZone' has a wrong offset!");
static_assert(offsetof(FSBZLookInputSettings, bIsSensitivityCurveEnabled) == 0x000008, "Member 'FSBZLookInputSettings::bIsSensitivityCurveEnabled' has a wrong offset!");
static_assert(offsetof(FSBZLookInputSettings, NormalStance) == 0x000010, "Member 'FSBZLookInputSettings::NormalStance' has a wrong offset!");
static_assert(offsetof(FSBZLookInputSettings, TargetingStance) == 0x000138, "Member 'FSBZLookInputSettings::TargetingStance' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPlayerSkillEffectData
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FSBZPlayerSkillEffectData final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZPlayerSkillEffectData) == 0x000008, "Wrong alignment on FSBZPlayerSkillEffectData");
static_assert(sizeof(FSBZPlayerSkillEffectData) == 0x000020, "Wrong size on FSBZPlayerSkillEffectData");

// ScriptStruct Starbreeze.SBZWeaponProgressionStats
// 0x0008 (0x0008 - 0x0000)
struct FSBZWeaponProgressionStats final
{
public:
	int32                                         WeaponProgressionLevel;                            // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeaponProgressionPoints;                           // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWeaponProgressionStats) == 0x000004, "Wrong alignment on FSBZWeaponProgressionStats");
static_assert(sizeof(FSBZWeaponProgressionStats) == 0x000008, "Wrong size on FSBZWeaponProgressionStats");
static_assert(offsetof(FSBZWeaponProgressionStats, WeaponProgressionLevel) == 0x000000, "Member 'FSBZWeaponProgressionStats::WeaponProgressionLevel' has a wrong offset!");
static_assert(offsetof(FSBZWeaponProgressionStats, WeaponProgressionPoints) == 0x000004, "Member 'FSBZWeaponProgressionStats::WeaponProgressionPoints' has a wrong offset!");

// ScriptStruct Starbreeze.SBZLevelTimesStruct
// 0x0008 (0x0008 - 0x0000)
struct FSBZLevelTimesStruct final
{
public:
	float                                         LoudTime;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StealthTime;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZLevelTimesStruct) == 0x000004, "Wrong alignment on FSBZLevelTimesStruct");
static_assert(sizeof(FSBZLevelTimesStruct) == 0x000008, "Wrong size on FSBZLevelTimesStruct");
static_assert(offsetof(FSBZLevelTimesStruct, LoudTime) == 0x000000, "Member 'FSBZLevelTimesStruct::LoudTime' has a wrong offset!");
static_assert(offsetof(FSBZLevelTimesStruct, StealthTime) == 0x000004, "Member 'FSBZLevelTimesStruct::StealthTime' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeaponStoreItem
// 0x0008 (0x00E0 - 0x00D8)
struct FSBZWeaponStoreItem final : public FSBZStoreBaseItem
{
public:
	class USBZBaseWeaponData*                     WeaponData;                                        // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWeaponStoreItem) == 0x000008, "Wrong alignment on FSBZWeaponStoreItem");
static_assert(sizeof(FSBZWeaponStoreItem) == 0x0000E0, "Wrong size on FSBZWeaponStoreItem");
static_assert(offsetof(FSBZWeaponStoreItem, WeaponData) == 0x0000D8, "Member 'FSBZWeaponStoreItem::WeaponData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZGloveStoreItem
// 0x0008 (0x00E0 - 0x00D8)
struct FSBZGloveStoreItem final : public FSBZStoreBaseItem
{
public:
	class USBZGloveData*                          GloveData;                                         // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZGloveStoreItem) == 0x000008, "Wrong alignment on FSBZGloveStoreItem");
static_assert(sizeof(FSBZGloveStoreItem) == 0x0000E0, "Wrong size on FSBZGloveStoreItem");
static_assert(offsetof(FSBZGloveStoreItem, GloveData) == 0x0000D8, "Member 'FSBZGloveStoreItem::GloveData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSuitPresetStoreItem
// 0x0008 (0x00E0 - 0x00D8)
struct FSBZSuitPresetStoreItem final : public FSBZStoreBaseItem
{
public:
	class USBZSuitPresetData*                     SuitPresetData;                                    // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSuitPresetStoreItem) == 0x000008, "Wrong alignment on FSBZSuitPresetStoreItem");
static_assert(sizeof(FSBZSuitPresetStoreItem) == 0x0000E0, "Wrong size on FSBZSuitPresetStoreItem");
static_assert(offsetof(FSBZSuitPresetStoreItem, SuitPresetData) == 0x0000D8, "Member 'FSBZSuitPresetStoreItem::SuitPresetData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSuitBaseStoreItem
// 0x0008 (0x00E0 - 0x00D8)
struct FSBZSuitBaseStoreItem final : public FSBZStoreBaseItem
{
public:
	class USBZSuitBaseData*                       SuitBaseData;                                      // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSuitBaseStoreItem) == 0x000008, "Wrong alignment on FSBZSuitBaseStoreItem");
static_assert(sizeof(FSBZSuitBaseStoreItem) == 0x0000E0, "Wrong size on FSBZSuitBaseStoreItem");
static_assert(offsetof(FSBZSuitBaseStoreItem, SuitBaseData) == 0x0000D8, "Member 'FSBZSuitBaseStoreItem::SuitBaseData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWatchStoreItem
// 0x0008 (0x00E0 - 0x00D8)
struct FSBZWatchStoreItem final : public FSBZStoreBaseItem
{
public:
	class USBZWatchData*                          WatchData;                                         // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWatchStoreItem) == 0x000008, "Wrong alignment on FSBZWatchStoreItem");
static_assert(sizeof(FSBZWatchStoreItem) == 0x0000E0, "Wrong size on FSBZWatchStoreItem");
static_assert(offsetof(FSBZWatchStoreItem, WatchData) == 0x0000D8, "Member 'FSBZWatchStoreItem::WatchData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPreplanningAssetStoreItem
// 0x0008 (0x00E0 - 0x00D8)
struct FSBZPreplanningAssetStoreItem final : public FSBZStoreBaseItem
{
public:
	class USBZPreplanningAssetData*               PreplanningAssetData;                              // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPreplanningAssetStoreItem) == 0x000008, "Wrong alignment on FSBZPreplanningAssetStoreItem");
static_assert(sizeof(FSBZPreplanningAssetStoreItem) == 0x0000E0, "Wrong size on FSBZPreplanningAssetStoreItem");
static_assert(offsetof(FSBZPreplanningAssetStoreItem, PreplanningAssetData) == 0x0000D8, "Member 'FSBZPreplanningAssetStoreItem::PreplanningAssetData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInventorySlotStoreItem
// 0x0008 (0x00E0 - 0x00D8)
struct FSBZInventorySlotStoreItem final : public FSBZStoreBaseItem
{
public:
	class USBZInventorySlotData*                  InventorySlotData;                                 // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZInventorySlotStoreItem) == 0x000008, "Wrong alignment on FSBZInventorySlotStoreItem");
static_assert(sizeof(FSBZInventorySlotStoreItem) == 0x0000E0, "Wrong size on FSBZInventorySlotStoreItem");
static_assert(offsetof(FSBZInventorySlotStoreItem, InventorySlotData) == 0x0000D8, "Member 'FSBZInventorySlotStoreItem::InventorySlotData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeaponPresetStoreItem
// 0x0008 (0x00E0 - 0x00D8)
struct FSBZWeaponPresetStoreItem final : public FSBZStoreBaseItem
{
public:
	class USBZWeaponPresetConfigData*             WeaponPresetConfigData;                            // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWeaponPresetStoreItem) == 0x000008, "Wrong alignment on FSBZWeaponPresetStoreItem");
static_assert(sizeof(FSBZWeaponPresetStoreItem) == 0x0000E0, "Wrong size on FSBZWeaponPresetStoreItem");
static_assert(offsetof(FSBZWeaponPresetStoreItem, WeaponPresetConfigData) == 0x0000D8, "Member 'FSBZWeaponPresetStoreItem::WeaponPresetConfigData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZLoadoutSlotStoreItem
// 0x0008 (0x00E0 - 0x00D8)
struct FSBZLoadoutSlotStoreItem final : public FSBZStoreBaseItem
{
public:
	class USBZLoadoutSlotData*                    LoadoutSlotData;                                   // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZLoadoutSlotStoreItem) == 0x000008, "Wrong alignment on FSBZLoadoutSlotStoreItem");
static_assert(sizeof(FSBZLoadoutSlotStoreItem) == 0x0000E0, "Wrong size on FSBZLoadoutSlotStoreItem");
static_assert(offsetof(FSBZLoadoutSlotStoreItem, LoadoutSlotData) == 0x0000D8, "Member 'FSBZLoadoutSlotStoreItem::LoadoutSlotData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeaponCharmStoreItem
// 0x0008 (0x00E0 - 0x00D8)
struct FSBZWeaponCharmStoreItem final : public FSBZStoreBaseItem
{
public:
	class USBZWeaponCharmData*                    WeaponCharmData;                                   // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWeaponCharmStoreItem) == 0x000008, "Wrong alignment on FSBZWeaponCharmStoreItem");
static_assert(sizeof(FSBZWeaponCharmStoreItem) == 0x0000E0, "Wrong size on FSBZWeaponCharmStoreItem");
static_assert(offsetof(FSBZWeaponCharmStoreItem, WeaponCharmData) == 0x0000D8, "Member 'FSBZWeaponCharmStoreItem::WeaponCharmData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeaponPatternStoreItem
// 0x0008 (0x00E0 - 0x00D8)
struct FSBZWeaponPatternStoreItem final : public FSBZStoreBaseItem
{
public:
	class USBZWeaponPatternData*                  WeaponPatternData;                                 // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWeaponPatternStoreItem) == 0x000008, "Wrong alignment on FSBZWeaponPatternStoreItem");
static_assert(sizeof(FSBZWeaponPatternStoreItem) == 0x0000E0, "Wrong size on FSBZWeaponPatternStoreItem");
static_assert(offsetof(FSBZWeaponPatternStoreItem, WeaponPatternData) == 0x0000D8, "Member 'FSBZWeaponPatternStoreItem::WeaponPatternData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeaponStickerStoreItem
// 0x0008 (0x00E0 - 0x00D8)
struct FSBZWeaponStickerStoreItem final : public FSBZStoreBaseItem
{
public:
	class USBZWeaponStickerData*                  WeaponStickerData;                                 // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWeaponStickerStoreItem) == 0x000008, "Wrong alignment on FSBZWeaponStickerStoreItem");
static_assert(sizeof(FSBZWeaponStickerStoreItem) == 0x0000E0, "Wrong size on FSBZWeaponStickerStoreItem");
static_assert(offsetof(FSBZWeaponStickerStoreItem, WeaponStickerData) == 0x0000D8, "Member 'FSBZWeaponStickerStoreItem::WeaponStickerData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMaskMouldStoreItem
// 0x0008 (0x00E0 - 0x00D8)
struct FSBZMaskMouldStoreItem final : public FSBZStoreBaseItem
{
public:
	class USBZMaskMouldData*                      MaskMouldData;                                     // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZMaskMouldStoreItem) == 0x000008, "Wrong alignment on FSBZMaskMouldStoreItem");
static_assert(sizeof(FSBZMaskMouldStoreItem) == 0x0000E0, "Wrong size on FSBZMaskMouldStoreItem");
static_assert(offsetof(FSBZMaskMouldStoreItem, MaskMouldData) == 0x0000D8, "Member 'FSBZMaskMouldStoreItem::MaskMouldData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMaskPresetStoreItem
// 0x0008 (0x00E0 - 0x00D8)
struct FSBZMaskPresetStoreItem final : public FSBZStoreBaseItem
{
public:
	class USBZMaskData*                           MaskData;                                          // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZMaskPresetStoreItem) == 0x000008, "Wrong alignment on FSBZMaskPresetStoreItem");
static_assert(sizeof(FSBZMaskPresetStoreItem) == 0x0000E0, "Wrong size on FSBZMaskPresetStoreItem");
static_assert(offsetof(FSBZMaskPresetStoreItem, MaskData) == 0x0000D8, "Member 'FSBZMaskPresetStoreItem::MaskData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMaskPreconfigStoreItem
// 0x0008 (0x00E0 - 0x00D8)
struct FSBZMaskPreconfigStoreItem final : public FSBZStoreBaseItem
{
public:
	class USBZMaskPreconfigData*                  MaskPreconfigData;                                 // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZMaskPreconfigStoreItem) == 0x000008, "Wrong alignment on FSBZMaskPreconfigStoreItem");
static_assert(sizeof(FSBZMaskPreconfigStoreItem) == 0x0000E0, "Wrong size on FSBZMaskPreconfigStoreItem");
static_assert(offsetof(FSBZMaskPreconfigStoreItem, MaskPreconfigData) == 0x0000D8, "Member 'FSBZMaskPreconfigStoreItem::MaskPreconfigData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMaskPatternStoreItem
// 0x0008 (0x00E0 - 0x00D8)
struct FSBZMaskPatternStoreItem final : public FSBZStoreBaseItem
{
public:
	class USBZMaskPatternData*                    MaskPatternData;                                   // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZMaskPatternStoreItem) == 0x000008, "Wrong alignment on FSBZMaskPatternStoreItem");
static_assert(sizeof(FSBZMaskPatternStoreItem) == 0x0000E0, "Wrong size on FSBZMaskPatternStoreItem");
static_assert(offsetof(FSBZMaskPatternStoreItem, MaskPatternData) == 0x0000D8, "Member 'FSBZMaskPatternStoreItem::MaskPatternData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMaskVFXStoreItem
// 0x0008 (0x00E0 - 0x00D8)
struct FSBZMaskVFXStoreItem final : public FSBZStoreBaseItem
{
public:
	class USBZMaskVFXData*                        MaskVFXData;                                       // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZMaskVFXStoreItem) == 0x000008, "Wrong alignment on FSBZMaskVFXStoreItem");
static_assert(sizeof(FSBZMaskVFXStoreItem) == 0x0000E0, "Wrong size on FSBZMaskVFXStoreItem");
static_assert(offsetof(FSBZMaskVFXStoreItem, MaskVFXData) == 0x0000D8, "Member 'FSBZMaskVFXStoreItem::MaskVFXData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSuitMaterialStoreItem
// 0x0008 (0x00E0 - 0x00D8)
struct FSBZSuitMaterialStoreItem final : public FSBZStoreBaseItem
{
public:
	class USBZSuitMaterialData*                   SuitMaterialData;                                  // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSuitMaterialStoreItem) == 0x000008, "Wrong alignment on FSBZSuitMaterialStoreItem");
static_assert(sizeof(FSBZSuitMaterialStoreItem) == 0x0000E0, "Wrong size on FSBZSuitMaterialStoreItem");
static_assert(offsetof(FSBZSuitMaterialStoreItem, SuitMaterialData) == 0x0000D8, "Member 'FSBZSuitMaterialStoreItem::SuitMaterialData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSuitPatternStoreItem
// 0x0008 (0x00E0 - 0x00D8)
struct FSBZSuitPatternStoreItem final : public FSBZStoreBaseItem
{
public:
	class USBZSuitPatternData*                    SuitPatternData;                                   // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSuitPatternStoreItem) == 0x000008, "Wrong alignment on FSBZSuitPatternStoreItem");
static_assert(sizeof(FSBZSuitPatternStoreItem) == 0x0000E0, "Wrong size on FSBZSuitPatternStoreItem");
static_assert(offsetof(FSBZSuitPatternStoreItem, SuitPatternData) == 0x0000D8, "Member 'FSBZSuitPatternStoreItem::SuitPatternData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCoinStoreItem
// 0x0008 (0x00E0 - 0x00D8)
struct FSBZCoinStoreItem final : public FSBZStoreBaseItem
{
public:
	class USBZCoinData*                           CoinData;                                          // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZCoinStoreItem) == 0x000008, "Wrong alignment on FSBZCoinStoreItem");
static_assert(sizeof(FSBZCoinStoreItem) == 0x0000E0, "Wrong size on FSBZCoinStoreItem");
static_assert(offsetof(FSBZCoinStoreItem, CoinData) == 0x0000D8, "Member 'FSBZCoinStoreItem::CoinData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZBundleItem
// 0x0018 (0x00F0 - 0x00D8)
struct FSBZBundleItem final : public FSBZStoreBaseItem
{
public:
	ESBZItemCategory                              BundleItemCategory;                                // 0x00D8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USBZInventoryBaseData*                  BundleItemData;                                    // 0x00E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x00E8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZBundleItem) == 0x000008, "Wrong alignment on FSBZBundleItem");
static_assert(sizeof(FSBZBundleItem) == 0x0000F0, "Wrong size on FSBZBundleItem");
static_assert(offsetof(FSBZBundleItem, BundleItemCategory) == 0x0000D8, "Member 'FSBZBundleItem::BundleItemCategory' has a wrong offset!");
static_assert(offsetof(FSBZBundleItem, BundleItemData) == 0x0000E0, "Member 'FSBZBundleItem::BundleItemData' has a wrong offset!");
static_assert(offsetof(FSBZBundleItem, Quantity) == 0x0000E8, "Member 'FSBZBundleItem::Quantity' has a wrong offset!");

// ScriptStruct Starbreeze.SBZItemBundleStoreItem
// 0x0018 (0x00F0 - 0x00D8)
struct FSBZItemBundleStoreItem final : public FSBZStoreBaseItem
{
public:
	class USBZItemBundleData*                     ItemBundleData;                                    // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSBZBundleItem>                 BundleContentArray;                                // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZItemBundleStoreItem) == 0x000008, "Wrong alignment on FSBZItemBundleStoreItem");
static_assert(sizeof(FSBZItemBundleStoreItem) == 0x0000F0, "Wrong size on FSBZItemBundleStoreItem");
static_assert(offsetof(FSBZItemBundleStoreItem, ItemBundleData) == 0x0000D8, "Member 'FSBZItemBundleStoreItem::ItemBundleData' has a wrong offset!");
static_assert(offsetof(FSBZItemBundleStoreItem, BundleContentArray) == 0x0000E0, "Member 'FSBZItemBundleStoreItem::BundleContentArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZHeistStoreItem
// 0x0000 (0x00D8 - 0x00D8)
struct FSBZHeistStoreItem final : public FSBZStoreBaseItem
{
};
static_assert(alignof(FSBZHeistStoreItem) == 0x000008, "Wrong alignment on FSBZHeistStoreItem");
static_assert(sizeof(FSBZHeistStoreItem) == 0x0000D8, "Wrong size on FSBZHeistStoreItem");

// ScriptStruct Starbreeze.SBZVendorPermissionStoreItem
// 0x0000 (0x00D8 - 0x00D8)
struct FSBZVendorPermissionStoreItem final : public FSBZStoreBaseItem
{
};
static_assert(alignof(FSBZVendorPermissionStoreItem) == 0x000008, "Wrong alignment on FSBZVendorPermissionStoreItem");
static_assert(sizeof(FSBZVendorPermissionStoreItem) == 0x0000D8, "Wrong size on FSBZVendorPermissionStoreItem");

// ScriptStruct Starbreeze.SBZPlayerCharacterStoreItem
// 0x0000 (0x00D8 - 0x00D8)
struct FSBZPlayerCharacterStoreItem final : public FSBZStoreBaseItem
{
};
static_assert(alignof(FSBZPlayerCharacterStoreItem) == 0x000008, "Wrong alignment on FSBZPlayerCharacterStoreItem");
static_assert(sizeof(FSBZPlayerCharacterStoreItem) == 0x0000D8, "Wrong size on FSBZPlayerCharacterStoreItem");

// ScriptStruct Starbreeze.SBZOverkillWeaponStoreItem
// 0x0000 (0x00D8 - 0x00D8)
struct FSBZOverkillWeaponStoreItem final : public FSBZStoreBaseItem
{
};
static_assert(alignof(FSBZOverkillWeaponStoreItem) == 0x000008, "Wrong alignment on FSBZOverkillWeaponStoreItem");
static_assert(sizeof(FSBZOverkillWeaponStoreItem) == 0x0000D8, "Wrong size on FSBZOverkillWeaponStoreItem");

// ScriptStruct Starbreeze.SBZOverskillLoadoutStoreItem
// 0x0000 (0x00D8 - 0x00D8)
struct FSBZOverskillLoadoutStoreItem final : public FSBZStoreBaseItem
{
};
static_assert(alignof(FSBZOverskillLoadoutStoreItem) == 0x000008, "Wrong alignment on FSBZOverskillLoadoutStoreItem");
static_assert(sizeof(FSBZOverskillLoadoutStoreItem) == 0x0000D8, "Wrong size on FSBZOverskillLoadoutStoreItem");

// ScriptStruct Starbreeze.SBZPlaceableStoreItem
// 0x0000 (0x00D8 - 0x00D8)
struct FSBZPlaceableStoreItem final : public FSBZStoreBaseItem
{
};
static_assert(alignof(FSBZPlaceableStoreItem) == 0x000008, "Wrong alignment on FSBZPlaceableStoreItem");
static_assert(sizeof(FSBZPlaceableStoreItem) == 0x0000D8, "Wrong size on FSBZPlaceableStoreItem");

// ScriptStruct Starbreeze.SBZToolStoreItem
// 0x0000 (0x00D8 - 0x00D8)
struct FSBZToolStoreItem final : public FSBZStoreBaseItem
{
};
static_assert(alignof(FSBZToolStoreItem) == 0x000008, "Wrong alignment on FSBZToolStoreItem");
static_assert(sizeof(FSBZToolStoreItem) == 0x0000D8, "Wrong size on FSBZToolStoreItem");

// ScriptStruct Starbreeze.SBZArmorStoreItem
// 0x0008 (0x00E0 - 0x00D8)
struct FSBZArmorStoreItem final : public FSBZStoreBaseItem
{
public:
	class USBZArmorData*                          ArmorData;                                         // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZArmorStoreItem) == 0x000008, "Wrong alignment on FSBZArmorStoreItem");
static_assert(sizeof(FSBZArmorStoreItem) == 0x0000E0, "Wrong size on FSBZArmorStoreItem");
static_assert(offsetof(FSBZArmorStoreItem, ArmorData) == 0x0000D8, "Member 'FSBZArmorStoreItem::ArmorData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZThrowableStoreItem
// 0x0000 (0x00D8 - 0x00D8)
struct FSBZThrowableStoreItem final : public FSBZStoreBaseItem
{
};
static_assert(alignof(FSBZThrowableStoreItem) == 0x000008, "Wrong alignment on FSBZThrowableStoreItem");
static_assert(sizeof(FSBZThrowableStoreItem) == 0x0000D8, "Wrong size on FSBZThrowableStoreItem");

// ScriptStruct Starbreeze.SBZPlayerStoreItemData
// 0x0BE0 (0x0BE0 - 0x0000)
struct FSBZPlayerStoreItemData final
{
public:
	TMap<class FString, struct FSBZWeaponStoreItem> PrimaryWeaponMap;                                // 0x0000(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZWeaponStoreItem> SecondaryWeaponMap;                              // 0x0050(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZGloveStoreItem> GloveMap;                                         // 0x00A0(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZSuitPresetStoreItem> SuitPresetMap;                               // 0x00F0(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZSuitBaseStoreItem> SuitBaseMap;                                   // 0x0140(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZWatchStoreItem> WatchMap;                                         // 0x0190(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZPreplanningAssetStoreItem> PreplanningAssetMap;                   // 0x01E0(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZInventorySlotStoreItem> PrimaryInventorySlotMap;                  // 0x0230(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZInventorySlotStoreItem> SecondaryInventorySlotMap;                // 0x0280(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZInventorySlotStoreItem> ArmorInventorySlotMap;                    // 0x02D0(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZInventorySlotStoreItem> MaskInventorySlotMap;                     // 0x0320(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZInventorySlotStoreItem> SuitInventorySlotMap;                     // 0x0370(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZInventorySlotStoreItem> GloveInventorySlotMap;                    // 0x03C0(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZWeaponPresetStoreItem> PrimaryWeaponPresetMap;                    // 0x0410(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZWeaponPresetStoreItem> SecondaryWeaponPresetMap;                  // 0x0460(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZLoadoutSlotStoreItem> LoadoutSlotMap;                             // 0x04B0(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZSprayCanStoreItem> SprayCanMap;                                   // 0x0500(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZWeaponCharmStoreItem> WeaponCharmMap;                             // 0x0550(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZWeaponPatternStoreItem> WeaponPatternMap;                         // 0x05A0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZWeaponStickerStoreItem> WeaponStickerMap;                         // 0x05F0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZMaskMouldStoreItem> MaskMouldMap;                                 // 0x0640(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZMaskPresetStoreItem> MaskPresetMap;                               // 0x0690(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZMaskPreconfigStoreItem> MaskPreconfigMap;                         // 0x06E0(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZMaskPatternStoreItem> MaskPatternMap;                             // 0x0730(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZMaskVFXStoreItem> MaskVFXMap;                                     // 0x0780(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZSuitMaterialStoreItem> SuitMaterialMap;                           // 0x07D0(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZSuitPatternStoreItem> SuitPatternMap;                             // 0x0820(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZCoinStoreItem> CoinMap;                                           // 0x0870(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZItemBundleStoreItem> ItemBundleMap;                               // 0x08C0(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZHeistStoreItem> HeistMap;                                         // 0x0910(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZVendorPermissionStoreItem> VendorPermissionMap;                   // 0x0960(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZPlayerCharacterStoreItem> PlayerCharacterMap;                     // 0x09B0(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZOverkillWeaponStoreItem> OverkillWeaponMap;                       // 0x0A00(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZOverskillLoadoutStoreItem> OverskillLoadoutMap;                   // 0x0A50(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZPlaceableStoreItem> PlaceableMap;                                 // 0x0AA0(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZToolStoreItem> ToolMap;                                           // 0x0AF0(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZArmorStoreItem> ArmorMap;                                         // 0x0B40(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZThrowableStoreItem> ThrowableMap;                                 // 0x0B90(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPlayerStoreItemData) == 0x000008, "Wrong alignment on FSBZPlayerStoreItemData");
static_assert(sizeof(FSBZPlayerStoreItemData) == 0x000BE0, "Wrong size on FSBZPlayerStoreItemData");
static_assert(offsetof(FSBZPlayerStoreItemData, PrimaryWeaponMap) == 0x000000, "Member 'FSBZPlayerStoreItemData::PrimaryWeaponMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, SecondaryWeaponMap) == 0x000050, "Member 'FSBZPlayerStoreItemData::SecondaryWeaponMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, GloveMap) == 0x0000A0, "Member 'FSBZPlayerStoreItemData::GloveMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, SuitPresetMap) == 0x0000F0, "Member 'FSBZPlayerStoreItemData::SuitPresetMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, SuitBaseMap) == 0x000140, "Member 'FSBZPlayerStoreItemData::SuitBaseMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, WatchMap) == 0x000190, "Member 'FSBZPlayerStoreItemData::WatchMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, PreplanningAssetMap) == 0x0001E0, "Member 'FSBZPlayerStoreItemData::PreplanningAssetMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, PrimaryInventorySlotMap) == 0x000230, "Member 'FSBZPlayerStoreItemData::PrimaryInventorySlotMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, SecondaryInventorySlotMap) == 0x000280, "Member 'FSBZPlayerStoreItemData::SecondaryInventorySlotMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, ArmorInventorySlotMap) == 0x0002D0, "Member 'FSBZPlayerStoreItemData::ArmorInventorySlotMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, MaskInventorySlotMap) == 0x000320, "Member 'FSBZPlayerStoreItemData::MaskInventorySlotMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, SuitInventorySlotMap) == 0x000370, "Member 'FSBZPlayerStoreItemData::SuitInventorySlotMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, GloveInventorySlotMap) == 0x0003C0, "Member 'FSBZPlayerStoreItemData::GloveInventorySlotMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, PrimaryWeaponPresetMap) == 0x000410, "Member 'FSBZPlayerStoreItemData::PrimaryWeaponPresetMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, SecondaryWeaponPresetMap) == 0x000460, "Member 'FSBZPlayerStoreItemData::SecondaryWeaponPresetMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, LoadoutSlotMap) == 0x0004B0, "Member 'FSBZPlayerStoreItemData::LoadoutSlotMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, SprayCanMap) == 0x000500, "Member 'FSBZPlayerStoreItemData::SprayCanMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, WeaponCharmMap) == 0x000550, "Member 'FSBZPlayerStoreItemData::WeaponCharmMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, WeaponPatternMap) == 0x0005A0, "Member 'FSBZPlayerStoreItemData::WeaponPatternMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, WeaponStickerMap) == 0x0005F0, "Member 'FSBZPlayerStoreItemData::WeaponStickerMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, MaskMouldMap) == 0x000640, "Member 'FSBZPlayerStoreItemData::MaskMouldMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, MaskPresetMap) == 0x000690, "Member 'FSBZPlayerStoreItemData::MaskPresetMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, MaskPreconfigMap) == 0x0006E0, "Member 'FSBZPlayerStoreItemData::MaskPreconfigMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, MaskPatternMap) == 0x000730, "Member 'FSBZPlayerStoreItemData::MaskPatternMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, MaskVFXMap) == 0x000780, "Member 'FSBZPlayerStoreItemData::MaskVFXMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, SuitMaterialMap) == 0x0007D0, "Member 'FSBZPlayerStoreItemData::SuitMaterialMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, SuitPatternMap) == 0x000820, "Member 'FSBZPlayerStoreItemData::SuitPatternMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, CoinMap) == 0x000870, "Member 'FSBZPlayerStoreItemData::CoinMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, ItemBundleMap) == 0x0008C0, "Member 'FSBZPlayerStoreItemData::ItemBundleMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, HeistMap) == 0x000910, "Member 'FSBZPlayerStoreItemData::HeistMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, VendorPermissionMap) == 0x000960, "Member 'FSBZPlayerStoreItemData::VendorPermissionMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, PlayerCharacterMap) == 0x0009B0, "Member 'FSBZPlayerStoreItemData::PlayerCharacterMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, OverkillWeaponMap) == 0x000A00, "Member 'FSBZPlayerStoreItemData::OverkillWeaponMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, OverskillLoadoutMap) == 0x000A50, "Member 'FSBZPlayerStoreItemData::OverskillLoadoutMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, PlaceableMap) == 0x000AA0, "Member 'FSBZPlayerStoreItemData::PlaceableMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, ToolMap) == 0x000AF0, "Member 'FSBZPlayerStoreItemData::ToolMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, ArmorMap) == 0x000B40, "Member 'FSBZPlayerStoreItemData::ArmorMap' has a wrong offset!");
static_assert(offsetof(FSBZPlayerStoreItemData, ThrowableMap) == 0x000B90, "Member 'FSBZPlayerStoreItemData::ThrowableMap' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSharedWeaponParentLock
// 0x0020 (0x0020 - 0x0000)
struct FSBZSharedWeaponParentLock final
{
public:
	class FString                                 UnlockWeaponSku;                                   // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UnlockWeaponRequiredLevel;                         // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UnlockWeaponCurrentLevel;                          // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLockedByOtherWeapon;                            // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZSharedWeaponParentLock) == 0x000008, "Wrong alignment on FSBZSharedWeaponParentLock");
static_assert(sizeof(FSBZSharedWeaponParentLock) == 0x000020, "Wrong size on FSBZSharedWeaponParentLock");
static_assert(offsetof(FSBZSharedWeaponParentLock, UnlockWeaponSku) == 0x000000, "Member 'FSBZSharedWeaponParentLock::UnlockWeaponSku' has a wrong offset!");
static_assert(offsetof(FSBZSharedWeaponParentLock, UnlockWeaponRequiredLevel) == 0x000010, "Member 'FSBZSharedWeaponParentLock::UnlockWeaponRequiredLevel' has a wrong offset!");
static_assert(offsetof(FSBZSharedWeaponParentLock, UnlockWeaponCurrentLevel) == 0x000014, "Member 'FSBZSharedWeaponParentLock::UnlockWeaponCurrentLevel' has a wrong offset!");
static_assert(offsetof(FSBZSharedWeaponParentLock, bIsLockedByOtherWeapon) == 0x000018, "Member 'FSBZSharedWeaponParentLock::bIsLockedByOtherWeapon' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPayDayCreditStoreItem
// 0x0008 (0x00E0 - 0x00D8)
struct FSBZPayDayCreditStoreItem final : public FSBZStoreBaseItem
{
public:
	class USBZPayDayCreditData*                   PayDayCreditData;                                  // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPayDayCreditStoreItem) == 0x000008, "Wrong alignment on FSBZPayDayCreditStoreItem");
static_assert(sizeof(FSBZPayDayCreditStoreItem) == 0x0000E0, "Wrong size on FSBZPayDayCreditStoreItem");
static_assert(offsetof(FSBZPayDayCreditStoreItem, PayDayCreditData) == 0x0000D8, "Member 'FSBZPayDayCreditStoreItem::PayDayCreditData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMetaNotification
// 0x0020 (0x0020 - 0x0000)
struct FSBZMetaNotification final
{
public:
	ESBZMetaRequestResult                         MetaResult;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayText;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZMetaNotification) == 0x000008, "Wrong alignment on FSBZMetaNotification");
static_assert(sizeof(FSBZMetaNotification) == 0x000020, "Wrong size on FSBZMetaNotification");
static_assert(offsetof(FSBZMetaNotification, MetaResult) == 0x000000, "Member 'FSBZMetaNotification::MetaResult' has a wrong offset!");
static_assert(offsetof(FSBZMetaNotification, DisplayText) == 0x000008, "Member 'FSBZMetaNotification::DisplayText' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSideBarNotificationData
// 0x0040 (0x0040 - 0x0000)
struct FSBZSideBarNotificationData final
{
public:
	class FText                                   HeaderText;                                        // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   DescriptionText;                                   // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         DisplayTime;                                       // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USBZInventoryBaseData*                  InventoryItem;                                     // 0x0038(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSideBarNotificationData) == 0x000008, "Wrong alignment on FSBZSideBarNotificationData");
static_assert(sizeof(FSBZSideBarNotificationData) == 0x000040, "Wrong size on FSBZSideBarNotificationData");
static_assert(offsetof(FSBZSideBarNotificationData, HeaderText) == 0x000000, "Member 'FSBZSideBarNotificationData::HeaderText' has a wrong offset!");
static_assert(offsetof(FSBZSideBarNotificationData, DescriptionText) == 0x000018, "Member 'FSBZSideBarNotificationData::DescriptionText' has a wrong offset!");
static_assert(offsetof(FSBZSideBarNotificationData, DisplayTime) == 0x000030, "Member 'FSBZSideBarNotificationData::DisplayTime' has a wrong offset!");
static_assert(offsetof(FSBZSideBarNotificationData, InventoryItem) == 0x000038, "Member 'FSBZSideBarNotificationData::InventoryItem' has a wrong offset!");

// ScriptStruct Starbreeze.SBZUIPopupData
// 0x0060 (0x0060 - 0x0000)
struct FSBZUIPopupData final
{
public:
	class FText                                   HeaderText;                                        // 0x0000(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   DescriptionText;                                   // 0x0018(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSBZButtonControlsReference            PopUpControlsReference;                            // 0x0030(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	class UUserWidget*                            WidgetBody;                                        // 0x0058(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZUIPopupData) == 0x000008, "Wrong alignment on FSBZUIPopupData");
static_assert(sizeof(FSBZUIPopupData) == 0x000060, "Wrong size on FSBZUIPopupData");
static_assert(offsetof(FSBZUIPopupData, HeaderText) == 0x000000, "Member 'FSBZUIPopupData::HeaderText' has a wrong offset!");
static_assert(offsetof(FSBZUIPopupData, DescriptionText) == 0x000018, "Member 'FSBZUIPopupData::DescriptionText' has a wrong offset!");
static_assert(offsetof(FSBZUIPopupData, PopUpControlsReference) == 0x000030, "Member 'FSBZUIPopupData::PopUpControlsReference' has a wrong offset!");
static_assert(offsetof(FSBZUIPopupData, WidgetBody) == 0x000058, "Member 'FSBZUIPopupData::WidgetBody' has a wrong offset!");

// ScriptStruct Starbreeze.SBZUIFullscreenNotificationData
// 0x0038 (0x0038 - 0x0000)
struct FSBZUIFullscreenNotificationData final
{
public:
	class FText                                   HeaderText;                                        // 0x0000(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   DescriptionText;                                   // 0x0018(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	ESBZNotificationType                          NotificationType;                                  // 0x0030(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZUIFullscreenNotificationData) == 0x000008, "Wrong alignment on FSBZUIFullscreenNotificationData");
static_assert(sizeof(FSBZUIFullscreenNotificationData) == 0x000038, "Wrong size on FSBZUIFullscreenNotificationData");
static_assert(offsetof(FSBZUIFullscreenNotificationData, HeaderText) == 0x000000, "Member 'FSBZUIFullscreenNotificationData::HeaderText' has a wrong offset!");
static_assert(offsetof(FSBZUIFullscreenNotificationData, DescriptionText) == 0x000018, "Member 'FSBZUIFullscreenNotificationData::DescriptionText' has a wrong offset!");
static_assert(offsetof(FSBZUIFullscreenNotificationData, NotificationType) == 0x000030, "Member 'FSBZUIFullscreenNotificationData::NotificationType' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPreplanningAsset
// 0x0038 (0x0038 - 0x0000)
struct FSBZPreplanningAsset final
{
public:
	struct FUniqueNetIdRepl                       PlayerId;                                          // 0x0000(0x0028)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SkuNo;                                             // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPreplanningAsset) == 0x000008, "Wrong alignment on FSBZPreplanningAsset");
static_assert(sizeof(FSBZPreplanningAsset) == 0x000038, "Wrong size on FSBZPreplanningAsset");
static_assert(offsetof(FSBZPreplanningAsset, PlayerId) == 0x000000, "Member 'FSBZPreplanningAsset::PlayerId' has a wrong offset!");
static_assert(offsetof(FSBZPreplanningAsset, SkuNo) == 0x000028, "Member 'FSBZPreplanningAsset::SkuNo' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPreplanningModifierSettingsData
// 0x0010 (0x0010 - 0x0000)
struct FSBZPreplanningModifierSettingsData final
{
public:
	uint8                                         PagerIncreaseAmount;                               // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        HostageReduceAmount;                               // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmmoPickupIncreasePercent;                         // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NegotiationTimeIncrease;                           // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPreplanningModifierSettingsData) == 0x000004, "Wrong alignment on FSBZPreplanningModifierSettingsData");
static_assert(sizeof(FSBZPreplanningModifierSettingsData) == 0x000010, "Wrong size on FSBZPreplanningModifierSettingsData");
static_assert(offsetof(FSBZPreplanningModifierSettingsData, PagerIncreaseAmount) == 0x000000, "Member 'FSBZPreplanningModifierSettingsData::PagerIncreaseAmount' has a wrong offset!");
static_assert(offsetof(FSBZPreplanningModifierSettingsData, HostageReduceAmount) == 0x000004, "Member 'FSBZPreplanningModifierSettingsData::HostageReduceAmount' has a wrong offset!");
static_assert(offsetof(FSBZPreplanningModifierSettingsData, AmmoPickupIncreasePercent) == 0x000008, "Member 'FSBZPreplanningModifierSettingsData::AmmoPickupIncreasePercent' has a wrong offset!");
static_assert(offsetof(FSBZPreplanningModifierSettingsData, NegotiationTimeIncrease) == 0x00000C, "Member 'FSBZPreplanningModifierSettingsData::NegotiationTimeIncrease' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeaponEntitlementData
// 0x0014 (0x0014 - 0x0000)
struct FSBZWeaponEntitlementData final
{
public:
	struct FGuid                                  ConfigSlotEntitlementId;                           // 0x0000(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZEquippableLoadoutSlot                     EquippableLoadoutSlot;                             // 0x0010(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZWeaponEntitlementData) == 0x000004, "Wrong alignment on FSBZWeaponEntitlementData");
static_assert(sizeof(FSBZWeaponEntitlementData) == 0x000014, "Wrong size on FSBZWeaponEntitlementData");
static_assert(offsetof(FSBZWeaponEntitlementData, ConfigSlotEntitlementId) == 0x000000, "Member 'FSBZWeaponEntitlementData::ConfigSlotEntitlementId' has a wrong offset!");
static_assert(offsetof(FSBZWeaponEntitlementData, EquippableLoadoutSlot) == 0x000010, "Member 'FSBZWeaponEntitlementData::EquippableLoadoutSlot' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeaponInventorySlotAndIndex
// 0x00E0 (0x00E0 - 0x0000)
struct FSBZWeaponInventorySlotAndIndex final
{
public:
	struct FSBZWeaponInventorySlot                WeaponInventorySlot;                               // 0x0000(0x00D8)(Transient, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x00D8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZWeaponInventorySlotAndIndex) == 0x000008, "Wrong alignment on FSBZWeaponInventorySlotAndIndex");
static_assert(sizeof(FSBZWeaponInventorySlotAndIndex) == 0x0000E0, "Wrong size on FSBZWeaponInventorySlotAndIndex");
static_assert(offsetof(FSBZWeaponInventorySlotAndIndex, WeaponInventorySlot) == 0x000000, "Member 'FSBZWeaponInventorySlotAndIndex::WeaponInventorySlot' has a wrong offset!");
static_assert(offsetof(FSBZWeaponInventorySlotAndIndex, Index) == 0x0000D8, "Member 'FSBZWeaponInventorySlotAndIndex::Index' has a wrong offset!");

// ScriptStruct Starbreeze.SBZArmorInventorySlotAndIndex
// 0x0070 (0x0070 - 0x0000)
struct FSBZArmorInventorySlotAndIndex final
{
public:
	struct FSBZArmorInventorySlot                 ArmorInventorySlot;                                // 0x0000(0x0068)(Transient, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x0068(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZArmorInventorySlotAndIndex) == 0x000008, "Wrong alignment on FSBZArmorInventorySlotAndIndex");
static_assert(sizeof(FSBZArmorInventorySlotAndIndex) == 0x000070, "Wrong size on FSBZArmorInventorySlotAndIndex");
static_assert(offsetof(FSBZArmorInventorySlotAndIndex, ArmorInventorySlot) == 0x000000, "Member 'FSBZArmorInventorySlotAndIndex::ArmorInventorySlot' has a wrong offset!");
static_assert(offsetof(FSBZArmorInventorySlotAndIndex, Index) == 0x000068, "Member 'FSBZArmorInventorySlotAndIndex::Index' has a wrong offset!");

// ScriptStruct Starbreeze.SBZGloveInventorySlotAndIndex
// 0x0058 (0x0058 - 0x0000)
struct FSBZGloveInventorySlotAndIndex final
{
public:
	struct FSBZGloveInventorySlot                 GloveInventorySlot;                                // 0x0000(0x0050)(Transient, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x0050(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZGloveInventorySlotAndIndex) == 0x000008, "Wrong alignment on FSBZGloveInventorySlotAndIndex");
static_assert(sizeof(FSBZGloveInventorySlotAndIndex) == 0x000058, "Wrong size on FSBZGloveInventorySlotAndIndex");
static_assert(offsetof(FSBZGloveInventorySlotAndIndex, GloveInventorySlot) == 0x000000, "Member 'FSBZGloveInventorySlotAndIndex::GloveInventorySlot' has a wrong offset!");
static_assert(offsetof(FSBZGloveInventorySlotAndIndex, Index) == 0x000050, "Member 'FSBZGloveInventorySlotAndIndex::Index' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSuitInventorySlotAndIndex
// 0x0090 (0x0090 - 0x0000)
struct FSBZSuitInventorySlotAndIndex final
{
public:
	struct FSBZSuitInventorySlot                  SuitInventorySlot;                                 // 0x0000(0x0088)(Transient, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x0088(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZSuitInventorySlotAndIndex) == 0x000008, "Wrong alignment on FSBZSuitInventorySlotAndIndex");
static_assert(sizeof(FSBZSuitInventorySlotAndIndex) == 0x000090, "Wrong size on FSBZSuitInventorySlotAndIndex");
static_assert(offsetof(FSBZSuitInventorySlotAndIndex, SuitInventorySlot) == 0x000000, "Member 'FSBZSuitInventorySlotAndIndex::SuitInventorySlot' has a wrong offset!");
static_assert(offsetof(FSBZSuitInventorySlotAndIndex, Index) == 0x000088, "Member 'FSBZSuitInventorySlotAndIndex::Index' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMaskInventorySlotAndIndex
// 0x00D8 (0x00D8 - 0x0000)
struct FSBZMaskInventorySlotAndIndex final
{
public:
	struct FSBZMaskInventorySlot                  MaskInventorySlot;                                 // 0x0000(0x00D0)(Transient, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x00D0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZMaskInventorySlotAndIndex) == 0x000008, "Wrong alignment on FSBZMaskInventorySlotAndIndex");
static_assert(sizeof(FSBZMaskInventorySlotAndIndex) == 0x0000D8, "Wrong size on FSBZMaskInventorySlotAndIndex");
static_assert(offsetof(FSBZMaskInventorySlotAndIndex, MaskInventorySlot) == 0x000000, "Member 'FSBZMaskInventorySlotAndIndex::MaskInventorySlot' has a wrong offset!");
static_assert(offsetof(FSBZMaskInventorySlotAndIndex, Index) == 0x0000D0, "Member 'FSBZMaskInventorySlotAndIndex::Index' has a wrong offset!");

// ScriptStruct Starbreeze.SBZStatUpdate
// 0x0018 (0x0018 - 0x0000)
struct FSBZStatUpdate final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZStatUpdate) == 0x000008, "Wrong alignment on FSBZStatUpdate");
static_assert(sizeof(FSBZStatUpdate) == 0x000018, "Wrong size on FSBZStatUpdate");
static_assert(offsetof(FSBZStatUpdate, Key) == 0x000000, "Member 'FSBZStatUpdate::Key' has a wrong offset!");
static_assert(offsetof(FSBZStatUpdate, Value) == 0x000010, "Member 'FSBZStatUpdate::Value' has a wrong offset!");

// ScriptStruct Starbreeze.SBZProgressionSaveCachedChallengesData
// 0x0050 (0x0050 - 0x0000)
struct FSBZProgressionSaveCachedChallengesData final
{
public:
	TMap<class FName, struct FSBZChallengeData>   CachedChallenges;                                  // 0x0000(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZProgressionSaveCachedChallengesData) == 0x000008, "Wrong alignment on FSBZProgressionSaveCachedChallengesData");
static_assert(sizeof(FSBZProgressionSaveCachedChallengesData) == 0x000050, "Wrong size on FSBZProgressionSaveCachedChallengesData");
static_assert(offsetof(FSBZProgressionSaveCachedChallengesData, CachedChallenges) == 0x000000, "Member 'FSBZProgressionSaveCachedChallengesData::CachedChallenges' has a wrong offset!");

// ScriptStruct Starbreeze.SBZVolumeTypeSetting
// 0x0018 (0x0018 - 0x0000)
struct FSBZVolumeTypeSetting final
{
public:
	class FName                                   RTPC;                                              // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundClass*                            SoundClass;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZVolumeTypeSetting) == 0x000008, "Wrong alignment on FSBZVolumeTypeSetting");
static_assert(sizeof(FSBZVolumeTypeSetting) == 0x000018, "Wrong size on FSBZVolumeTypeSetting");
static_assert(offsetof(FSBZVolumeTypeSetting, RTPC) == 0x000000, "Member 'FSBZVolumeTypeSetting::RTPC' has a wrong offset!");
static_assert(offsetof(FSBZVolumeTypeSetting, SoundClass) == 0x000010, "Member 'FSBZVolumeTypeSetting::SoundClass' has a wrong offset!");

// ScriptStruct Starbreeze.SBZRecommendedChallengeBlock
// 0x0010 (0x0010 - 0x0000)
struct FSBZRecommendedChallengeBlock final
{
public:
	TArray<class FName>                           ChallengeIdArray;                                  // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZRecommendedChallengeBlock) == 0x000008, "Wrong alignment on FSBZRecommendedChallengeBlock");
static_assert(sizeof(FSBZRecommendedChallengeBlock) == 0x000010, "Wrong size on FSBZRecommendedChallengeBlock");
static_assert(offsetof(FSBZRecommendedChallengeBlock, ChallengeIdArray) == 0x000000, "Member 'FSBZRecommendedChallengeBlock::ChallengeIdArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPlayerLoadoutConfigArray
// 0x0010 (0x0010 - 0x0000)
struct FSBZPlayerLoadoutConfigArray final
{
public:
	TArray<struct FSBZPlayerLoadoutConfig>        PlayerLoadoutConfigArray;                          // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPlayerLoadoutConfigArray) == 0x000008, "Wrong alignment on FSBZPlayerLoadoutConfigArray");
static_assert(sizeof(FSBZPlayerLoadoutConfigArray) == 0x000010, "Wrong size on FSBZPlayerLoadoutConfigArray");
static_assert(offsetof(FSBZPlayerLoadoutConfigArray, PlayerLoadoutConfigArray) == 0x000000, "Member 'FSBZPlayerLoadoutConfigArray::PlayerLoadoutConfigArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZInfamySaveData
// 0x0008 (0x0008 - 0x0000)
struct FSBZInfamySaveData final
{
public:
	int32                                         InfamyExperience;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InfamyLevel;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZInfamySaveData) == 0x000004, "Wrong alignment on FSBZInfamySaveData");
static_assert(sizeof(FSBZInfamySaveData) == 0x000008, "Wrong size on FSBZInfamySaveData");
static_assert(offsetof(FSBZInfamySaveData, InfamyExperience) == 0x000000, "Member 'FSBZInfamySaveData::InfamyExperience' has a wrong offset!");
static_assert(offsetof(FSBZInfamySaveData, InfamyLevel) == 0x000004, "Member 'FSBZInfamySaveData::InfamyLevel' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSkipIntroSequenceData
// 0x0010 (0x0010 - 0x0000)
struct FSBZSkipIntroSequenceData final
{
public:
	TArray<bool>                                  SkipArray;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSkipIntroSequenceData) == 0x000008, "Wrong alignment on FSBZSkipIntroSequenceData");
static_assert(sizeof(FSBZSkipIntroSequenceData) == 0x000010, "Wrong size on FSBZSkipIntroSequenceData");
static_assert(offsetof(FSBZSkipIntroSequenceData, SkipArray) == 0x000000, "Member 'FSBZSkipIntroSequenceData::SkipArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPurchasedWeaponPartAttachment
// 0x0020 (0x0020 - 0x0000)
struct FSBZPurchasedWeaponPartAttachment final
{
public:
	class FString                                 WeaponPartAttachmentSku;                           // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  BaseWeaponEntitlementId;                           // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPurchasedWeaponPartAttachment) == 0x000008, "Wrong alignment on FSBZPurchasedWeaponPartAttachment");
static_assert(sizeof(FSBZPurchasedWeaponPartAttachment) == 0x000020, "Wrong size on FSBZPurchasedWeaponPartAttachment");
static_assert(offsetof(FSBZPurchasedWeaponPartAttachment, WeaponPartAttachmentSku) == 0x000000, "Member 'FSBZPurchasedWeaponPartAttachment::WeaponPartAttachmentSku' has a wrong offset!");
static_assert(offsetof(FSBZPurchasedWeaponPartAttachment, BaseWeaponEntitlementId) == 0x000010, "Member 'FSBZPurchasedWeaponPartAttachment::BaseWeaponEntitlementId' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeaponPartAttachmentData
// 0x0010 (0x0010 - 0x0000)
struct FSBZWeaponPartAttachmentData final
{
public:
	TArray<struct FSBZPurchasedWeaponPartAttachment> PurchasedWeaponPartAttachmentArray;             // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWeaponPartAttachmentData) == 0x000008, "Wrong alignment on FSBZWeaponPartAttachmentData");
static_assert(sizeof(FSBZWeaponPartAttachmentData) == 0x000010, "Wrong size on FSBZWeaponPartAttachmentData");
static_assert(offsetof(FSBZWeaponPartAttachmentData, PurchasedWeaponPartAttachmentArray) == 0x000000, "Member 'FSBZWeaponPartAttachmentData::PurchasedWeaponPartAttachmentArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZProgressionSaveGameData
// 0x03D0 (0x03D0 - 0x0000)
struct FSBZProgressionSaveGameData final
{
public:
	struct FPD3PlayerLoadout                      Loadout;                                           // 0x0000(0x01C0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 ActiveLoadoutIndexPlatformArray;                   // 0x01C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSBZPlayerLoadoutConfigArray           PlayerLoadoutConfigArray;                          // 0x01D0(0x0010)(Edit, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FSBZPlayerLoadoutConfigArray>   PlayerLoadoutConfigPerPlatformArray;               // 0x01E0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FSBZPlayerCosmeticsConfig>      PlayerCosmeticsConfigPerPlatformArray;             // 0x01F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FSBZPreferredPlayerCharacterArray> PreferredPlayerCharacterPerPlatformArray;       // 0x0200(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class USBZPlayerCharacterData*>        PlayerPreferredCharacterArray;                     // 0x0210(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSBZItemConfigInventorySaveData        ItemConfigInventorySaveData;                       // 0x0220(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FSBZArmorConfigInventorySaveData       ArmorConfigInventorySaveData;                      // 0x0260(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FSBZMaskConfigInventorySaveData        MaskConfigInventorySaveData;                       // 0x0280(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FSBZSuitConfigInventorySaveData        SuitConfigInventorySaveData;                       // 0x02A0(0x0020)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FSBZGloveConfigInventorySaveData       GloveConfigInventorySaveData;                      // 0x02C0(0x0020)(Edit, EditConst, NativeAccessSpecifierPublic)
	class FString                                 ResearchMarker;                                    // 0x02E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, int32>                    CurrentRequestedPriceProgressionLevel;             // 0x02F0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int64                                         LastTimeEventCheck;                                // 0x0340(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSBZInfamySaveData                     InfamySaveData;                                    // 0x0348(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 StoryProgressionArray;                             // 0x0350(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSBZSkipIntroSequenceData>      SkipIntroSequenceArray;                            // 0x0360(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSBZWeaponPartAttachmentData           WeaponPartAttachmentData;                          // 0x0370(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSBZRecommendedChallengeBlock> RecommendedChallengeBlockMap;          // 0x0380(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZProgressionSaveGameData) == 0x000008, "Wrong alignment on FSBZProgressionSaveGameData");
static_assert(sizeof(FSBZProgressionSaveGameData) == 0x0003D0, "Wrong size on FSBZProgressionSaveGameData");
static_assert(offsetof(FSBZProgressionSaveGameData, Loadout) == 0x000000, "Member 'FSBZProgressionSaveGameData::Loadout' has a wrong offset!");
static_assert(offsetof(FSBZProgressionSaveGameData, ActiveLoadoutIndexPlatformArray) == 0x0001C0, "Member 'FSBZProgressionSaveGameData::ActiveLoadoutIndexPlatformArray' has a wrong offset!");
static_assert(offsetof(FSBZProgressionSaveGameData, PlayerLoadoutConfigArray) == 0x0001D0, "Member 'FSBZProgressionSaveGameData::PlayerLoadoutConfigArray' has a wrong offset!");
static_assert(offsetof(FSBZProgressionSaveGameData, PlayerLoadoutConfigPerPlatformArray) == 0x0001E0, "Member 'FSBZProgressionSaveGameData::PlayerLoadoutConfigPerPlatformArray' has a wrong offset!");
static_assert(offsetof(FSBZProgressionSaveGameData, PlayerCosmeticsConfigPerPlatformArray) == 0x0001F0, "Member 'FSBZProgressionSaveGameData::PlayerCosmeticsConfigPerPlatformArray' has a wrong offset!");
static_assert(offsetof(FSBZProgressionSaveGameData, PreferredPlayerCharacterPerPlatformArray) == 0x000200, "Member 'FSBZProgressionSaveGameData::PreferredPlayerCharacterPerPlatformArray' has a wrong offset!");
static_assert(offsetof(FSBZProgressionSaveGameData, PlayerPreferredCharacterArray) == 0x000210, "Member 'FSBZProgressionSaveGameData::PlayerPreferredCharacterArray' has a wrong offset!");
static_assert(offsetof(FSBZProgressionSaveGameData, ItemConfigInventorySaveData) == 0x000220, "Member 'FSBZProgressionSaveGameData::ItemConfigInventorySaveData' has a wrong offset!");
static_assert(offsetof(FSBZProgressionSaveGameData, ArmorConfigInventorySaveData) == 0x000260, "Member 'FSBZProgressionSaveGameData::ArmorConfigInventorySaveData' has a wrong offset!");
static_assert(offsetof(FSBZProgressionSaveGameData, MaskConfigInventorySaveData) == 0x000280, "Member 'FSBZProgressionSaveGameData::MaskConfigInventorySaveData' has a wrong offset!");
static_assert(offsetof(FSBZProgressionSaveGameData, SuitConfigInventorySaveData) == 0x0002A0, "Member 'FSBZProgressionSaveGameData::SuitConfigInventorySaveData' has a wrong offset!");
static_assert(offsetof(FSBZProgressionSaveGameData, GloveConfigInventorySaveData) == 0x0002C0, "Member 'FSBZProgressionSaveGameData::GloveConfigInventorySaveData' has a wrong offset!");
static_assert(offsetof(FSBZProgressionSaveGameData, ResearchMarker) == 0x0002E0, "Member 'FSBZProgressionSaveGameData::ResearchMarker' has a wrong offset!");
static_assert(offsetof(FSBZProgressionSaveGameData, CurrentRequestedPriceProgressionLevel) == 0x0002F0, "Member 'FSBZProgressionSaveGameData::CurrentRequestedPriceProgressionLevel' has a wrong offset!");
static_assert(offsetof(FSBZProgressionSaveGameData, LastTimeEventCheck) == 0x000340, "Member 'FSBZProgressionSaveGameData::LastTimeEventCheck' has a wrong offset!");
static_assert(offsetof(FSBZProgressionSaveGameData, InfamySaveData) == 0x000348, "Member 'FSBZProgressionSaveGameData::InfamySaveData' has a wrong offset!");
static_assert(offsetof(FSBZProgressionSaveGameData, StoryProgressionArray) == 0x000350, "Member 'FSBZProgressionSaveGameData::StoryProgressionArray' has a wrong offset!");
static_assert(offsetof(FSBZProgressionSaveGameData, SkipIntroSequenceArray) == 0x000360, "Member 'FSBZProgressionSaveGameData::SkipIntroSequenceArray' has a wrong offset!");
static_assert(offsetof(FSBZProgressionSaveGameData, WeaponPartAttachmentData) == 0x000370, "Member 'FSBZProgressionSaveGameData::WeaponPartAttachmentData' has a wrong offset!");
static_assert(offsetof(FSBZProgressionSaveGameData, RecommendedChallengeBlockMap) == 0x000380, "Member 'FSBZProgressionSaveGameData::RecommendedChallengeBlockMap' has a wrong offset!");

// ScriptStruct Starbreeze.SBZVotingMsgArgs
// 0x0068 (0x0068 - 0x0000)
struct alignas(0x08) FSBZVotingMsgArgs final
{
public:
	uint8                                         Pad_0[0x68];                                       // 0x0000(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZVotingMsgArgs) == 0x000008, "Wrong alignment on FSBZVotingMsgArgs");
static_assert(sizeof(FSBZVotingMsgArgs) == 0x000068, "Wrong size on FSBZVotingMsgArgs");

// ScriptStruct Starbreeze.SBZDamageMultiplierDistance
// 0x0008 (0x0008 - 0x0000)
struct FSBZDamageMultiplierDistance final
{
public:
	float                                         Multiplier;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZDamageMultiplierDistance) == 0x000004, "Wrong alignment on FSBZDamageMultiplierDistance");
static_assert(sizeof(FSBZDamageMultiplierDistance) == 0x000008, "Wrong size on FSBZDamageMultiplierDistance");
static_assert(offsetof(FSBZDamageMultiplierDistance, Multiplier) == 0x000000, "Member 'FSBZDamageMultiplierDistance::Multiplier' has a wrong offset!");
static_assert(offsetof(FSBZDamageMultiplierDistance, Distance) == 0x000004, "Member 'FSBZDamageMultiplierDistance::Distance' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSavedArmorConfig
// 0x0030 (0x0030 - 0x0000)
struct FSBZSavedArmorConfig final
{
public:
	struct FGuid                                  ArmorEntitlementId;                                // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSBZArmorConfig                        ArmorConfig;                                       // 0x0010(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSavedArmorConfig) == 0x000008, "Wrong alignment on FSBZSavedArmorConfig");
static_assert(sizeof(FSBZSavedArmorConfig) == 0x000030, "Wrong size on FSBZSavedArmorConfig");
static_assert(offsetof(FSBZSavedArmorConfig, ArmorEntitlementId) == 0x000000, "Member 'FSBZSavedArmorConfig::ArmorEntitlementId' has a wrong offset!");
static_assert(offsetof(FSBZSavedArmorConfig, ArmorConfig) == 0x000010, "Member 'FSBZSavedArmorConfig::ArmorConfig' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPropDamagePool
// 0x0058 (0x0058 - 0x0000)
struct FSBZPropDamagePool final
{
public:
	struct FSBZComponentSelector                  PrimitiveComponent;                                // 0x0000(0x0020)(Edit, RepSkip, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  DamageTypeTags;                                    // 0x0020(0x0020)(Edit, RepSkip, NativeAccessSpecifierPublic)
	float                                         MaxHealth;                                         // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxHits;                                           // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Health;                                            // 0x0048(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hits;                                              // 0x004C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RejectDamage;                                      // 0x0050(0x0004)(ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RejectHits;                                        // 0x0054(0x0004)(ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZPropDamagePool) == 0x000008, "Wrong alignment on FSBZPropDamagePool");
static_assert(sizeof(FSBZPropDamagePool) == 0x000058, "Wrong size on FSBZPropDamagePool");
static_assert(offsetof(FSBZPropDamagePool, PrimitiveComponent) == 0x000000, "Member 'FSBZPropDamagePool::PrimitiveComponent' has a wrong offset!");
static_assert(offsetof(FSBZPropDamagePool, DamageTypeTags) == 0x000020, "Member 'FSBZPropDamagePool::DamageTypeTags' has a wrong offset!");
static_assert(offsetof(FSBZPropDamagePool, MaxHealth) == 0x000040, "Member 'FSBZPropDamagePool::MaxHealth' has a wrong offset!");
static_assert(offsetof(FSBZPropDamagePool, MaxHits) == 0x000044, "Member 'FSBZPropDamagePool::MaxHits' has a wrong offset!");
static_assert(offsetof(FSBZPropDamagePool, Health) == 0x000048, "Member 'FSBZPropDamagePool::Health' has a wrong offset!");
static_assert(offsetof(FSBZPropDamagePool, Hits) == 0x00004C, "Member 'FSBZPropDamagePool::Hits' has a wrong offset!");
static_assert(offsetof(FSBZPropDamagePool, RejectDamage) == 0x000050, "Member 'FSBZPropDamagePool::RejectDamage' has a wrong offset!");
static_assert(offsetof(FSBZPropDamagePool, RejectHits) == 0x000054, "Member 'FSBZPropDamagePool::RejectHits' has a wrong offset!");

// ScriptStruct Starbreeze.SBZRagdollInfo
// 0x0038 (0x0038 - 0x0000)
struct FSBZRagdollInfo final
{
public:
	class ASBZCharacter*                          Character;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector_NetQuantize                    ServerHipsLocation;                                // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                ClientHipsLocation;                                // 0x0014(0x000C)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                PrevClientHipsLocation;                            // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MotionlessTimer;                                   // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        NetID;                                             // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bIsCharacterInitialized : 1;                       // 0x0034(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bIsServerHipsLocationValid : 1;                    // 0x0034(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZRagdollInfo) == 0x000008, "Wrong alignment on FSBZRagdollInfo");
static_assert(sizeof(FSBZRagdollInfo) == 0x000038, "Wrong size on FSBZRagdollInfo");
static_assert(offsetof(FSBZRagdollInfo, Character) == 0x000000, "Member 'FSBZRagdollInfo::Character' has a wrong offset!");
static_assert(offsetof(FSBZRagdollInfo, ServerHipsLocation) == 0x000008, "Member 'FSBZRagdollInfo::ServerHipsLocation' has a wrong offset!");
static_assert(offsetof(FSBZRagdollInfo, ClientHipsLocation) == 0x000014, "Member 'FSBZRagdollInfo::ClientHipsLocation' has a wrong offset!");
static_assert(offsetof(FSBZRagdollInfo, PrevClientHipsLocation) == 0x000020, "Member 'FSBZRagdollInfo::PrevClientHipsLocation' has a wrong offset!");
static_assert(offsetof(FSBZRagdollInfo, MotionlessTimer) == 0x00002C, "Member 'FSBZRagdollInfo::MotionlessTimer' has a wrong offset!");
static_assert(offsetof(FSBZRagdollInfo, NetID) == 0x000030, "Member 'FSBZRagdollInfo::NetID' has a wrong offset!");

// ScriptStruct Starbreeze.SBZHackableInfoActorCollection
// 0x0010 (0x0010 - 0x0000)
struct FSBZHackableInfoActorCollection final
{
public:
	TArray<class ASBZHackableInfoActor*>          Array;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZHackableInfoActorCollection) == 0x000008, "Wrong alignment on FSBZHackableInfoActorCollection");
static_assert(sizeof(FSBZHackableInfoActorCollection) == 0x000010, "Wrong size on FSBZHackableInfoActorCollection");
static_assert(offsetof(FSBZHackableInfoActorCollection, Array) == 0x000000, "Member 'FSBZHackableInfoActorCollection::Array' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeaponSpread
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FSBZWeaponSpread final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZWeaponSpread) == 0x000004, "Wrong alignment on FSBZWeaponSpread");
static_assert(sizeof(FSBZWeaponSpread) == 0x000008, "Wrong size on FSBZWeaponSpread");

// ScriptStruct Starbreeze.SBZCameraDOF
// 0x0014 (0x0014 - 0x0000)
struct FSBZCameraDOF final
{
public:
	bool                                          bUseStaticFocalDistance;                           // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DepthOfFieldFocalDistance;                         // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldFstop;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldDepthBlurAmount;                       // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldDepthBlurRadius;                       // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZCameraDOF) == 0x000004, "Wrong alignment on FSBZCameraDOF");
static_assert(sizeof(FSBZCameraDOF) == 0x000014, "Wrong size on FSBZCameraDOF");
static_assert(offsetof(FSBZCameraDOF, bUseStaticFocalDistance) == 0x000000, "Member 'FSBZCameraDOF::bUseStaticFocalDistance' has a wrong offset!");
static_assert(offsetof(FSBZCameraDOF, DepthOfFieldFocalDistance) == 0x000004, "Member 'FSBZCameraDOF::DepthOfFieldFocalDistance' has a wrong offset!");
static_assert(offsetof(FSBZCameraDOF, DepthOfFieldFstop) == 0x000008, "Member 'FSBZCameraDOF::DepthOfFieldFstop' has a wrong offset!");
static_assert(offsetof(FSBZCameraDOF, DepthOfFieldDepthBlurAmount) == 0x00000C, "Member 'FSBZCameraDOF::DepthOfFieldDepthBlurAmount' has a wrong offset!");
static_assert(offsetof(FSBZCameraDOF, DepthOfFieldDepthBlurRadius) == 0x000010, "Member 'FSBZCameraDOF::DepthOfFieldDepthBlurRadius' has a wrong offset!");

// ScriptStruct Starbreeze.SBZRappellingRopeSettings
// 0x0108 (0x0108 - 0x0000)
struct FSBZRappellingRopeSettings final
{
public:
	TSubclassOf<class ASBZRappellingRope>         RappellingRopeClassToSpawn;                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DespawnDelay;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachStart;                                      // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSBZCablePointAttachment               StartAttachment;                                   // 0x0010(0x0068)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FSBZCablePointAttachment>       PointAttachments;                                  // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bAttachEnd;                                        // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSBZCablePointAttachment               EndAttachment;                                     // 0x0090(0x0068)(Edit, NativeAccessSpecifierPublic)
	bool                                          bEnableCollisionPlane;                             // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableStiffness;                                  // 0x00F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FA[0x2];                                       // 0x00FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinSegmentLength;                                  // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSegmentCount;                                   // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZRappellingRopeSettings) == 0x000008, "Wrong alignment on FSBZRappellingRopeSettings");
static_assert(sizeof(FSBZRappellingRopeSettings) == 0x000108, "Wrong size on FSBZRappellingRopeSettings");
static_assert(offsetof(FSBZRappellingRopeSettings, RappellingRopeClassToSpawn) == 0x000000, "Member 'FSBZRappellingRopeSettings::RappellingRopeClassToSpawn' has a wrong offset!");
static_assert(offsetof(FSBZRappellingRopeSettings, DespawnDelay) == 0x000008, "Member 'FSBZRappellingRopeSettings::DespawnDelay' has a wrong offset!");
static_assert(offsetof(FSBZRappellingRopeSettings, bAttachStart) == 0x00000C, "Member 'FSBZRappellingRopeSettings::bAttachStart' has a wrong offset!");
static_assert(offsetof(FSBZRappellingRopeSettings, StartAttachment) == 0x000010, "Member 'FSBZRappellingRopeSettings::StartAttachment' has a wrong offset!");
static_assert(offsetof(FSBZRappellingRopeSettings, PointAttachments) == 0x000078, "Member 'FSBZRappellingRopeSettings::PointAttachments' has a wrong offset!");
static_assert(offsetof(FSBZRappellingRopeSettings, bAttachEnd) == 0x000088, "Member 'FSBZRappellingRopeSettings::bAttachEnd' has a wrong offset!");
static_assert(offsetof(FSBZRappellingRopeSettings, EndAttachment) == 0x000090, "Member 'FSBZRappellingRopeSettings::EndAttachment' has a wrong offset!");
static_assert(offsetof(FSBZRappellingRopeSettings, bEnableCollisionPlane) == 0x0000F8, "Member 'FSBZRappellingRopeSettings::bEnableCollisionPlane' has a wrong offset!");
static_assert(offsetof(FSBZRappellingRopeSettings, bEnableStiffness) == 0x0000F9, "Member 'FSBZRappellingRopeSettings::bEnableStiffness' has a wrong offset!");
static_assert(offsetof(FSBZRappellingRopeSettings, MinSegmentLength) == 0x0000FC, "Member 'FSBZRappellingRopeSettings::MinSegmentLength' has a wrong offset!");
static_assert(offsetof(FSBZRappellingRopeSettings, MaxSegmentCount) == 0x000100, "Member 'FSBZRappellingRopeSettings::MaxSegmentCount' has a wrong offset!");

// ScriptStruct Starbreeze.SBZReactionData
// 0x0001 (0x0001 - 0x0000)
struct FSBZReactionData final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZReactionData) == 0x000001, "Wrong alignment on FSBZReactionData");
static_assert(sizeof(FSBZReactionData) == 0x000001, "Wrong size on FSBZReactionData");

// ScriptStruct Starbreeze.SBZReconnectPlayerStateData
// 0x02F0 (0x02F0 - 0x0000)
struct FSBZReconnectPlayerStateData final
{
public:
	struct FUniqueNetIdRepl                       UniqueId;                                          // 0x0000(0x0028)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SavedNetworkAddress;                               // 0x0028(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0038(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerId;                                          // 0x0048(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSBZReconnectPlayerStateLoadoutData    Loadout;                                           // 0x0050(0x0070)(Transient, NativeAccessSpecifierPublic)
	struct FSBZPlayerEndMissionResultData         ResultData;                                        // 0x00C0(0x01B0)(Transient, NativeAccessSpecifierPublic)
	int32                                         CiviliansKilledBeforeCustody;                      // 0x0270(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ServerSentryKillCount;                             // 0x0274(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkillTankDisengageActivatedTimeSeconds;            // 0x0278(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnforcerSkillKillCount;                            // 0x027C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnforcerSkillLastKillTime;                         // 0x0280(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnforcerAcedSkillKillCount;                        // 0x0284(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverkillWeaponProgress;                            // 0x0288(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMaskOn;                                         // 0x028C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28D[0x3];                                      // 0x028D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpectateDurationModification;                      // 0x0290(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReducedCustodyTime;                                // 0x0294(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpectateTime;                                      // 0x0298(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CustodyCount;                                      // 0x029C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CustodyReleaseCost;                                // 0x02A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentTradeReduction;                             // 0x02A4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bServerIsHardBargainCustody;                       // 0x02A8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsARGESRestorationActivatable;                    // 0x02A9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOverkillEnabled;                                // 0x02AA(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPD3DefeatState                               DefeatState;                                       // 0x02AB(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLastArrestedByGuard;                            // 0x02AC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AD[0x3];                                      // 0x02AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 BuffTimeArray;                                     // 0x02B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<uint8>                                 BuffBlockCountArray;                               // 0x02C0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<float>                                 BuffBlockCooldownTimeArray;                        // 0x02D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	float                                         RepairArmorInteractionImmuneTime;                  // 0x02E0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSkillTankLastManStandingBlocking;               // 0x02E4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E5[0x3];                                      // 0x02E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SkillTankLastManStandingImmuneTime;                // 0x02E8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZReconnectPlayerStateData) == 0x000008, "Wrong alignment on FSBZReconnectPlayerStateData");
static_assert(sizeof(FSBZReconnectPlayerStateData) == 0x0002F0, "Wrong size on FSBZReconnectPlayerStateData");
static_assert(offsetof(FSBZReconnectPlayerStateData, UniqueId) == 0x000000, "Member 'FSBZReconnectPlayerStateData::UniqueId' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateData, SavedNetworkAddress) == 0x000028, "Member 'FSBZReconnectPlayerStateData::SavedNetworkAddress' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateData, Name) == 0x000038, "Member 'FSBZReconnectPlayerStateData::Name' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateData, PlayerId) == 0x000048, "Member 'FSBZReconnectPlayerStateData::PlayerId' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateData, Loadout) == 0x000050, "Member 'FSBZReconnectPlayerStateData::Loadout' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateData, ResultData) == 0x0000C0, "Member 'FSBZReconnectPlayerStateData::ResultData' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateData, CiviliansKilledBeforeCustody) == 0x000270, "Member 'FSBZReconnectPlayerStateData::CiviliansKilledBeforeCustody' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateData, ServerSentryKillCount) == 0x000274, "Member 'FSBZReconnectPlayerStateData::ServerSentryKillCount' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateData, SkillTankDisengageActivatedTimeSeconds) == 0x000278, "Member 'FSBZReconnectPlayerStateData::SkillTankDisengageActivatedTimeSeconds' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateData, EnforcerSkillKillCount) == 0x00027C, "Member 'FSBZReconnectPlayerStateData::EnforcerSkillKillCount' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateData, EnforcerSkillLastKillTime) == 0x000280, "Member 'FSBZReconnectPlayerStateData::EnforcerSkillLastKillTime' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateData, EnforcerAcedSkillKillCount) == 0x000284, "Member 'FSBZReconnectPlayerStateData::EnforcerAcedSkillKillCount' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateData, OverkillWeaponProgress) == 0x000288, "Member 'FSBZReconnectPlayerStateData::OverkillWeaponProgress' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateData, bIsMaskOn) == 0x00028C, "Member 'FSBZReconnectPlayerStateData::bIsMaskOn' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateData, SpectateDurationModification) == 0x000290, "Member 'FSBZReconnectPlayerStateData::SpectateDurationModification' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateData, ReducedCustodyTime) == 0x000294, "Member 'FSBZReconnectPlayerStateData::ReducedCustodyTime' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateData, SpectateTime) == 0x000298, "Member 'FSBZReconnectPlayerStateData::SpectateTime' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateData, CustodyCount) == 0x00029C, "Member 'FSBZReconnectPlayerStateData::CustodyCount' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateData, CustodyReleaseCost) == 0x0002A0, "Member 'FSBZReconnectPlayerStateData::CustodyReleaseCost' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateData, CurrentTradeReduction) == 0x0002A4, "Member 'FSBZReconnectPlayerStateData::CurrentTradeReduction' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateData, bServerIsHardBargainCustody) == 0x0002A8, "Member 'FSBZReconnectPlayerStateData::bServerIsHardBargainCustody' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateData, bIsARGESRestorationActivatable) == 0x0002A9, "Member 'FSBZReconnectPlayerStateData::bIsARGESRestorationActivatable' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateData, bIsOverkillEnabled) == 0x0002AA, "Member 'FSBZReconnectPlayerStateData::bIsOverkillEnabled' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateData, DefeatState) == 0x0002AB, "Member 'FSBZReconnectPlayerStateData::DefeatState' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateData, bIsLastArrestedByGuard) == 0x0002AC, "Member 'FSBZReconnectPlayerStateData::bIsLastArrestedByGuard' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateData, BuffTimeArray) == 0x0002B0, "Member 'FSBZReconnectPlayerStateData::BuffTimeArray' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateData, BuffBlockCountArray) == 0x0002C0, "Member 'FSBZReconnectPlayerStateData::BuffBlockCountArray' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateData, BuffBlockCooldownTimeArray) == 0x0002D0, "Member 'FSBZReconnectPlayerStateData::BuffBlockCooldownTimeArray' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateData, RepairArmorInteractionImmuneTime) == 0x0002E0, "Member 'FSBZReconnectPlayerStateData::RepairArmorInteractionImmuneTime' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateData, bIsSkillTankLastManStandingBlocking) == 0x0002E4, "Member 'FSBZReconnectPlayerStateData::bIsSkillTankLastManStandingBlocking' has a wrong offset!");
static_assert(offsetof(FSBZReconnectPlayerStateData, SkillTankLastManStandingImmuneTime) == 0x0002E8, "Member 'FSBZReconnectPlayerStateData::SkillTankLastManStandingImmuneTime' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCombinedReloadState
// 0x0003 (0x0003 - 0x0000)
struct FSBZCombinedReloadState final
{
public:
	ESBZReloadState                               State;                                             // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEmptyCycleNeeded;                               // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCycleNeeded;                                    // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZCombinedReloadState) == 0x000001, "Wrong alignment on FSBZCombinedReloadState");
static_assert(sizeof(FSBZCombinedReloadState) == 0x000003, "Wrong size on FSBZCombinedReloadState");
static_assert(offsetof(FSBZCombinedReloadState, State) == 0x000000, "Member 'FSBZCombinedReloadState::State' has a wrong offset!");
static_assert(offsetof(FSBZCombinedReloadState, bIsEmptyCycleNeeded) == 0x000001, "Member 'FSBZCombinedReloadState::bIsEmptyCycleNeeded' has a wrong offset!");
static_assert(offsetof(FSBZCombinedReloadState, bIsCycleNeeded) == 0x000002, "Member 'FSBZCombinedReloadState::bIsCycleNeeded' has a wrong offset!");

// ScriptStruct Starbreeze.SBZReloadTargetData
// 0x0008 (0x0010 - 0x0008)
struct FSBZReloadTargetData final : public FGameplayAbilityTargetData
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZReloadTargetData) == 0x000008, "Wrong alignment on FSBZReloadTargetData");
static_assert(sizeof(FSBZReloadTargetData) == 0x000010, "Wrong size on FSBZReloadTargetData");

// ScriptStruct Starbreeze.SBZReplayEventInfo
// 0x0020 (0x0020 - 0x0000)
struct FSBZReplayEventInfo final
{
public:
	ESBZReplayEvent                               EventGroup;                                        // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MetaData;                                          // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Percent;                                           // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZReplayEventInfo) == 0x000008, "Wrong alignment on FSBZReplayEventInfo");
static_assert(sizeof(FSBZReplayEventInfo) == 0x000020, "Wrong size on FSBZReplayEventInfo");
static_assert(offsetof(FSBZReplayEventInfo, EventGroup) == 0x000000, "Member 'FSBZReplayEventInfo::EventGroup' has a wrong offset!");
static_assert(offsetof(FSBZReplayEventInfo, MetaData) == 0x000008, "Member 'FSBZReplayEventInfo::MetaData' has a wrong offset!");
static_assert(offsetof(FSBZReplayEventInfo, Time) == 0x000018, "Member 'FSBZReplayEventInfo::Time' has a wrong offset!");
static_assert(offsetof(FSBZReplayEventInfo, Percent) == 0x00001C, "Member 'FSBZReplayEventInfo::Percent' has a wrong offset!");

// ScriptStruct Starbreeze.SBZReplayInfo
// 0x0060 (0x0060 - 0x0000)
struct FSBZReplayInfo final
{
public:
	int32                                         LevelIdx;                                          // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReplayName;                                        // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FriendlyName;                                      // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              Timestamp;                                         // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LengthInMS;                                        // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsValid;                                          // 0x0034(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReplayDisplayTotalTime;                            // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReplayDisplayCreationTime;                         // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChangeList;                                        // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZReplayInfo) == 0x000008, "Wrong alignment on FSBZReplayInfo");
static_assert(sizeof(FSBZReplayInfo) == 0x000060, "Wrong size on FSBZReplayInfo");
static_assert(offsetof(FSBZReplayInfo, LevelIdx) == 0x000000, "Member 'FSBZReplayInfo::LevelIdx' has a wrong offset!");
static_assert(offsetof(FSBZReplayInfo, ReplayName) == 0x000008, "Member 'FSBZReplayInfo::ReplayName' has a wrong offset!");
static_assert(offsetof(FSBZReplayInfo, FriendlyName) == 0x000018, "Member 'FSBZReplayInfo::FriendlyName' has a wrong offset!");
static_assert(offsetof(FSBZReplayInfo, Timestamp) == 0x000028, "Member 'FSBZReplayInfo::Timestamp' has a wrong offset!");
static_assert(offsetof(FSBZReplayInfo, LengthInMS) == 0x000030, "Member 'FSBZReplayInfo::LengthInMS' has a wrong offset!");
static_assert(offsetof(FSBZReplayInfo, bIsValid) == 0x000034, "Member 'FSBZReplayInfo::bIsValid' has a wrong offset!");
static_assert(offsetof(FSBZReplayInfo, ReplayDisplayTotalTime) == 0x000038, "Member 'FSBZReplayInfo::ReplayDisplayTotalTime' has a wrong offset!");
static_assert(offsetof(FSBZReplayInfo, ReplayDisplayCreationTime) == 0x000048, "Member 'FSBZReplayInfo::ReplayDisplayCreationTime' has a wrong offset!");
static_assert(offsetof(FSBZReplayInfo, ChangeList) == 0x000058, "Member 'FSBZReplayInfo::ChangeList' has a wrong offset!");

// ScriptStruct Starbreeze.SBZEquippableState
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FSBZEquippableState final
{
public:
	bool                                          bIsBuildup;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FireBuildupScale;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartFireBuildupScale;                             // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0xC];                                        // 0x000C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZEquippableState) == 0x000008, "Wrong alignment on FSBZEquippableState");
static_assert(sizeof(FSBZEquippableState) == 0x000018, "Wrong size on FSBZEquippableState");
static_assert(offsetof(FSBZEquippableState, bIsBuildup) == 0x000000, "Member 'FSBZEquippableState::bIsBuildup' has a wrong offset!");
static_assert(offsetof(FSBZEquippableState, FireBuildupScale) == 0x000004, "Member 'FSBZEquippableState::FireBuildupScale' has a wrong offset!");
static_assert(offsetof(FSBZEquippableState, StartFireBuildupScale) == 0x000008, "Member 'FSBZEquippableState::StartFireBuildupScale' has a wrong offset!");

// ScriptStruct Starbreeze.SBZReplicatedEquippableState
// 0x0048 (0x0048 - 0x0000)
struct FSBZReplicatedEquippableState final
{
public:
	struct FSBZEquippableState                    Array[0x3];                                        // 0x0000(0x0018)(Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZReplicatedEquippableState) == 0x000008, "Wrong alignment on FSBZReplicatedEquippableState");
static_assert(sizeof(FSBZReplicatedEquippableState) == 0x000048, "Wrong size on FSBZReplicatedEquippableState");
static_assert(offsetof(FSBZReplicatedEquippableState, Array) == 0x000000, "Member 'FSBZReplicatedEquippableState::Array' has a wrong offset!");

// ScriptStruct Starbreeze.SBZReplicatedReloadState
// 0x000B (0x000B - 0x0000)
struct FSBZReplicatedReloadState final
{
public:
	struct FSBZCombinedReloadState                Array[0x3];                                        // 0x0000(0x0003)(Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsPlaying;                                        // 0x0009(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPlayingEmptyCycleNeeded;                        // 0x000A(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZReplicatedReloadState) == 0x000001, "Wrong alignment on FSBZReplicatedReloadState");
static_assert(sizeof(FSBZReplicatedReloadState) == 0x00000B, "Wrong size on FSBZReplicatedReloadState");
static_assert(offsetof(FSBZReplicatedReloadState, Array) == 0x000000, "Member 'FSBZReplicatedReloadState::Array' has a wrong offset!");
static_assert(offsetof(FSBZReplicatedReloadState, bIsPlaying) == 0x000009, "Member 'FSBZReplicatedReloadState::bIsPlaying' has a wrong offset!");
static_assert(offsetof(FSBZReplicatedReloadState, bIsPlayingEmptyCycleNeeded) == 0x00000A, "Member 'FSBZReplicatedReloadState::bIsPlayingEmptyCycleNeeded' has a wrong offset!");

// ScriptStruct Starbreeze.SBZConfigRepClass
// 0x0024 (0x0024 - 0x0000)
struct FSBZConfigRepClass final
{
public:
	class FName                                   Name;                                              // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERepNodeRoutingStrategy                       Type;                                              // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistancePriorityScale;                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StarvationPriorityScale;                           // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CullDistance;                                      // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        ReplicationPeriodFrame;                            // 0x001C(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        FastPath_ReplicationPeriodFrame;                   // 0x001E(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        ActorChannelFrameTimeout;                          // 0x0020(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bMustReplicateOnInitialFrame : 1;                  // 0x0022(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_23[0x1];                                       // 0x0023(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZConfigRepClass) == 0x000004, "Wrong alignment on FSBZConfigRepClass");
static_assert(sizeof(FSBZConfigRepClass) == 0x000024, "Wrong size on FSBZConfigRepClass");
static_assert(offsetof(FSBZConfigRepClass, Name) == 0x000000, "Member 'FSBZConfigRepClass::Name' has a wrong offset!");
static_assert(offsetof(FSBZConfigRepClass, Type) == 0x00000C, "Member 'FSBZConfigRepClass::Type' has a wrong offset!");
static_assert(offsetof(FSBZConfigRepClass, DistancePriorityScale) == 0x000010, "Member 'FSBZConfigRepClass::DistancePriorityScale' has a wrong offset!");
static_assert(offsetof(FSBZConfigRepClass, StarvationPriorityScale) == 0x000014, "Member 'FSBZConfigRepClass::StarvationPriorityScale' has a wrong offset!");
static_assert(offsetof(FSBZConfigRepClass, CullDistance) == 0x000018, "Member 'FSBZConfigRepClass::CullDistance' has a wrong offset!");
static_assert(offsetof(FSBZConfigRepClass, ReplicationPeriodFrame) == 0x00001C, "Member 'FSBZConfigRepClass::ReplicationPeriodFrame' has a wrong offset!");
static_assert(offsetof(FSBZConfigRepClass, FastPath_ReplicationPeriodFrame) == 0x00001E, "Member 'FSBZConfigRepClass::FastPath_ReplicationPeriodFrame' has a wrong offset!");
static_assert(offsetof(FSBZConfigRepClass, ActorChannelFrameTimeout) == 0x000020, "Member 'FSBZConfigRepClass::ActorChannelFrameTimeout' has a wrong offset!");

// ScriptStruct Starbreeze.SBZRevertDamageAttributeSetData
// 0x0018 (0x0018 - 0x0000)
struct FSBZRevertDamageAttributeSetData final
{
public:
	class APawn*                                  Pawn;                                              // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint8>                                 ByteArray;                                         // 0x0008(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZRevertDamageAttributeSetData) == 0x000008, "Wrong alignment on FSBZRevertDamageAttributeSetData");
static_assert(sizeof(FSBZRevertDamageAttributeSetData) == 0x000018, "Wrong size on FSBZRevertDamageAttributeSetData");
static_assert(offsetof(FSBZRevertDamageAttributeSetData, Pawn) == 0x000000, "Member 'FSBZRevertDamageAttributeSetData::Pawn' has a wrong offset!");
static_assert(offsetof(FSBZRevertDamageAttributeSetData, ByteArray) == 0x000008, "Member 'FSBZRevertDamageAttributeSetData::ByteArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZRevertDamageAttributeSetContainer
// 0x0010 (0x0010 - 0x0000)
struct FSBZRevertDamageAttributeSetContainer final
{
public:
	TArray<struct FSBZRevertDamageAttributeSetData> AttributeSetDataArray;                           // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FSBZRevertDamageAttributeSetContainer) == 0x000008, "Wrong alignment on FSBZRevertDamageAttributeSetContainer");
static_assert(sizeof(FSBZRevertDamageAttributeSetContainer) == 0x000010, "Wrong size on FSBZRevertDamageAttributeSetContainer");
static_assert(offsetof(FSBZRevertDamageAttributeSetContainer, AttributeSetDataArray) == 0x000000, "Member 'FSBZRevertDamageAttributeSetContainer::AttributeSetDataArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZRoomPathQuery
// 0x0038 (0x0038 - 0x0000)
struct FSBZRoomPathQuery final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ASBZRoomVolume*                         StartRoom;                                         // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASBZRoomVolume*                         EndRoom;                                           // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Owner;                                             // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZRoomPathQuery) == 0x000008, "Wrong alignment on FSBZRoomPathQuery");
static_assert(sizeof(FSBZRoomPathQuery) == 0x000038, "Wrong size on FSBZRoomPathQuery");
static_assert(offsetof(FSBZRoomPathQuery, StartRoom) == 0x000018, "Member 'FSBZRoomPathQuery::StartRoom' has a wrong offset!");
static_assert(offsetof(FSBZRoomPathQuery, EndRoom) == 0x000020, "Member 'FSBZRoomPathQuery::EndRoom' has a wrong offset!");
static_assert(offsetof(FSBZRoomPathQuery, Owner) == 0x000030, "Member 'FSBZRoomPathQuery::Owner' has a wrong offset!");

// ScriptStruct Starbreeze.SBZRoomPath
// 0x0048 (0x0048 - 0x0000)
struct FSBZRoomPath final
{
public:
	TArray<TScriptInterface<class ISBZRoomConnectorInterface>> Connectors;                           // 0x0000(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class ASBZRoomVolume*>                 Rooms;                                             // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x28];                                      // 0x0020(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZRoomPath) == 0x000008, "Wrong alignment on FSBZRoomPath");
static_assert(sizeof(FSBZRoomPath) == 0x000048, "Wrong size on FSBZRoomPath");
static_assert(offsetof(FSBZRoomPath, Connectors) == 0x000000, "Member 'FSBZRoomPath::Connectors' has a wrong offset!");
static_assert(offsetof(FSBZRoomPath, Rooms) == 0x000010, "Member 'FSBZRoomPath::Rooms' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeaponSpreadStances
// 0x00C0 (0x00C0 - 0x0000)
struct FSBZWeaponSpreadStances final
{
public:
	struct FSBZWeaponSpreadStanceMultipliers      Stand;                                             // 0x0000(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FSBZWeaponSpreadStanceMultipliers      StandMove;                                         // 0x0020(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FSBZWeaponSpreadStanceMultipliers      Crouch;                                            // 0x0040(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FSBZWeaponSpreadStanceMultipliers      CrouchMove;                                        // 0x0060(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FSBZWeaponSpreadStanceMultipliers      Target;                                            // 0x0080(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FSBZWeaponSpreadStanceMultipliers      TargetMove;                                        // 0x00A0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWeaponSpreadStances) == 0x000004, "Wrong alignment on FSBZWeaponSpreadStances");
static_assert(sizeof(FSBZWeaponSpreadStances) == 0x0000C0, "Wrong size on FSBZWeaponSpreadStances");
static_assert(offsetof(FSBZWeaponSpreadStances, Stand) == 0x000000, "Member 'FSBZWeaponSpreadStances::Stand' has a wrong offset!");
static_assert(offsetof(FSBZWeaponSpreadStances, StandMove) == 0x000020, "Member 'FSBZWeaponSpreadStances::StandMove' has a wrong offset!");
static_assert(offsetof(FSBZWeaponSpreadStances, Crouch) == 0x000040, "Member 'FSBZWeaponSpreadStances::Crouch' has a wrong offset!");
static_assert(offsetof(FSBZWeaponSpreadStances, CrouchMove) == 0x000060, "Member 'FSBZWeaponSpreadStances::CrouchMove' has a wrong offset!");
static_assert(offsetof(FSBZWeaponSpreadStances, Target) == 0x000080, "Member 'FSBZWeaponSpreadStances::Target' has a wrong offset!");
static_assert(offsetof(FSBZWeaponSpreadStances, TargetMove) == 0x0000A0, "Member 'FSBZWeaponSpreadStances::TargetMove' has a wrong offset!");

// ScriptStruct Starbreeze.SBZNode
// 0x0040 (0x0040 - 0x0000)
struct FSBZNode final
{
public:
	TScriptInterface<class ISBZRoomConnectorInterface> Connector;                                    // 0x0000(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class ASBZRoomVolume*                         Room;                                              // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x28];                                      // 0x0018(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZNode) == 0x000008, "Wrong alignment on FSBZNode");
static_assert(sizeof(FSBZNode) == 0x000040, "Wrong size on FSBZNode");
static_assert(offsetof(FSBZNode, Connector) == 0x000000, "Member 'FSBZNode::Connector' has a wrong offset!");
static_assert(offsetof(FSBZNode, Room) == 0x000010, "Member 'FSBZNode::Room' has a wrong offset!");

// ScriptStruct Starbreeze.SBZEffectChanceData
// 0x0018 (0x0018 - 0x0000)
struct FSBZEffectChanceData final
{
public:
	TArray<ESBZSeasonalEventEffectType>           EffectTypeArray;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Chance;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZEffectChanceData) == 0x000008, "Wrong alignment on FSBZEffectChanceData");
static_assert(sizeof(FSBZEffectChanceData) == 0x000018, "Wrong size on FSBZEffectChanceData");
static_assert(offsetof(FSBZEffectChanceData, EffectTypeArray) == 0x000000, "Member 'FSBZEffectChanceData::EffectTypeArray' has a wrong offset!");
static_assert(offsetof(FSBZEffectChanceData, Chance) == 0x000010, "Member 'FSBZEffectChanceData::Chance' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSecurityCameraDetectionData
// 0x0020 (0x0020 - 0x0000)
struct FSBZSecurityCameraDetectionData final
{
public:
	TWeakObjectPtr<class AActor>                  Actor;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentDetection;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPerceived;                                      // 0x000C(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZCameraDetectionLevel                      DetectionLevel;                                    // 0x000D(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class ISBZAIVisualDetectionGeneratorInterface> VisionGeneratorInterface;        // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSecurityCameraDetectionData) == 0x000008, "Wrong alignment on FSBZSecurityCameraDetectionData");
static_assert(sizeof(FSBZSecurityCameraDetectionData) == 0x000020, "Wrong size on FSBZSecurityCameraDetectionData");
static_assert(offsetof(FSBZSecurityCameraDetectionData, Actor) == 0x000000, "Member 'FSBZSecurityCameraDetectionData::Actor' has a wrong offset!");
static_assert(offsetof(FSBZSecurityCameraDetectionData, CurrentDetection) == 0x000008, "Member 'FSBZSecurityCameraDetectionData::CurrentDetection' has a wrong offset!");
static_assert(offsetof(FSBZSecurityCameraDetectionData, bIsPerceived) == 0x00000C, "Member 'FSBZSecurityCameraDetectionData::bIsPerceived' has a wrong offset!");
static_assert(offsetof(FSBZSecurityCameraDetectionData, DetectionLevel) == 0x00000D, "Member 'FSBZSecurityCameraDetectionData::DetectionLevel' has a wrong offset!");
static_assert(offsetof(FSBZSecurityCameraDetectionData, VisionGeneratorInterface) == 0x000010, "Member 'FSBZSecurityCameraDetectionData::VisionGeneratorInterface' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSecurityCompanySettingData
// 0x0078 (0x0078 - 0x0000)
struct FSBZSecurityCompanySettingData final
{
public:
	uint16                                        IndestructibleCamerasMask;                         // 0x0000(0x0002)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        CameraRuntimeLimitMask;                            // 0x0002(0x0002)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        LeadGuardMask;                                     // 0x0004(0x0002)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        DebilitatingSpecialsMask;                          // 0x0006(0x0002)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        FacialRecognitionMask;                             // 0x0008(0x0002)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        ArmorPiercingMask;                                 // 0x000A(0x0002)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        BuddySystemMask;                                   // 0x000C(0x0002)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        AlphaStrikeMask;                                   // 0x000E(0x0002)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        HardBargainMask;                                   // 0x0010(0x0002)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        AICoreMask;                                        // 0x0012(0x0002)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        ReflectorShieldsMask;                              // 0x0014(0x0002)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        AIShieldingMask;                                   // 0x0016(0x0002)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmorPiercingPercentage;                           // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  DebilitatingPawnTypes;                             // 0x0020(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<ESBZPlayerAbilityBuffType>             DebilitatingBuffsToRemove;                         // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         HardBargainMinHostageRequired;                     // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  BuddySystemIgnoreTags;                             // 0x0058(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSecurityCompanySettingData) == 0x000008, "Wrong alignment on FSBZSecurityCompanySettingData");
static_assert(sizeof(FSBZSecurityCompanySettingData) == 0x000078, "Wrong size on FSBZSecurityCompanySettingData");
static_assert(offsetof(FSBZSecurityCompanySettingData, IndestructibleCamerasMask) == 0x000000, "Member 'FSBZSecurityCompanySettingData::IndestructibleCamerasMask' has a wrong offset!");
static_assert(offsetof(FSBZSecurityCompanySettingData, CameraRuntimeLimitMask) == 0x000002, "Member 'FSBZSecurityCompanySettingData::CameraRuntimeLimitMask' has a wrong offset!");
static_assert(offsetof(FSBZSecurityCompanySettingData, LeadGuardMask) == 0x000004, "Member 'FSBZSecurityCompanySettingData::LeadGuardMask' has a wrong offset!");
static_assert(offsetof(FSBZSecurityCompanySettingData, DebilitatingSpecialsMask) == 0x000006, "Member 'FSBZSecurityCompanySettingData::DebilitatingSpecialsMask' has a wrong offset!");
static_assert(offsetof(FSBZSecurityCompanySettingData, FacialRecognitionMask) == 0x000008, "Member 'FSBZSecurityCompanySettingData::FacialRecognitionMask' has a wrong offset!");
static_assert(offsetof(FSBZSecurityCompanySettingData, ArmorPiercingMask) == 0x00000A, "Member 'FSBZSecurityCompanySettingData::ArmorPiercingMask' has a wrong offset!");
static_assert(offsetof(FSBZSecurityCompanySettingData, BuddySystemMask) == 0x00000C, "Member 'FSBZSecurityCompanySettingData::BuddySystemMask' has a wrong offset!");
static_assert(offsetof(FSBZSecurityCompanySettingData, AlphaStrikeMask) == 0x00000E, "Member 'FSBZSecurityCompanySettingData::AlphaStrikeMask' has a wrong offset!");
static_assert(offsetof(FSBZSecurityCompanySettingData, HardBargainMask) == 0x000010, "Member 'FSBZSecurityCompanySettingData::HardBargainMask' has a wrong offset!");
static_assert(offsetof(FSBZSecurityCompanySettingData, AICoreMask) == 0x000012, "Member 'FSBZSecurityCompanySettingData::AICoreMask' has a wrong offset!");
static_assert(offsetof(FSBZSecurityCompanySettingData, ReflectorShieldsMask) == 0x000014, "Member 'FSBZSecurityCompanySettingData::ReflectorShieldsMask' has a wrong offset!");
static_assert(offsetof(FSBZSecurityCompanySettingData, AIShieldingMask) == 0x000016, "Member 'FSBZSecurityCompanySettingData::AIShieldingMask' has a wrong offset!");
static_assert(offsetof(FSBZSecurityCompanySettingData, ArmorPiercingPercentage) == 0x000018, "Member 'FSBZSecurityCompanySettingData::ArmorPiercingPercentage' has a wrong offset!");
static_assert(offsetof(FSBZSecurityCompanySettingData, DebilitatingPawnTypes) == 0x000020, "Member 'FSBZSecurityCompanySettingData::DebilitatingPawnTypes' has a wrong offset!");
static_assert(offsetof(FSBZSecurityCompanySettingData, DebilitatingBuffsToRemove) == 0x000040, "Member 'FSBZSecurityCompanySettingData::DebilitatingBuffsToRemove' has a wrong offset!");
static_assert(offsetof(FSBZSecurityCompanySettingData, HardBargainMinHostageRequired) == 0x000050, "Member 'FSBZSecurityCompanySettingData::HardBargainMinHostageRequired' has a wrong offset!");
static_assert(offsetof(FSBZSecurityCompanySettingData, BuddySystemIgnoreTags) == 0x000058, "Member 'FSBZSecurityCompanySettingData::BuddySystemIgnoreTags' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeaponTargetingOverrideData
// 0x0008 (0x0008 - 0x0000)
struct FSBZWeaponTargetingOverrideData final
{
public:
	float                                         TargetingXAxisOffset;                              // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TopPassTargetingFocalDistanceOffset;               // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWeaponTargetingOverrideData) == 0x000004, "Wrong alignment on FSBZWeaponTargetingOverrideData");
static_assert(sizeof(FSBZWeaponTargetingOverrideData) == 0x000008, "Wrong size on FSBZWeaponTargetingOverrideData");
static_assert(offsetof(FSBZWeaponTargetingOverrideData, TargetingXAxisOffset) == 0x000000, "Member 'FSBZWeaponTargetingOverrideData::TargetingXAxisOffset' has a wrong offset!");
static_assert(offsetof(FSBZWeaponTargetingOverrideData, TopPassTargetingFocalDistanceOffset) == 0x000004, "Member 'FSBZWeaponTargetingOverrideData::TopPassTargetingFocalDistanceOffset' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSensorToolTargetData
// 0x0010 (0x0018 - 0x0008)
struct FSBZSensorToolTargetData final : public FGameplayAbilityTargetData
{
public:
	class AActor*                                 ToggledActor;                                      // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZSensorToolTargetData) == 0x000008, "Wrong alignment on FSBZSensorToolTargetData");
static_assert(sizeof(FSBZSensorToolTargetData) == 0x000018, "Wrong size on FSBZSensorToolTargetData");
static_assert(offsetof(FSBZSensorToolTargetData, ToggledActor) == 0x000008, "Member 'FSBZSensorToolTargetData::ToggledActor' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSentryGunAngleBouncer
// 0x0014 (0x0014 - 0x0000)
struct FSBZSentryGunAngleBouncer final
{
public:
	float                                         BounceFrequency;                                   // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BounceStrength;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0xC];                                        // 0x0008(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZSentryGunAngleBouncer) == 0x000004, "Wrong alignment on FSBZSentryGunAngleBouncer");
static_assert(sizeof(FSBZSentryGunAngleBouncer) == 0x000014, "Wrong size on FSBZSentryGunAngleBouncer");
static_assert(offsetof(FSBZSentryGunAngleBouncer, BounceFrequency) == 0x000000, "Member 'FSBZSentryGunAngleBouncer::BounceFrequency' has a wrong offset!");
static_assert(offsetof(FSBZSentryGunAngleBouncer, BounceStrength) == 0x000004, "Member 'FSBZSentryGunAngleBouncer::BounceStrength' has a wrong offset!");

// ScriptStruct Starbreeze.SBZServersListIterator
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FSBZServersListIterator final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZServersListIterator) == 0x000008, "Wrong alignment on FSBZServersListIterator");
static_assert(sizeof(FSBZServersListIterator) == 0x000028, "Wrong size on FSBZServersListIterator");

// ScriptStruct Starbreeze.SBZWheeledVehicleFX
// 0x0030 (0x0030 - 0x0000)
struct FSBZWheeledVehicleFX final
{
public:
	class UNiagaraSystem*                         Asset;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Socket;                                            // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            SpeedThresholdMinMax;                              // 0x0018(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NiagaraComponent;                                  // 0x0028(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWheeledVehicleFX) == 0x000008, "Wrong alignment on FSBZWheeledVehicleFX");
static_assert(sizeof(FSBZWheeledVehicleFX) == 0x000030, "Wrong size on FSBZWheeledVehicleFX");
static_assert(offsetof(FSBZWheeledVehicleFX, Asset) == 0x000000, "Member 'FSBZWheeledVehicleFX::Asset' has a wrong offset!");
static_assert(offsetof(FSBZWheeledVehicleFX, Socket) == 0x000008, "Member 'FSBZWheeledVehicleFX::Socket' has a wrong offset!");
static_assert(offsetof(FSBZWheeledVehicleFX, MaxDistance) == 0x000014, "Member 'FSBZWheeledVehicleFX::MaxDistance' has a wrong offset!");
static_assert(offsetof(FSBZWheeledVehicleFX, SpeedThresholdMinMax) == 0x000018, "Member 'FSBZWheeledVehicleFX::SpeedThresholdMinMax' has a wrong offset!");
static_assert(offsetof(FSBZWheeledVehicleFX, NiagaraComponent) == 0x000028, "Member 'FSBZWheeledVehicleFX::NiagaraComponent' has a wrong offset!");

// ScriptStruct Starbreeze.SBZServerBrowserFilters
// 0x0018 (0x0018 - 0x0000)
struct FSBZServerBrowserFilters final
{
public:
	TArray<class FString>                         HeistNames;                                        // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZServerBrowserFilters) == 0x000008, "Wrong alignment on FSBZServerBrowserFilters");
static_assert(sizeof(FSBZServerBrowserFilters) == 0x000018, "Wrong size on FSBZServerBrowserFilters");
static_assert(offsetof(FSBZServerBrowserFilters, HeistNames) == 0x000000, "Member 'FSBZServerBrowserFilters::HeistNames' has a wrong offset!");

// ScriptStruct Starbreeze.SingleUserStatRequests
// 0x00B0 (0x00B0 - 0x0000)
struct FSingleUserStatRequests final
{
public:
	class FString                                 UserId;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, float>                    Stats;                                             // 0x0010(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x50];                                      // 0x0060(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSingleUserStatRequests) == 0x000008, "Wrong alignment on FSingleUserStatRequests");
static_assert(sizeof(FSingleUserStatRequests) == 0x0000B0, "Wrong size on FSingleUserStatRequests");
static_assert(offsetof(FSingleUserStatRequests, UserId) == 0x000000, "Member 'FSingleUserStatRequests::UserId' has a wrong offset!");
static_assert(offsetof(FSingleUserStatRequests, Stats) == 0x000010, "Member 'FSingleUserStatRequests::Stats' has a wrong offset!");

// ScriptStruct Starbreeze.MultipleUsersStatRequests
// 0x0050 (0x0050 - 0x0000)
struct FMultipleUsersStatRequests final
{
public:
	TMap<class FString, struct FSingleUserStatRequests> UsersStatRequests;                           // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FMultipleUsersStatRequests) == 0x000008, "Wrong alignment on FMultipleUsersStatRequests");
static_assert(sizeof(FMultipleUsersStatRequests) == 0x000050, "Wrong size on FMultipleUsersStatRequests");
static_assert(offsetof(FMultipleUsersStatRequests, UsersStatRequests) == 0x000000, "Member 'FMultipleUsersStatRequests::UsersStatRequests' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSettingsMenuInputAction
// 0x000C (0x000C - 0x0000)
struct FSBZSettingsMenuInputAction final
{
public:
	class FName                                   ActionName;                                        // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSettingsMenuInputAction) == 0x000004, "Wrong alignment on FSBZSettingsMenuInputAction");
static_assert(sizeof(FSBZSettingsMenuInputAction) == 0x00000C, "Wrong size on FSBZSettingsMenuInputAction");
static_assert(offsetof(FSBZSettingsMenuInputAction, ActionName) == 0x000000, "Member 'FSBZSettingsMenuInputAction::ActionName' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSettingsMenuInputAxis
// 0x0010 (0x0010 - 0x0000)
struct FSBZSettingsMenuInputAxis final
{
public:
	class FName                                   AxisName;                                          // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSettingsMenuInputAxis) == 0x000004, "Wrong alignment on FSBZSettingsMenuInputAxis");
static_assert(sizeof(FSBZSettingsMenuInputAxis) == 0x000010, "Wrong size on FSBZSettingsMenuInputAxis");
static_assert(offsetof(FSBZSettingsMenuInputAxis, AxisName) == 0x000000, "Member 'FSBZSettingsMenuInputAxis::AxisName' has a wrong offset!");
static_assert(offsetof(FSBZSettingsMenuInputAxis, Scale) == 0x00000C, "Member 'FSBZSettingsMenuInputAxis::Scale' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSettingData
// 0x02E8 (0x02E8 - 0x0000)
struct FSBZSettingData final
{
public:
	class FText                                   SettingNameLocalized;                              // 0x0000(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bHasPlaystationSpecificSettingNameLocalized;       // 0x0018(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   SettingNameLocalizedPlaystation;                   // 0x0020(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bHasXBoxSpecificSettingNameLocalized;              // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   SettingNameLocalizedXBox;                          // 0x0040(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   SettingName;                                       // 0x0058(0x000C)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StringTableShortName;                              // 0x0068(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZControlType                               ControlType;                                       // 0x0078(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SettingHelperPanelName;                            // 0x007C(0x000C)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   SettingDescriptionLocalized;                       // 0x0088(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	bool                                          bApplyChangeImmediately;                           // 0x00A0(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAskChangeConfirmation;                            // 0x00A1(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanResetToDefault;                                // 0x00A2(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A3[0x1];                                       // 0x00A3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GetButtonVisibilityFunctionName;                   // 0x00A4(0x000C)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowOnlyOnWindowsPlatform;                        // 0x00B0(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideInShippingBuild;                              // 0x00B1(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideInAnyBuild;                                   // 0x00B2(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B3[0x1];                                       // 0x00B3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DoActionFunctionName;                              // 0x00B4(0x000C)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GetDefaultValueFunctionName;                       // 0x00C0(0x000C)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GetValueFunctionName;                              // 0x00CC(0x000C)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SetValueFunctionName;                              // 0x00D8(0x000C)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GetDefaultKeyPrimaryFunctionName;                  // 0x00E4(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GetKeyPrimaryFunctionName;                         // 0x00F0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SetKeyPrimaryFunctionName;                         // 0x00FC(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GetDefaultKeySecondaryFunctionName;                // 0x0108(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GetKeySecondaryFunctionName;                       // 0x0114(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SetKeySecondaryFunctionName;                       // 0x0120(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ButtonVisibilityPrevious;                          // 0x012C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ButtonVisibilityCurrent;                           // 0x012D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12E[0x2];                                      // 0x012E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ActionButtonLabelLocalized;                        // 0x0130(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	class FString                                 ToggleName;                                        // 0x0148(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BoolValue;                                         // 0x0158(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LastBoolValue;                                     // 0x0159(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15A[0x6];                                      // 0x015A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MultipleChoiceName;                                // 0x0160(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Int64Value;                                        // 0x0170(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         LastInt64Value;                                    // 0x0178(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatMinValue;                                     // 0x0180(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatMaxValue;                                     // 0x0184(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatIncrementValue;                               // 0x0188(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatValue;                                        // 0x018C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastFloatValue;                                    // 0x0190(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_194[0x4];                                      // 0x0194(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StringValue;                                       // 0x0198(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LastStringValue;                                   // 0x01A8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorValue;                                        // 0x01B8(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LastColorValue;                                    // 0x01C8(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              IntPointValue;                                     // 0x01D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              LastIntPointValue;                                 // 0x01E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSBZSettingsMenuInputAction>    InputActions;                                      // 0x01E8(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FSBZSettingsMenuInputAxis>      InputAxes;                                         // 0x01F8(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	struct FInputChord                            PrimaryBinding;                                    // 0x0208(0x0028)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputChord                            SecondaryBinding;                                  // 0x0230(0x0028)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputChord                            LastPrimaryBinding;                                // 0x0258(0x0028)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputChord                            LastSecondaryBinding;                              // 0x0280(0x0028)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           AllowedBindingOverlaps;                            // 0x02A8(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<class FName>                           PrimaryBindingConflicts;                           // 0x02B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           SecondaryBindingConflicts;                         // 0x02C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   ParentName;                                        // 0x02D8(0x000C)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDirty;                                          // 0x02E4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasDefaultValue;                                  // 0x02E5(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActive;                                           // 0x02E6(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E7[0x1];                                      // 0x02E7(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZSettingData) == 0x000008, "Wrong alignment on FSBZSettingData");
static_assert(sizeof(FSBZSettingData) == 0x0002E8, "Wrong size on FSBZSettingData");
static_assert(offsetof(FSBZSettingData, SettingNameLocalized) == 0x000000, "Member 'FSBZSettingData::SettingNameLocalized' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, bHasPlaystationSpecificSettingNameLocalized) == 0x000018, "Member 'FSBZSettingData::bHasPlaystationSpecificSettingNameLocalized' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, SettingNameLocalizedPlaystation) == 0x000020, "Member 'FSBZSettingData::SettingNameLocalizedPlaystation' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, bHasXBoxSpecificSettingNameLocalized) == 0x000038, "Member 'FSBZSettingData::bHasXBoxSpecificSettingNameLocalized' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, SettingNameLocalizedXBox) == 0x000040, "Member 'FSBZSettingData::SettingNameLocalizedXBox' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, SettingName) == 0x000058, "Member 'FSBZSettingData::SettingName' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, StringTableShortName) == 0x000068, "Member 'FSBZSettingData::StringTableShortName' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, ControlType) == 0x000078, "Member 'FSBZSettingData::ControlType' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, SettingHelperPanelName) == 0x00007C, "Member 'FSBZSettingData::SettingHelperPanelName' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, SettingDescriptionLocalized) == 0x000088, "Member 'FSBZSettingData::SettingDescriptionLocalized' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, bApplyChangeImmediately) == 0x0000A0, "Member 'FSBZSettingData::bApplyChangeImmediately' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, bAskChangeConfirmation) == 0x0000A1, "Member 'FSBZSettingData::bAskChangeConfirmation' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, bCanResetToDefault) == 0x0000A2, "Member 'FSBZSettingData::bCanResetToDefault' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, GetButtonVisibilityFunctionName) == 0x0000A4, "Member 'FSBZSettingData::GetButtonVisibilityFunctionName' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, bShowOnlyOnWindowsPlatform) == 0x0000B0, "Member 'FSBZSettingData::bShowOnlyOnWindowsPlatform' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, bHideInShippingBuild) == 0x0000B1, "Member 'FSBZSettingData::bHideInShippingBuild' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, bHideInAnyBuild) == 0x0000B2, "Member 'FSBZSettingData::bHideInAnyBuild' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, DoActionFunctionName) == 0x0000B4, "Member 'FSBZSettingData::DoActionFunctionName' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, GetDefaultValueFunctionName) == 0x0000C0, "Member 'FSBZSettingData::GetDefaultValueFunctionName' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, GetValueFunctionName) == 0x0000CC, "Member 'FSBZSettingData::GetValueFunctionName' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, SetValueFunctionName) == 0x0000D8, "Member 'FSBZSettingData::SetValueFunctionName' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, GetDefaultKeyPrimaryFunctionName) == 0x0000E4, "Member 'FSBZSettingData::GetDefaultKeyPrimaryFunctionName' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, GetKeyPrimaryFunctionName) == 0x0000F0, "Member 'FSBZSettingData::GetKeyPrimaryFunctionName' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, SetKeyPrimaryFunctionName) == 0x0000FC, "Member 'FSBZSettingData::SetKeyPrimaryFunctionName' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, GetDefaultKeySecondaryFunctionName) == 0x000108, "Member 'FSBZSettingData::GetDefaultKeySecondaryFunctionName' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, GetKeySecondaryFunctionName) == 0x000114, "Member 'FSBZSettingData::GetKeySecondaryFunctionName' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, SetKeySecondaryFunctionName) == 0x000120, "Member 'FSBZSettingData::SetKeySecondaryFunctionName' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, ButtonVisibilityPrevious) == 0x00012C, "Member 'FSBZSettingData::ButtonVisibilityPrevious' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, ButtonVisibilityCurrent) == 0x00012D, "Member 'FSBZSettingData::ButtonVisibilityCurrent' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, ActionButtonLabelLocalized) == 0x000130, "Member 'FSBZSettingData::ActionButtonLabelLocalized' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, ToggleName) == 0x000148, "Member 'FSBZSettingData::ToggleName' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, BoolValue) == 0x000158, "Member 'FSBZSettingData::BoolValue' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, LastBoolValue) == 0x000159, "Member 'FSBZSettingData::LastBoolValue' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, MultipleChoiceName) == 0x000160, "Member 'FSBZSettingData::MultipleChoiceName' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, Int64Value) == 0x000170, "Member 'FSBZSettingData::Int64Value' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, LastInt64Value) == 0x000178, "Member 'FSBZSettingData::LastInt64Value' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, FloatMinValue) == 0x000180, "Member 'FSBZSettingData::FloatMinValue' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, FloatMaxValue) == 0x000184, "Member 'FSBZSettingData::FloatMaxValue' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, FloatIncrementValue) == 0x000188, "Member 'FSBZSettingData::FloatIncrementValue' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, FloatValue) == 0x00018C, "Member 'FSBZSettingData::FloatValue' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, LastFloatValue) == 0x000190, "Member 'FSBZSettingData::LastFloatValue' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, StringValue) == 0x000198, "Member 'FSBZSettingData::StringValue' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, LastStringValue) == 0x0001A8, "Member 'FSBZSettingData::LastStringValue' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, ColorValue) == 0x0001B8, "Member 'FSBZSettingData::ColorValue' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, LastColorValue) == 0x0001C8, "Member 'FSBZSettingData::LastColorValue' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, IntPointValue) == 0x0001D8, "Member 'FSBZSettingData::IntPointValue' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, LastIntPointValue) == 0x0001E0, "Member 'FSBZSettingData::LastIntPointValue' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, InputActions) == 0x0001E8, "Member 'FSBZSettingData::InputActions' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, InputAxes) == 0x0001F8, "Member 'FSBZSettingData::InputAxes' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, PrimaryBinding) == 0x000208, "Member 'FSBZSettingData::PrimaryBinding' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, SecondaryBinding) == 0x000230, "Member 'FSBZSettingData::SecondaryBinding' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, LastPrimaryBinding) == 0x000258, "Member 'FSBZSettingData::LastPrimaryBinding' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, LastSecondaryBinding) == 0x000280, "Member 'FSBZSettingData::LastSecondaryBinding' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, AllowedBindingOverlaps) == 0x0002A8, "Member 'FSBZSettingData::AllowedBindingOverlaps' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, PrimaryBindingConflicts) == 0x0002B8, "Member 'FSBZSettingData::PrimaryBindingConflicts' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, SecondaryBindingConflicts) == 0x0002C8, "Member 'FSBZSettingData::SecondaryBindingConflicts' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, ParentName) == 0x0002D8, "Member 'FSBZSettingData::ParentName' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, bIsDirty) == 0x0002E4, "Member 'FSBZSettingData::bIsDirty' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, bHasDefaultValue) == 0x0002E5, "Member 'FSBZSettingData::bHasDefaultValue' has a wrong offset!");
static_assert(offsetof(FSBZSettingData, bActive) == 0x0002E6, "Member 'FSBZSettingData::bActive' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSettingsMenuGroupInfo
// 0x0078 (0x0078 - 0x0000)
struct FSBZSettingsMenuGroupInfo final
{
public:
	class FText                                   GroupNameLocalized;                                // 0x0000(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bHasPlaystationSpecificGroupNameLocalized;         // 0x0018(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   GroupNameLocalizedPlaystation;                     // 0x0020(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bHasXBoxSpecificGroupNameLocalized;                // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   GroupNameLocalizedXBox;                            // 0x0040(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   GroupName;                                         // 0x0058(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowOnlyOnWindowsPlatform;                        // 0x0064(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideInShippingBuild;                              // 0x0065(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_66[0x2];                                       // 0x0066(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSBZSettingData>                Settings;                                          // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSettingsMenuGroupInfo) == 0x000008, "Wrong alignment on FSBZSettingsMenuGroupInfo");
static_assert(sizeof(FSBZSettingsMenuGroupInfo) == 0x000078, "Wrong size on FSBZSettingsMenuGroupInfo");
static_assert(offsetof(FSBZSettingsMenuGroupInfo, GroupNameLocalized) == 0x000000, "Member 'FSBZSettingsMenuGroupInfo::GroupNameLocalized' has a wrong offset!");
static_assert(offsetof(FSBZSettingsMenuGroupInfo, bHasPlaystationSpecificGroupNameLocalized) == 0x000018, "Member 'FSBZSettingsMenuGroupInfo::bHasPlaystationSpecificGroupNameLocalized' has a wrong offset!");
static_assert(offsetof(FSBZSettingsMenuGroupInfo, GroupNameLocalizedPlaystation) == 0x000020, "Member 'FSBZSettingsMenuGroupInfo::GroupNameLocalizedPlaystation' has a wrong offset!");
static_assert(offsetof(FSBZSettingsMenuGroupInfo, bHasXBoxSpecificGroupNameLocalized) == 0x000038, "Member 'FSBZSettingsMenuGroupInfo::bHasXBoxSpecificGroupNameLocalized' has a wrong offset!");
static_assert(offsetof(FSBZSettingsMenuGroupInfo, GroupNameLocalizedXBox) == 0x000040, "Member 'FSBZSettingsMenuGroupInfo::GroupNameLocalizedXBox' has a wrong offset!");
static_assert(offsetof(FSBZSettingsMenuGroupInfo, GroupName) == 0x000058, "Member 'FSBZSettingsMenuGroupInfo::GroupName' has a wrong offset!");
static_assert(offsetof(FSBZSettingsMenuGroupInfo, bShowOnlyOnWindowsPlatform) == 0x000064, "Member 'FSBZSettingsMenuGroupInfo::bShowOnlyOnWindowsPlatform' has a wrong offset!");
static_assert(offsetof(FSBZSettingsMenuGroupInfo, bHideInShippingBuild) == 0x000065, "Member 'FSBZSettingsMenuGroupInfo::bHideInShippingBuild' has a wrong offset!");
static_assert(offsetof(FSBZSettingsMenuGroupInfo, Settings) == 0x000068, "Member 'FSBZSettingsMenuGroupInfo::Settings' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSettingsMenuCategoryInfo
// 0x0080 (0x0080 - 0x0000)
struct FSBZSettingsMenuCategoryInfo final
{
public:
	class FText                                   CategoryNameLocalized;                             // 0x0000(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bHasPlaystationSpecificCategoryNameLocalized;      // 0x0018(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CategoryNameLocalizedPlaystation;                  // 0x0020(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bHasXBoxSpecificCategoryNameLocalized;             // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CategoryNameLocalizedXBox;                         // 0x0040(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   CategoryName;                                      // 0x0058(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class USBZSettingsFunctions>      SettingsFunctions;                                 // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSBZSettingsMenuGroupInfo>      SettingsGroups;                                    // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSettingsMenuCategoryInfo) == 0x000008, "Wrong alignment on FSBZSettingsMenuCategoryInfo");
static_assert(sizeof(FSBZSettingsMenuCategoryInfo) == 0x000080, "Wrong size on FSBZSettingsMenuCategoryInfo");
static_assert(offsetof(FSBZSettingsMenuCategoryInfo, CategoryNameLocalized) == 0x000000, "Member 'FSBZSettingsMenuCategoryInfo::CategoryNameLocalized' has a wrong offset!");
static_assert(offsetof(FSBZSettingsMenuCategoryInfo, bHasPlaystationSpecificCategoryNameLocalized) == 0x000018, "Member 'FSBZSettingsMenuCategoryInfo::bHasPlaystationSpecificCategoryNameLocalized' has a wrong offset!");
static_assert(offsetof(FSBZSettingsMenuCategoryInfo, CategoryNameLocalizedPlaystation) == 0x000020, "Member 'FSBZSettingsMenuCategoryInfo::CategoryNameLocalizedPlaystation' has a wrong offset!");
static_assert(offsetof(FSBZSettingsMenuCategoryInfo, bHasXBoxSpecificCategoryNameLocalized) == 0x000038, "Member 'FSBZSettingsMenuCategoryInfo::bHasXBoxSpecificCategoryNameLocalized' has a wrong offset!");
static_assert(offsetof(FSBZSettingsMenuCategoryInfo, CategoryNameLocalizedXBox) == 0x000040, "Member 'FSBZSettingsMenuCategoryInfo::CategoryNameLocalizedXBox' has a wrong offset!");
static_assert(offsetof(FSBZSettingsMenuCategoryInfo, CategoryName) == 0x000058, "Member 'FSBZSettingsMenuCategoryInfo::CategoryName' has a wrong offset!");
static_assert(offsetof(FSBZSettingsMenuCategoryInfo, SettingsFunctions) == 0x000068, "Member 'FSBZSettingsMenuCategoryInfo::SettingsFunctions' has a wrong offset!");
static_assert(offsetof(FSBZSettingsMenuCategoryInfo, SettingsGroups) == 0x000070, "Member 'FSBZSettingsMenuCategoryInfo::SettingsGroups' has a wrong offset!");

// ScriptStruct Starbreeze.SBZGlobalMaterialParameters
// 0x0068 (0x0068 - 0x0000)
struct FSBZGlobalMaterialParameters final
{
public:
	struct FVector                                WindDirection;                                     // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WindSpeed;                                         // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ActionOriginActor;                                 // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           FXGlobalEmissive;                                  // 0x0018(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           FXGlobalBaseColor;                                 // 0x0028(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           EnemyBacklightInfluence;                           // 0x0038(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           EnemyBacklightFade;                                // 0x0048(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           EnemyBacklightRangeFuzz;                           // 0x0058(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZGlobalMaterialParameters) == 0x000008, "Wrong alignment on FSBZGlobalMaterialParameters");
static_assert(sizeof(FSBZGlobalMaterialParameters) == 0x000068, "Wrong size on FSBZGlobalMaterialParameters");
static_assert(offsetof(FSBZGlobalMaterialParameters, WindDirection) == 0x000000, "Member 'FSBZGlobalMaterialParameters::WindDirection' has a wrong offset!");
static_assert(offsetof(FSBZGlobalMaterialParameters, WindSpeed) == 0x00000C, "Member 'FSBZGlobalMaterialParameters::WindSpeed' has a wrong offset!");
static_assert(offsetof(FSBZGlobalMaterialParameters, ActionOriginActor) == 0x000010, "Member 'FSBZGlobalMaterialParameters::ActionOriginActor' has a wrong offset!");
static_assert(offsetof(FSBZGlobalMaterialParameters, FXGlobalEmissive) == 0x000018, "Member 'FSBZGlobalMaterialParameters::FXGlobalEmissive' has a wrong offset!");
static_assert(offsetof(FSBZGlobalMaterialParameters, FXGlobalBaseColor) == 0x000028, "Member 'FSBZGlobalMaterialParameters::FXGlobalBaseColor' has a wrong offset!");
static_assert(offsetof(FSBZGlobalMaterialParameters, EnemyBacklightInfluence) == 0x000038, "Member 'FSBZGlobalMaterialParameters::EnemyBacklightInfluence' has a wrong offset!");
static_assert(offsetof(FSBZGlobalMaterialParameters, EnemyBacklightFade) == 0x000048, "Member 'FSBZGlobalMaterialParameters::EnemyBacklightFade' has a wrong offset!");
static_assert(offsetof(FSBZGlobalMaterialParameters, EnemyBacklightRangeFuzz) == 0x000058, "Member 'FSBZGlobalMaterialParameters::EnemyBacklightRangeFuzz' has a wrong offset!");

// ScriptStruct Starbreeze.SBZTrackedVariable
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FSBZTrackedVariable final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   VarName;                                           // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESBZTrackedVariableType                       Type;                                              // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZTrackedVariable) == 0x000008, "Wrong alignment on FSBZTrackedVariable");
static_assert(sizeof(FSBZTrackedVariable) == 0x000020, "Wrong size on FSBZTrackedVariable");
static_assert(offsetof(FSBZTrackedVariable, VarName) == 0x000010, "Member 'FSBZTrackedVariable::VarName' has a wrong offset!");
static_assert(offsetof(FSBZTrackedVariable, Type) == 0x00001C, "Member 'FSBZTrackedVariable::Type' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSettingsMenuChildData
// 0x0020 (0x0020 - 0x0000)
struct FSBZSettingsMenuChildData final
{
public:
	class FName                                   ParentName;                                        // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ChildsName;                                        // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSettingsMenuChildData) == 0x000008, "Wrong alignment on FSBZSettingsMenuChildData");
static_assert(sizeof(FSBZSettingsMenuChildData) == 0x000020, "Wrong size on FSBZSettingsMenuChildData");
static_assert(offsetof(FSBZSettingsMenuChildData, ParentName) == 0x000000, "Member 'FSBZSettingsMenuChildData::ParentName' has a wrong offset!");
static_assert(offsetof(FSBZSettingsMenuChildData, ChildsName) == 0x000010, "Member 'FSBZSettingsMenuChildData::ChildsName' has a wrong offset!");

// ScriptStruct Starbreeze.SBZShockGrenadeActorData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FSBZShockGrenadeActorData final
{
public:
	int32                                         ChainNumber;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsExplosionTriggered;                             // 0x0004(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0xB];                                        // 0x0005(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZShockGrenadeActorData) == 0x000008, "Wrong alignment on FSBZShockGrenadeActorData");
static_assert(sizeof(FSBZShockGrenadeActorData) == 0x000010, "Wrong size on FSBZShockGrenadeActorData");
static_assert(offsetof(FSBZShockGrenadeActorData, ChainNumber) == 0x000000, "Member 'FSBZShockGrenadeActorData::ChainNumber' has a wrong offset!");
static_assert(offsetof(FSBZShockGrenadeActorData, bIsExplosionTriggered) == 0x000004, "Member 'FSBZShockGrenadeActorData::bIsExplosionTriggered' has a wrong offset!");

// ScriptStruct Starbreeze.SBZShoveHumanShieldTargetData
// 0x02F8 (0x0300 - 0x0008)
struct FSBZShoveHumanShieldTargetData final : public FGameplayAbilityTargetData
{
public:
	uint8                                         Pad_8[0x2F8];                                      // 0x0008(0x02F8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZShoveHumanShieldTargetData) == 0x000008, "Wrong alignment on FSBZShoveHumanShieldTargetData");
static_assert(sizeof(FSBZShoveHumanShieldTargetData) == 0x000300, "Wrong size on FSBZShoveHumanShieldTargetData");

// ScriptStruct Starbreeze.SBZSimplePhysicsState
// 0x0030 (0x0030 - 0x0000)
struct FSBZSimplePhysicsState final
{
public:
	struct FVector                                LastPos;                                           // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  LastRot;                                           // 0x0010(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnsurePos;                                        // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0xF];                                       // 0x0021(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZSimplePhysicsState) == 0x000010, "Wrong alignment on FSBZSimplePhysicsState");
static_assert(sizeof(FSBZSimplePhysicsState) == 0x000030, "Wrong size on FSBZSimplePhysicsState");
static_assert(offsetof(FSBZSimplePhysicsState, LastPos) == 0x000000, "Member 'FSBZSimplePhysicsState::LastPos' has a wrong offset!");
static_assert(offsetof(FSBZSimplePhysicsState, LastRot) == 0x000010, "Member 'FSBZSimplePhysicsState::LastRot' has a wrong offset!");
static_assert(offsetof(FSBZSimplePhysicsState, bEnsurePos) == 0x000020, "Member 'FSBZSimplePhysicsState::bEnsurePos' has a wrong offset!");

// ScriptStruct Starbreeze.SBZVehicleDoorAnimationContainer
// 0x0050 (0x0050 - 0x0000)
struct FSBZVehicleDoorAnimationContainer final
{
public:
	TMap<ESBZVehicleDoorType, class USBZBuiltInAnimMontage*> DoorAnimations;                         // 0x0000(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZVehicleDoorAnimationContainer) == 0x000008, "Wrong alignment on FSBZVehicleDoorAnimationContainer");
static_assert(sizeof(FSBZVehicleDoorAnimationContainer) == 0x000050, "Wrong size on FSBZVehicleDoorAnimationContainer");
static_assert(offsetof(FSBZVehicleDoorAnimationContainer, DoorAnimations) == 0x000000, "Member 'FSBZVehicleDoorAnimationContainer::DoorAnimations' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSkillTreePair
// 0x0010 (0x0010 - 0x0000)
struct FSBZSkillTreePair final
{
public:
	class USBZSkillData*                          Base;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZSkillData*                          Aced;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSkillTreePair) == 0x000008, "Wrong alignment on FSBZSkillTreePair");
static_assert(sizeof(FSBZSkillTreePair) == 0x000010, "Wrong size on FSBZSkillTreePair");
static_assert(offsetof(FSBZSkillTreePair, Base) == 0x000000, "Member 'FSBZSkillTreePair::Base' has a wrong offset!");
static_assert(offsetof(FSBZSkillTreePair, Aced) == 0x000008, "Member 'FSBZSkillTreePair::Aced' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSkillTreeUpgradePair
// 0x0020 (0x0020 - 0x0000)
struct FSBZSkillTreeUpgradePair final
{
public:
	struct FSBZSkillTreePair                      UpgradeA;                                          // 0x0000(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FSBZSkillTreePair                      UpgradeB;                                          // 0x0010(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSkillTreeUpgradePair) == 0x000008, "Wrong alignment on FSBZSkillTreeUpgradePair");
static_assert(sizeof(FSBZSkillTreeUpgradePair) == 0x000020, "Wrong size on FSBZSkillTreeUpgradePair");
static_assert(offsetof(FSBZSkillTreeUpgradePair, UpgradeA) == 0x000000, "Member 'FSBZSkillTreeUpgradePair::UpgradeA' has a wrong offset!");
static_assert(offsetof(FSBZSkillTreeUpgradePair, UpgradeB) == 0x000010, "Member 'FSBZSkillTreeUpgradePair::UpgradeB' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSkillValue
// 0x0010 (0x0010 - 0x0000)
struct FSBZSkillValue
{
public:
	class FName                                   Name;                                              // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZSkillValueFormat                          FormatType;                                        // 0x000C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZSkillValue) == 0x000004, "Wrong alignment on FSBZSkillValue");
static_assert(sizeof(FSBZSkillValue) == 0x000010, "Wrong size on FSBZSkillValue");
static_assert(offsetof(FSBZSkillValue, Name) == 0x000000, "Member 'FSBZSkillValue::Name' has a wrong offset!");
static_assert(offsetof(FSBZSkillValue, FormatType) == 0x00000C, "Member 'FSBZSkillValue::FormatType' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSkillTagContainerValue
// 0x0020 (0x0030 - 0x0010)
struct FSBZSkillTagContainerValue final : public FSBZSkillValue
{
public:
	struct FGameplayTagContainer                  Value;                                             // 0x0010(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSkillTagContainerValue) == 0x000008, "Wrong alignment on FSBZSkillTagContainerValue");
static_assert(sizeof(FSBZSkillTagContainerValue) == 0x000030, "Wrong size on FSBZSkillTagContainerValue");
static_assert(offsetof(FSBZSkillTagContainerValue, Value) == 0x000010, "Member 'FSBZSkillTagContainerValue::Value' has a wrong offset!");

// ScriptStruct Starbreeze.SBZVehicleSpawnData
// 0x0020 (0x0020 - 0x0000)
struct FSBZVehicleSpawnData final
{
public:
	TArray<struct FSBZVehicleSplineData>          Paths;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class USBZAssaultVehicleSpawnerData*          VehicleSpawnData;                                  // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZVehicleSpawnData) == 0x000008, "Wrong alignment on FSBZVehicleSpawnData");
static_assert(sizeof(FSBZVehicleSpawnData) == 0x000020, "Wrong size on FSBZVehicleSpawnData");
static_assert(offsetof(FSBZVehicleSpawnData, Paths) == 0x000000, "Member 'FSBZVehicleSpawnData::Paths' has a wrong offset!");
static_assert(offsetof(FSBZVehicleSpawnData, VehicleSpawnData) == 0x000010, "Member 'FSBZVehicleSpawnData::VehicleSpawnData' has a wrong offset!");
static_assert(offsetof(FSBZVehicleSpawnData, bEnabled) == 0x000018, "Member 'FSBZVehicleSpawnData::bEnabled' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSkillIntValue
// 0x0004 (0x0014 - 0x0010)
struct FSBZSkillIntValue final : public FSBZSkillValue
{
public:
	int32                                         Value;                                             // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSkillIntValue) == 0x000004, "Wrong alignment on FSBZSkillIntValue");
static_assert(sizeof(FSBZSkillIntValue) == 0x000014, "Wrong size on FSBZSkillIntValue");
static_assert(offsetof(FSBZSkillIntValue, Value) == 0x000010, "Member 'FSBZSkillIntValue::Value' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSkillFloatValue
// 0x0004 (0x0014 - 0x0010)
struct FSBZSkillFloatValue final : public FSBZSkillValue
{
public:
	float                                         Value;                                             // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSkillFloatValue) == 0x000004, "Wrong alignment on FSBZSkillFloatValue");
static_assert(sizeof(FSBZSkillFloatValue) == 0x000014, "Wrong size on FSBZSkillFloatValue");
static_assert(offsetof(FSBZSkillFloatValue, Value) == 0x000010, "Member 'FSBZSkillFloatValue::Value' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAbilityBuffTypeActivation
// 0x0002 (0x0002 - 0x0000)
struct FSBZAbilityBuffTypeActivation final
{
public:
	ESBZAbilityBuffTypeAction                     Action;                                            // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZPlayerAbilityBuffType                     Type;                                              // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAbilityBuffTypeActivation) == 0x000001, "Wrong alignment on FSBZAbilityBuffTypeActivation");
static_assert(sizeof(FSBZAbilityBuffTypeActivation) == 0x000002, "Wrong size on FSBZAbilityBuffTypeActivation");
static_assert(offsetof(FSBZAbilityBuffTypeActivation, Action) == 0x000000, "Member 'FSBZAbilityBuffTypeActivation::Action' has a wrong offset!");
static_assert(offsetof(FSBZAbilityBuffTypeActivation, Type) == 0x000001, "Member 'FSBZAbilityBuffTypeActivation::Type' has a wrong offset!");

// ScriptStruct Starbreeze.SBZHackerSkillSettingData
// 0x000C (0x000C - 0x0000)
struct FSBZHackerSkillSettingData final
{
public:
	float                                         MaxDistanceModifierBase;                           // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AdditionalBatteriesAcedBase;                       // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HackableDurationDecreaseMastery;                   // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZHackerSkillSettingData) == 0x000004, "Wrong alignment on FSBZHackerSkillSettingData");
static_assert(sizeof(FSBZHackerSkillSettingData) == 0x00000C, "Wrong size on FSBZHackerSkillSettingData");
static_assert(offsetof(FSBZHackerSkillSettingData, MaxDistanceModifierBase) == 0x000000, "Member 'FSBZHackerSkillSettingData::MaxDistanceModifierBase' has a wrong offset!");
static_assert(offsetof(FSBZHackerSkillSettingData, AdditionalBatteriesAcedBase) == 0x000004, "Member 'FSBZHackerSkillSettingData::AdditionalBatteriesAcedBase' has a wrong offset!");
static_assert(offsetof(FSBZHackerSkillSettingData, HackableDurationDecreaseMastery) == 0x000008, "Member 'FSBZHackerSkillSettingData::HackableDurationDecreaseMastery' has a wrong offset!");

// ScriptStruct Starbreeze.SBZMicroCameraSkillSettingData
// 0x0008 (0x0008 - 0x0000)
struct FSBZMicroCameraSkillSettingData final
{
public:
	float                                         AmountUpgradeBase;                                 // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationMastery01;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZMicroCameraSkillSettingData) == 0x000004, "Wrong alignment on FSBZMicroCameraSkillSettingData");
static_assert(sizeof(FSBZMicroCameraSkillSettingData) == 0x000008, "Wrong size on FSBZMicroCameraSkillSettingData");
static_assert(offsetof(FSBZMicroCameraSkillSettingData, AmountUpgradeBase) == 0x000000, "Member 'FSBZMicroCameraSkillSettingData::AmountUpgradeBase' has a wrong offset!");
static_assert(offsetof(FSBZMicroCameraSkillSettingData, DurationMastery01) == 0x000004, "Member 'FSBZMicroCameraSkillSettingData::DurationMastery01' has a wrong offset!");

// ScriptStruct Starbreeze.SBZCutterSkillSettingData
// 0x0018 (0x0018 - 0x0000)
struct FSBZCutterSkillSettingData final
{
public:
	float                                         CuttingDurationDecreaseBase;                       // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZCuttingMaterialTier                       MinCuttingMaterialTierBase;                        // 0x0004(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AmmoIncreaseAcedBase;                              // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CuttingDurationDecreaseMastery;                    // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZCuttingMaterialTier                       MinCuttingMaterialTierUpgrade01;                   // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AmmoIncreaseUpgrade03;                             // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZCutterSkillSettingData) == 0x000004, "Wrong alignment on FSBZCutterSkillSettingData");
static_assert(sizeof(FSBZCutterSkillSettingData) == 0x000018, "Wrong size on FSBZCutterSkillSettingData");
static_assert(offsetof(FSBZCutterSkillSettingData, CuttingDurationDecreaseBase) == 0x000000, "Member 'FSBZCutterSkillSettingData::CuttingDurationDecreaseBase' has a wrong offset!");
static_assert(offsetof(FSBZCutterSkillSettingData, MinCuttingMaterialTierBase) == 0x000004, "Member 'FSBZCutterSkillSettingData::MinCuttingMaterialTierBase' has a wrong offset!");
static_assert(offsetof(FSBZCutterSkillSettingData, AmmoIncreaseAcedBase) == 0x000008, "Member 'FSBZCutterSkillSettingData::AmmoIncreaseAcedBase' has a wrong offset!");
static_assert(offsetof(FSBZCutterSkillSettingData, CuttingDurationDecreaseMastery) == 0x00000C, "Member 'FSBZCutterSkillSettingData::CuttingDurationDecreaseMastery' has a wrong offset!");
static_assert(offsetof(FSBZCutterSkillSettingData, MinCuttingMaterialTierUpgrade01) == 0x000010, "Member 'FSBZCutterSkillSettingData::MinCuttingMaterialTierUpgrade01' has a wrong offset!");
static_assert(offsetof(FSBZCutterSkillSettingData, AmmoIncreaseUpgrade03) == 0x000014, "Member 'FSBZCutterSkillSettingData::AmmoIncreaseUpgrade03' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSkillSettingData
// 0x002C (0x002C - 0x0000)
struct FSBZSkillSettingData final
{
public:
	struct FSBZHackerSkillSettingData             Hacker;                                            // 0x0000(0x000C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FSBZMicroCameraSkillSettingData        MicroCamera;                                       // 0x000C(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FSBZCutterSkillSettingData             Cutter;                                            // 0x0014(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSkillSettingData) == 0x000004, "Wrong alignment on FSBZSkillSettingData");
static_assert(sizeof(FSBZSkillSettingData) == 0x00002C, "Wrong size on FSBZSkillSettingData");
static_assert(offsetof(FSBZSkillSettingData, Hacker) == 0x000000, "Member 'FSBZSkillSettingData::Hacker' has a wrong offset!");
static_assert(offsetof(FSBZSkillSettingData, MicroCamera) == 0x00000C, "Member 'FSBZSkillSettingData::MicroCamera' has a wrong offset!");
static_assert(offsetof(FSBZSkillSettingData, Cutter) == 0x000014, "Member 'FSBZSkillSettingData::Cutter' has a wrong offset!");

// ScriptStruct Starbreeze.SBZVelocityTrackedComponentArrayData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FSBZVelocityTrackedComponentArrayData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZVelocityTrackedComponentArrayData) == 0x000008, "Wrong alignment on FSBZVelocityTrackedComponentArrayData");
static_assert(sizeof(FSBZVelocityTrackedComponentArrayData) == 0x000010, "Wrong size on FSBZVelocityTrackedComponentArrayData");

// ScriptStruct Starbreeze.SBZItemProvidedBySkill
// 0x0018 (0x0018 - 0x0000)
struct FSBZItemProvidedBySkill final
{
public:
	bool                                          bIsAvailable;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USBZSkillLine*                          SkillLineToUnlock;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZInventoryBaseData*                  InventoryBaseData;                                 // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZItemProvidedBySkill) == 0x000008, "Wrong alignment on FSBZItemProvidedBySkill");
static_assert(sizeof(FSBZItemProvidedBySkill) == 0x000018, "Wrong size on FSBZItemProvidedBySkill");
static_assert(offsetof(FSBZItemProvidedBySkill, bIsAvailable) == 0x000000, "Member 'FSBZItemProvidedBySkill::bIsAvailable' has a wrong offset!");
static_assert(offsetof(FSBZItemProvidedBySkill, SkillLineToUnlock) == 0x000008, "Member 'FSBZItemProvidedBySkill::SkillLineToUnlock' has a wrong offset!");
static_assert(offsetof(FSBZItemProvidedBySkill, InventoryBaseData) == 0x000010, "Member 'FSBZItemProvidedBySkill::InventoryBaseData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZPendingUsingSpawnedCarryData
// 0x0010 (0x0010 - 0x0000)
struct FSBZPendingUsingSpawnedCarryData final
{
public:
	class ASBZCharacter*                          User;                                              // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZPendingUsingSpawnedCarryData) == 0x000008, "Wrong alignment on FSBZPendingUsingSpawnedCarryData");
static_assert(sizeof(FSBZPendingUsingSpawnedCarryData) == 0x000010, "Wrong size on FSBZPendingUsingSpawnedCarryData");
static_assert(offsetof(FSBZPendingUsingSpawnedCarryData, User) == 0x000000, "Member 'FSBZPendingUsingSpawnedCarryData::User' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSpawnedCarryData
// 0x0040 (0x0040 - 0x0000)
struct FSBZSpawnedCarryData final
{
public:
	struct FQuat                                  Quat;                                              // 0x0000(0x0010)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    Location;                                          // 0x0010(0x000C)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        NetID;                                             // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Seed;                                              // 0x002C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SpawnedActor;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsPagerEnabled : 1;                               // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZSpawnedCarryData) == 0x000010, "Wrong alignment on FSBZSpawnedCarryData");
static_assert(sizeof(FSBZSpawnedCarryData) == 0x000040, "Wrong size on FSBZSpawnedCarryData");
static_assert(offsetof(FSBZSpawnedCarryData, Quat) == 0x000000, "Member 'FSBZSpawnedCarryData::Quat' has a wrong offset!");
static_assert(offsetof(FSBZSpawnedCarryData, Location) == 0x000010, "Member 'FSBZSpawnedCarryData::Location' has a wrong offset!");
static_assert(offsetof(FSBZSpawnedCarryData, ActorClass) == 0x000020, "Member 'FSBZSpawnedCarryData::ActorClass' has a wrong offset!");
static_assert(offsetof(FSBZSpawnedCarryData, NetID) == 0x000028, "Member 'FSBZSpawnedCarryData::NetID' has a wrong offset!");
static_assert(offsetof(FSBZSpawnedCarryData, Seed) == 0x00002C, "Member 'FSBZSpawnedCarryData::Seed' has a wrong offset!");
static_assert(offsetof(FSBZSpawnedCarryData, SpawnedActor) == 0x000030, "Member 'FSBZSpawnedCarryData::SpawnedActor' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSpawnLocation
// 0x0058 (0x0058 - 0x0000)
struct FSBZSpawnLocation final
{
public:
	struct FSBZLocationInformation                LocationInformation;                               // 0x0000(0x0048)(Edit, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         PossibleSpawningActors;                            // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSpawnLocation) == 0x000008, "Wrong alignment on FSBZSpawnLocation");
static_assert(sizeof(FSBZSpawnLocation) == 0x000058, "Wrong size on FSBZSpawnLocation");
static_assert(offsetof(FSBZSpawnLocation, LocationInformation) == 0x000000, "Member 'FSBZSpawnLocation::LocationInformation' has a wrong offset!");
static_assert(offsetof(FSBZSpawnLocation, PossibleSpawningActors) == 0x000048, "Member 'FSBZSpawnLocation::PossibleSpawningActors' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSpawnAttachData
// 0x0040 (0x0040 - 0x0000)
struct FSBZSpawnAttachData final
{
public:
	class USceneComponent*                        AttachComponent;                                   // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnTransform;                                    // 0x0010(0x0030)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSpawnAttachData) == 0x000010, "Wrong alignment on FSBZSpawnAttachData");
static_assert(sizeof(FSBZSpawnAttachData) == 0x000040, "Wrong size on FSBZSpawnAttachData");
static_assert(offsetof(FSBZSpawnAttachData, AttachComponent) == 0x000000, "Member 'FSBZSpawnAttachData::AttachComponent' has a wrong offset!");
static_assert(offsetof(FSBZSpawnAttachData, SpawnTransform) == 0x000010, "Member 'FSBZSpawnAttachData::SpawnTransform' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSpawnActorLocationData
// 0x0068 (0x0068 - 0x0000)
struct FSBZSpawnActorLocationData final
{
public:
	class AActor*                                 SpawnActor;                                        // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSBZLocationInformation                ActorLocationInfo;                                 // 0x0008(0x0048)(Transient, NativeAccessSpecifierPublic)
	int32                                         RoomLocationIndex;                                 // 0x0050(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSBZSpawnAttachData>            SpawnAttachDataArray;                              // 0x0058(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSpawnActorLocationData) == 0x000008, "Wrong alignment on FSBZSpawnActorLocationData");
static_assert(sizeof(FSBZSpawnActorLocationData) == 0x000068, "Wrong size on FSBZSpawnActorLocationData");
static_assert(offsetof(FSBZSpawnActorLocationData, SpawnActor) == 0x000000, "Member 'FSBZSpawnActorLocationData::SpawnActor' has a wrong offset!");
static_assert(offsetof(FSBZSpawnActorLocationData, ActorLocationInfo) == 0x000008, "Member 'FSBZSpawnActorLocationData::ActorLocationInfo' has a wrong offset!");
static_assert(offsetof(FSBZSpawnActorLocationData, RoomLocationIndex) == 0x000050, "Member 'FSBZSpawnActorLocationData::RoomLocationIndex' has a wrong offset!");
static_assert(offsetof(FSBZSpawnActorLocationData, SpawnAttachDataArray) == 0x000058, "Member 'FSBZSpawnActorLocationData::SpawnAttachDataArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSpawnRequestOptions
// 0x0014 (0x0014 - 0x0000)
struct FSBZSpawnRequestOptions final
{
public:
	uint8                                         Priority;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Delay;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Spacing;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timeout;                                           // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpawnActorCollisionHandlingMethod            CollisionHandlingMethod;                           // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZSpawnRequestOptions) == 0x000004, "Wrong alignment on FSBZSpawnRequestOptions");
static_assert(sizeof(FSBZSpawnRequestOptions) == 0x000014, "Wrong size on FSBZSpawnRequestOptions");
static_assert(offsetof(FSBZSpawnRequestOptions, Priority) == 0x000000, "Member 'FSBZSpawnRequestOptions::Priority' has a wrong offset!");
static_assert(offsetof(FSBZSpawnRequestOptions, Delay) == 0x000004, "Member 'FSBZSpawnRequestOptions::Delay' has a wrong offset!");
static_assert(offsetof(FSBZSpawnRequestOptions, Spacing) == 0x000008, "Member 'FSBZSpawnRequestOptions::Spacing' has a wrong offset!");
static_assert(offsetof(FSBZSpawnRequestOptions, Timeout) == 0x00000C, "Member 'FSBZSpawnRequestOptions::Timeout' has a wrong offset!");
static_assert(offsetof(FSBZSpawnRequestOptions, CollisionHandlingMethod) == 0x000010, "Member 'FSBZSpawnRequestOptions::CollisionHandlingMethod' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSpawnWaveFilteredOrder
// 0x0028 (0x0028 - 0x0000)
struct FSBZSpawnWaveFilteredOrder final
{
public:
	TSubclassOf<class USBZAIOrder>                OrderClass;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  PawnTypes;                                         // 0x0008(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSpawnWaveFilteredOrder) == 0x000008, "Wrong alignment on FSBZSpawnWaveFilteredOrder");
static_assert(sizeof(FSBZSpawnWaveFilteredOrder) == 0x000028, "Wrong size on FSBZSpawnWaveFilteredOrder");
static_assert(offsetof(FSBZSpawnWaveFilteredOrder, OrderClass) == 0x000000, "Member 'FSBZSpawnWaveFilteredOrder::OrderClass' has a wrong offset!");
static_assert(offsetof(FSBZSpawnWaveFilteredOrder, PawnTypes) == 0x000008, "Member 'FSBZSpawnWaveFilteredOrder::PawnTypes' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSpawnWaveFilteredBehavior
// 0x0028 (0x0028 - 0x0000)
struct FSBZSpawnWaveFilteredBehavior final
{
public:
	class UBehaviorTree*                          BehaviorTree;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  PawnTypes;                                         // 0x0008(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSpawnWaveFilteredBehavior) == 0x000008, "Wrong alignment on FSBZSpawnWaveFilteredBehavior");
static_assert(sizeof(FSBZSpawnWaveFilteredBehavior) == 0x000028, "Wrong size on FSBZSpawnWaveFilteredBehavior");
static_assert(offsetof(FSBZSpawnWaveFilteredBehavior, BehaviorTree) == 0x000000, "Member 'FSBZSpawnWaveFilteredBehavior::BehaviorTree' has a wrong offset!");
static_assert(offsetof(FSBZSpawnWaveFilteredBehavior, PawnTypes) == 0x000008, "Member 'FSBZSpawnWaveFilteredBehavior::PawnTypes' has a wrong offset!");

// ScriptStruct Starbreeze.SBZProgressionWaveMapping
// 0x0008 (0x0008 - 0x0000)
struct FSBZProgressionWaveMapping final
{
public:
	float                                         Progression;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WaveIndex;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZProgressionWaveMapping) == 0x000004, "Wrong alignment on FSBZProgressionWaveMapping");
static_assert(sizeof(FSBZProgressionWaveMapping) == 0x000008, "Wrong size on FSBZProgressionWaveMapping");
static_assert(offsetof(FSBZProgressionWaveMapping, Progression) == 0x000000, "Member 'FSBZProgressionWaveMapping::Progression' has a wrong offset!");
static_assert(offsetof(FSBZProgressionWaveMapping, WaveIndex) == 0x000004, "Member 'FSBZProgressionWaveMapping::WaveIndex' has a wrong offset!");

// ScriptStruct Starbreeze.SBZRestartLevelInfo
// 0x0004 (0x0004 - 0x0000)
struct FSBZRestartLevelInfo final
{
public:
	int32                                         LevelIdx;                                          // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZRestartLevelInfo) == 0x000004, "Wrong alignment on FSBZRestartLevelInfo");
static_assert(sizeof(FSBZRestartLevelInfo) == 0x000004, "Wrong size on FSBZRestartLevelInfo");
static_assert(offsetof(FSBZRestartLevelInfo, LevelIdx) == 0x000000, "Member 'FSBZRestartLevelInfo::LevelIdx' has a wrong offset!");

// ScriptStruct Starbreeze.PlayerWaitingActionPhaseState
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FPlayerWaitingActionPhaseState final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerWaitingActionPhaseState) == 0x000008, "Wrong alignment on FPlayerWaitingActionPhaseState");
static_assert(sizeof(FPlayerWaitingActionPhaseState) == 0x000030, "Wrong size on FPlayerWaitingActionPhaseState");

// ScriptStruct Starbreeze.SBZSteeringSpline
// 0x0080 (0x0080 - 0x0000)
struct alignas(0x08) FSBZSteeringSpline final
{
public:
	uint8                                         Pad_0[0x80];                                       // 0x0000(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZSteeringSpline) == 0x000008, "Wrong alignment on FSBZSteeringSpline");
static_assert(sizeof(FSBZSteeringSpline) == 0x000080, "Wrong size on FSBZSteeringSpline");

// ScriptStruct Starbreeze.SBZServerStoreInfo
// 0x0020 (0x0020 - 0x0000)
struct FSBZServerStoreInfo final
{
public:
	struct FGuid                                  ItemId;                                            // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemNamespace;                                     // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZServerStoreInfo) == 0x000008, "Wrong alignment on FSBZServerStoreInfo");
static_assert(sizeof(FSBZServerStoreInfo) == 0x000020, "Wrong size on FSBZServerStoreInfo");
static_assert(offsetof(FSBZServerStoreInfo, ItemId) == 0x000000, "Member 'FSBZServerStoreInfo::ItemId' has a wrong offset!");
static_assert(offsetof(FSBZServerStoreInfo, ItemNamespace) == 0x000010, "Member 'FSBZServerStoreInfo::ItemNamespace' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSuitBaseVariant
// 0x0050 (0x0050 - 0x0000)
struct FSBZSuitBaseVariant final
{
public:
	TSoftObjectPtr<class USkeletalMesh>           SkeletalMesh3P;                                    // 0x0000(0x0030)(Edit, DisableEditOnTemplate, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint32>                                LowerPartMaterialSlotIndex;                        // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<uint32>                                UpperPartMaterialSlotIndex;                        // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSuitBaseVariant) == 0x000008, "Wrong alignment on FSBZSuitBaseVariant");
static_assert(sizeof(FSBZSuitBaseVariant) == 0x000050, "Wrong size on FSBZSuitBaseVariant");
static_assert(offsetof(FSBZSuitBaseVariant, SkeletalMesh3P) == 0x000000, "Member 'FSBZSuitBaseVariant::SkeletalMesh3P' has a wrong offset!");
static_assert(offsetof(FSBZSuitBaseVariant, LowerPartMaterialSlotIndex) == 0x000030, "Member 'FSBZSuitBaseVariant::LowerPartMaterialSlotIndex' has a wrong offset!");
static_assert(offsetof(FSBZSuitBaseVariant, UpperPartMaterialSlotIndex) == 0x000040, "Member 'FSBZSuitBaseVariant::UpperPartMaterialSlotIndex' has a wrong offset!");

// ScriptStruct Starbreeze.SBZSurfaceType
// 0x0080 (0x0080 - 0x0000)
struct FSBZSurfaceType final
{
public:
	ESBZAISoundSurfaceTypes                       AISoundSurfaceType;                                // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USBZProjectileImpactConfig*             ProjectileImpactConfig;                            // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZThrowableProjectileImpactConfig*    ThrowableProjectileImpactConfig;                   // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZMeleeImpactConfig*                  MeleeImpactConfig;                                 // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZExplosionImpactConfig*              ExplosionImpactConfig;                             // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZFootstepImpactConfig*               FootstepImpactConfig;                              // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZSlidingImpactConfig*                SlidingImpactConfig;                               // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZMantlingImpactConfig*               MantlingImpactConfig;                              // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZStepUpImpactConfig*                 StepUpImpactConfig;                                // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZObjectImpactConfig*                 ObjectImpactConfig;                                // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZDebrisImpactConfig*                 DebrisImpactConfig;                                // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZThrowableImpactConfig*              ThrowableImpactConfig;                             // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZBagItemImpactConfig*                BagItemImpactConfig;                               // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZBloodSplatterImpactConfig*          BloodSplatterImpactConfig;                         // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MaterialSoundSwitchState;                          // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZSurfaceType) == 0x000008, "Wrong alignment on FSBZSurfaceType");
static_assert(sizeof(FSBZSurfaceType) == 0x000080, "Wrong size on FSBZSurfaceType");
static_assert(offsetof(FSBZSurfaceType, AISoundSurfaceType) == 0x000000, "Member 'FSBZSurfaceType::AISoundSurfaceType' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceType, ProjectileImpactConfig) == 0x000008, "Member 'FSBZSurfaceType::ProjectileImpactConfig' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceType, ThrowableProjectileImpactConfig) == 0x000010, "Member 'FSBZSurfaceType::ThrowableProjectileImpactConfig' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceType, MeleeImpactConfig) == 0x000018, "Member 'FSBZSurfaceType::MeleeImpactConfig' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceType, ExplosionImpactConfig) == 0x000020, "Member 'FSBZSurfaceType::ExplosionImpactConfig' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceType, FootstepImpactConfig) == 0x000028, "Member 'FSBZSurfaceType::FootstepImpactConfig' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceType, SlidingImpactConfig) == 0x000030, "Member 'FSBZSurfaceType::SlidingImpactConfig' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceType, MantlingImpactConfig) == 0x000038, "Member 'FSBZSurfaceType::MantlingImpactConfig' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceType, StepUpImpactConfig) == 0x000040, "Member 'FSBZSurfaceType::StepUpImpactConfig' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceType, ObjectImpactConfig) == 0x000048, "Member 'FSBZSurfaceType::ObjectImpactConfig' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceType, DebrisImpactConfig) == 0x000050, "Member 'FSBZSurfaceType::DebrisImpactConfig' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceType, ThrowableImpactConfig) == 0x000058, "Member 'FSBZSurfaceType::ThrowableImpactConfig' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceType, BagItemImpactConfig) == 0x000060, "Member 'FSBZSurfaceType::BagItemImpactConfig' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceType, BloodSplatterImpactConfig) == 0x000068, "Member 'FSBZSurfaceType::BloodSplatterImpactConfig' has a wrong offset!");
static_assert(offsetof(FSBZSurfaceType, MaterialSoundSwitchState) == 0x000070, "Member 'FSBZSurfaceType::MaterialSoundSwitchState' has a wrong offset!");

// ScriptStruct Starbreeze.SBZTagReactionActivation
// 0x0018 (0x0018 - 0x0000)
struct FSBZTagReactionActivation final
{
public:
	TArray<class UAnimMontage*>                   MontageArray;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         RandomOffset;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZTagReactionActivation) == 0x000008, "Wrong alignment on FSBZTagReactionActivation");
static_assert(sizeof(FSBZTagReactionActivation) == 0x000018, "Wrong size on FSBZTagReactionActivation");
static_assert(offsetof(FSBZTagReactionActivation, MontageArray) == 0x000000, "Member 'FSBZTagReactionActivation::MontageArray' has a wrong offset!");
static_assert(offsetof(FSBZTagReactionActivation, RandomOffset) == 0x000010, "Member 'FSBZTagReactionActivation::RandomOffset' has a wrong offset!");

// ScriptStruct Starbreeze.SBZTagReaction
// 0x0110 (0x0110 - 0x0000)
struct FSBZTagReaction final
{
public:
	struct FSBZTagReactionActivation              ActivateStanding;                                  // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSBZTagReactionActivation              ActivateCrouching;                                 // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSBZTagReactionActivation              ActivateLyingOnFront;                              // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSBZTagReactionActivation              ActivateLyingOnBack;                               // 0x0048(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSBZTagReactionActivation              DeactivateStanding;                                // 0x0060(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSBZTagReactionActivation              DeactivateCrouching;                               // 0x0078(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSBZTagReactionActivation              DeactivateLyingOnFront;                            // 0x0090(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSBZTagReactionActivation              DeactivateLyingOnBack;                             // 0x00A8(0x0018)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Priority;                                          // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         TagReactionEffect;                                 // 0x00C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZVoiceCommentDataAsset*              TagReactionStartedComment;                         // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZVoiceCommentDataAsset*              TagReactionEndedComment;                           // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EffectSocket;                                      // 0x00E0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  BlockingTags;                                      // 0x00F0(0x0020)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZTagReaction) == 0x000008, "Wrong alignment on FSBZTagReaction");
static_assert(sizeof(FSBZTagReaction) == 0x000110, "Wrong size on FSBZTagReaction");
static_assert(offsetof(FSBZTagReaction, ActivateStanding) == 0x000000, "Member 'FSBZTagReaction::ActivateStanding' has a wrong offset!");
static_assert(offsetof(FSBZTagReaction, ActivateCrouching) == 0x000018, "Member 'FSBZTagReaction::ActivateCrouching' has a wrong offset!");
static_assert(offsetof(FSBZTagReaction, ActivateLyingOnFront) == 0x000030, "Member 'FSBZTagReaction::ActivateLyingOnFront' has a wrong offset!");
static_assert(offsetof(FSBZTagReaction, ActivateLyingOnBack) == 0x000048, "Member 'FSBZTagReaction::ActivateLyingOnBack' has a wrong offset!");
static_assert(offsetof(FSBZTagReaction, DeactivateStanding) == 0x000060, "Member 'FSBZTagReaction::DeactivateStanding' has a wrong offset!");
static_assert(offsetof(FSBZTagReaction, DeactivateCrouching) == 0x000078, "Member 'FSBZTagReaction::DeactivateCrouching' has a wrong offset!");
static_assert(offsetof(FSBZTagReaction, DeactivateLyingOnFront) == 0x000090, "Member 'FSBZTagReaction::DeactivateLyingOnFront' has a wrong offset!");
static_assert(offsetof(FSBZTagReaction, DeactivateLyingOnBack) == 0x0000A8, "Member 'FSBZTagReaction::DeactivateLyingOnBack' has a wrong offset!");
static_assert(offsetof(FSBZTagReaction, Priority) == 0x0000C0, "Member 'FSBZTagReaction::Priority' has a wrong offset!");
static_assert(offsetof(FSBZTagReaction, TagReactionEffect) == 0x0000C8, "Member 'FSBZTagReaction::TagReactionEffect' has a wrong offset!");
static_assert(offsetof(FSBZTagReaction, TagReactionStartedComment) == 0x0000D0, "Member 'FSBZTagReaction::TagReactionStartedComment' has a wrong offset!");
static_assert(offsetof(FSBZTagReaction, TagReactionEndedComment) == 0x0000D8, "Member 'FSBZTagReaction::TagReactionEndedComment' has a wrong offset!");
static_assert(offsetof(FSBZTagReaction, EffectSocket) == 0x0000E0, "Member 'FSBZTagReaction::EffectSocket' has a wrong offset!");
static_assert(offsetof(FSBZTagReaction, BlockingTags) == 0x0000F0, "Member 'FSBZTagReaction::BlockingTags' has a wrong offset!");

// ScriptStruct Starbreeze.SBZArmorVariationInfo
// 0x0014 (0x0014 - 0x0000)
struct FSBZArmorVariationInfo final
{
public:
	class FName                                   Name;                                              // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Bit;                                               // 0x0010(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZArmorVariationInfo) == 0x000004, "Wrong alignment on FSBZArmorVariationInfo");
static_assert(sizeof(FSBZArmorVariationInfo) == 0x000014, "Wrong size on FSBZArmorVariationInfo");
static_assert(offsetof(FSBZArmorVariationInfo, Name) == 0x000000, "Member 'FSBZArmorVariationInfo::Name' has a wrong offset!");
static_assert(offsetof(FSBZArmorVariationInfo, Index) == 0x00000C, "Member 'FSBZArmorVariationInfo::Index' has a wrong offset!");
static_assert(offsetof(FSBZArmorVariationInfo, Bit) == 0x000010, "Member 'FSBZArmorVariationInfo::Bit' has a wrong offset!");

// ScriptStruct Starbreeze.SBZAIGasGrenadeDifficultyData
// 0x0018 (0x0018 - 0x0000)
struct FSBZAIGasGrenadeDifficultyData final
{
public:
	float                                         DamagePerSecond;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationSeconds;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TickSeconds;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverHealDamageMultiplier;                          // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmorPenetration;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DropDamage;                                        // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZAIGasGrenadeDifficultyData) == 0x000004, "Wrong alignment on FSBZAIGasGrenadeDifficultyData");
static_assert(sizeof(FSBZAIGasGrenadeDifficultyData) == 0x000018, "Wrong size on FSBZAIGasGrenadeDifficultyData");
static_assert(offsetof(FSBZAIGasGrenadeDifficultyData, DamagePerSecond) == 0x000000, "Member 'FSBZAIGasGrenadeDifficultyData::DamagePerSecond' has a wrong offset!");
static_assert(offsetof(FSBZAIGasGrenadeDifficultyData, DurationSeconds) == 0x000004, "Member 'FSBZAIGasGrenadeDifficultyData::DurationSeconds' has a wrong offset!");
static_assert(offsetof(FSBZAIGasGrenadeDifficultyData, TickSeconds) == 0x000008, "Member 'FSBZAIGasGrenadeDifficultyData::TickSeconds' has a wrong offset!");
static_assert(offsetof(FSBZAIGasGrenadeDifficultyData, OverHealDamageMultiplier) == 0x00000C, "Member 'FSBZAIGasGrenadeDifficultyData::OverHealDamageMultiplier' has a wrong offset!");
static_assert(offsetof(FSBZAIGasGrenadeDifficultyData, ArmorPenetration) == 0x000010, "Member 'FSBZAIGasGrenadeDifficultyData::ArmorPenetration' has a wrong offset!");
static_assert(offsetof(FSBZAIGasGrenadeDifficultyData, DropDamage) == 0x000014, "Member 'FSBZAIGasGrenadeDifficultyData::DropDamage' has a wrong offset!");

// ScriptStruct Starbreeze.SBZActorThrowNetData
// 0x0018 (0x0018 - 0x0000)
struct FSBZActorThrowNetData final
{
public:
	class AActor*                                 ActorToThrow;                                      // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ThrowForce;                                        // 0x0008(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZActorThrowNetData) == 0x000008, "Wrong alignment on FSBZActorThrowNetData");
static_assert(sizeof(FSBZActorThrowNetData) == 0x000018, "Wrong size on FSBZActorThrowNetData");
static_assert(offsetof(FSBZActorThrowNetData, ActorToThrow) == 0x000000, "Member 'FSBZActorThrowNetData::ActorToThrow' has a wrong offset!");
static_assert(offsetof(FSBZActorThrowNetData, ThrowForce) == 0x000008, "Member 'FSBZActorThrowNetData::ThrowForce' has a wrong offset!");

// ScriptStruct Starbreeze.SBZTickingLootDifficultySettings
// 0x0120 (0x0120 - 0x0000)
struct FSBZTickingLootDifficultySettings final
{
public:
	struct FRuntimeFloatCurve                     CounterSpeedCurve;                                 // 0x0000(0x0088)(Edit, NativeAccessSpecifierPublic)
	int32                                         ObjectiveValue;                                    // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecreaseAmount;                                    // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     CounterDecreaseSpeedCurve;                         // 0x0090(0x0088)(Edit, NativeAccessSpecifierPublic)
	float                                         MinValuePercent;                                   // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValuePercent;                                   // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZTickingLootDifficultySettings) == 0x000008, "Wrong alignment on FSBZTickingLootDifficultySettings");
static_assert(sizeof(FSBZTickingLootDifficultySettings) == 0x000120, "Wrong size on FSBZTickingLootDifficultySettings");
static_assert(offsetof(FSBZTickingLootDifficultySettings, CounterSpeedCurve) == 0x000000, "Member 'FSBZTickingLootDifficultySettings::CounterSpeedCurve' has a wrong offset!");
static_assert(offsetof(FSBZTickingLootDifficultySettings, ObjectiveValue) == 0x000088, "Member 'FSBZTickingLootDifficultySettings::ObjectiveValue' has a wrong offset!");
static_assert(offsetof(FSBZTickingLootDifficultySettings, DecreaseAmount) == 0x00008C, "Member 'FSBZTickingLootDifficultySettings::DecreaseAmount' has a wrong offset!");
static_assert(offsetof(FSBZTickingLootDifficultySettings, CounterDecreaseSpeedCurve) == 0x000090, "Member 'FSBZTickingLootDifficultySettings::CounterDecreaseSpeedCurve' has a wrong offset!");
static_assert(offsetof(FSBZTickingLootDifficultySettings, MinValuePercent) == 0x000118, "Member 'FSBZTickingLootDifficultySettings::MinValuePercent' has a wrong offset!");
static_assert(offsetof(FSBZTickingLootDifficultySettings, MaxValuePercent) == 0x00011C, "Member 'FSBZTickingLootDifficultySettings::MaxValuePercent' has a wrong offset!");

// ScriptStruct Starbreeze.SBZLootCounterData
// 0x000C (0x000C - 0x0000)
struct FSBZLootCounterData final
{
public:
	float                                         CurrentLootCount;                                  // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredLootCount;                                  // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZTickingLootType                           TickingLootType;                                   // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZLootCounterData) == 0x000004, "Wrong alignment on FSBZLootCounterData");
static_assert(sizeof(FSBZLootCounterData) == 0x00000C, "Wrong size on FSBZLootCounterData");
static_assert(offsetof(FSBZLootCounterData, CurrentLootCount) == 0x000000, "Member 'FSBZLootCounterData::CurrentLootCount' has a wrong offset!");
static_assert(offsetof(FSBZLootCounterData, DesiredLootCount) == 0x000004, "Member 'FSBZLootCounterData::DesiredLootCount' has a wrong offset!");
static_assert(offsetof(FSBZLootCounterData, TickingLootType) == 0x000008, "Member 'FSBZLootCounterData::TickingLootType' has a wrong offset!");

// ScriptStruct Starbreeze.SBZGameTimeTo
// 0x0010 (0x0010 - 0x0000)
struct FSBZGameTimeTo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                WorldContextObject;                                // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FSBZGameTimeTo) == 0x000008, "Wrong alignment on FSBZGameTimeTo");
static_assert(sizeof(FSBZGameTimeTo) == 0x000010, "Wrong size on FSBZGameTimeTo");
static_assert(offsetof(FSBZGameTimeTo, WorldContextObject) == 0x000008, "Member 'FSBZGameTimeTo::WorldContextObject' has a wrong offset!");

// ScriptStruct Starbreeze.SBZGameTimeSince
// 0x0010 (0x0010 - 0x0000)
struct FSBZGameTimeSince final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                WorldContextObject;                                // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FSBZGameTimeSince) == 0x000008, "Wrong alignment on FSBZGameTimeSince");
static_assert(sizeof(FSBZGameTimeSince) == 0x000010, "Wrong size on FSBZGameTimeSince");
static_assert(offsetof(FSBZGameTimeSince, WorldContextObject) == 0x000008, "Member 'FSBZGameTimeSince::WorldContextObject' has a wrong offset!");

// ScriptStruct Starbreeze.SBZTrafficLightPool
// 0x0030 (0x0030 - 0x0000)
struct FSBZTrafficLightPool final
{
public:
	TArray<class ASBZTrafficVolume*>              BlockerArray;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AStaticMeshActor*>               MeshArray;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         GreenTimer;                                        // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwitchToGreenTimer;                                // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwitchToRedTimer;                                  // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZTrafficLightPool) == 0x000008, "Wrong alignment on FSBZTrafficLightPool");
static_assert(sizeof(FSBZTrafficLightPool) == 0x000030, "Wrong size on FSBZTrafficLightPool");
static_assert(offsetof(FSBZTrafficLightPool, BlockerArray) == 0x000000, "Member 'FSBZTrafficLightPool::BlockerArray' has a wrong offset!");
static_assert(offsetof(FSBZTrafficLightPool, MeshArray) == 0x000010, "Member 'FSBZTrafficLightPool::MeshArray' has a wrong offset!");
static_assert(offsetof(FSBZTrafficLightPool, GreenTimer) == 0x000020, "Member 'FSBZTrafficLightPool::GreenTimer' has a wrong offset!");
static_assert(offsetof(FSBZTrafficLightPool, SwitchToGreenTimer) == 0x000024, "Member 'FSBZTrafficLightPool::SwitchToGreenTimer' has a wrong offset!");
static_assert(offsetof(FSBZTrafficLightPool, SwitchToRedTimer) == 0x000028, "Member 'FSBZTrafficLightPool::SwitchToRedTimer' has a wrong offset!");

// ScriptStruct Starbreeze.SBZTrafficLightPoolState
// 0x0028 (0x0028 - 0x0000)
struct FSBZTrafficLightPoolState final
{
public:
	TArray<class UStaticMeshComponent*>           CachedMeshComponentArray;                          // 0x0000(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USBZAmbientSoundComponent*>      PedestrianSoundEmitters;                           // 0x0010(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ESBZTrafficLightStatus                        Status;                                            // 0x0020(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Timer;                                             // 0x0024(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZTrafficLightPoolState) == 0x000008, "Wrong alignment on FSBZTrafficLightPoolState");
static_assert(sizeof(FSBZTrafficLightPoolState) == 0x000028, "Wrong size on FSBZTrafficLightPoolState");
static_assert(offsetof(FSBZTrafficLightPoolState, CachedMeshComponentArray) == 0x000000, "Member 'FSBZTrafficLightPoolState::CachedMeshComponentArray' has a wrong offset!");
static_assert(offsetof(FSBZTrafficLightPoolState, PedestrianSoundEmitters) == 0x000010, "Member 'FSBZTrafficLightPoolState::PedestrianSoundEmitters' has a wrong offset!");
static_assert(offsetof(FSBZTrafficLightPoolState, Status) == 0x000020, "Member 'FSBZTrafficLightPoolState::Status' has a wrong offset!");
static_assert(offsetof(FSBZTrafficLightPoolState, Timer) == 0x000024, "Member 'FSBZTrafficLightPoolState::Timer' has a wrong offset!");

// ScriptStruct Starbreeze.SBZTrafficSoundHorn
// 0x0024 (0x0024 - 0x0000)
struct FSBZTrafficSoundHorn final
{
public:
	struct FFloatInterval                         TrafficLightBaseTimer;                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         TrafficLightQueueAddition;                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TrafficLightQueueStart;                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrafficLightChance;                                // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         StopWaitTimer;                                     // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopWaitChance;                                    // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZTrafficSoundHorn) == 0x000004, "Wrong alignment on FSBZTrafficSoundHorn");
static_assert(sizeof(FSBZTrafficSoundHorn) == 0x000024, "Wrong size on FSBZTrafficSoundHorn");
static_assert(offsetof(FSBZTrafficSoundHorn, TrafficLightBaseTimer) == 0x000000, "Member 'FSBZTrafficSoundHorn::TrafficLightBaseTimer' has a wrong offset!");
static_assert(offsetof(FSBZTrafficSoundHorn, TrafficLightQueueAddition) == 0x000008, "Member 'FSBZTrafficSoundHorn::TrafficLightQueueAddition' has a wrong offset!");
static_assert(offsetof(FSBZTrafficSoundHorn, TrafficLightQueueStart) == 0x000010, "Member 'FSBZTrafficSoundHorn::TrafficLightQueueStart' has a wrong offset!");
static_assert(offsetof(FSBZTrafficSoundHorn, TrafficLightChance) == 0x000014, "Member 'FSBZTrafficSoundHorn::TrafficLightChance' has a wrong offset!");
static_assert(offsetof(FSBZTrafficSoundHorn, StopWaitTimer) == 0x000018, "Member 'FSBZTrafficSoundHorn::StopWaitTimer' has a wrong offset!");
static_assert(offsetof(FSBZTrafficSoundHorn, StopWaitChance) == 0x000020, "Member 'FSBZTrafficSoundHorn::StopWaitChance' has a wrong offset!");

// ScriptStruct Starbreeze.SBZVehicleArrayElement
// 0x0010 (0x0010 - 0x0000)
struct FSBZVehicleArrayElement final
{
public:
	TSubclassOf<class ASBZWheeledVehicle>         Vehicle;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZVehicleArrayElement) == 0x000008, "Wrong alignment on FSBZVehicleArrayElement");
static_assert(sizeof(FSBZVehicleArrayElement) == 0x000010, "Wrong size on FSBZVehicleArrayElement");
static_assert(offsetof(FSBZVehicleArrayElement, Vehicle) == 0x000000, "Member 'FSBZVehicleArrayElement::Vehicle' has a wrong offset!");
static_assert(offsetof(FSBZVehicleArrayElement, Weight) == 0x000008, "Member 'FSBZVehicleArrayElement::Weight' has a wrong offset!");

// ScriptStruct Starbreeze.SBZTrafficCivilians
// 0x0040 (0x0040 - 0x0000)
struct FSBZTrafficCivilians final
{
public:
	TArray<TSubclassOf<class ASBZWheeledVehicle>> VehicleArray;                                      // 0x0000(0x0010)(ZeroConstructor, Deprecated, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FSBZVehicleArrayElement>        WeightedVehicleArray;                              // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FInt32Interval                         AmountVehicleToSpawnEachInterval;                  // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxAmountVehiclesInLevel;                          // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         VehicleSpawnInterval;                              // 0x002C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VehicleDriveOffSpeed;                              // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VehicleDriveOffTurnSpeed;                          // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZTrafficCivilians) == 0x000008, "Wrong alignment on FSBZTrafficCivilians");
static_assert(sizeof(FSBZTrafficCivilians) == 0x000040, "Wrong size on FSBZTrafficCivilians");
static_assert(offsetof(FSBZTrafficCivilians, VehicleArray) == 0x000000, "Member 'FSBZTrafficCivilians::VehicleArray' has a wrong offset!");
static_assert(offsetof(FSBZTrafficCivilians, WeightedVehicleArray) == 0x000010, "Member 'FSBZTrafficCivilians::WeightedVehicleArray' has a wrong offset!");
static_assert(offsetof(FSBZTrafficCivilians, AmountVehicleToSpawnEachInterval) == 0x000020, "Member 'FSBZTrafficCivilians::AmountVehicleToSpawnEachInterval' has a wrong offset!");
static_assert(offsetof(FSBZTrafficCivilians, MaxAmountVehiclesInLevel) == 0x000028, "Member 'FSBZTrafficCivilians::MaxAmountVehiclesInLevel' has a wrong offset!");
static_assert(offsetof(FSBZTrafficCivilians, VehicleSpawnInterval) == 0x00002C, "Member 'FSBZTrafficCivilians::VehicleSpawnInterval' has a wrong offset!");
static_assert(offsetof(FSBZTrafficCivilians, VehicleDriveOffSpeed) == 0x000034, "Member 'FSBZTrafficCivilians::VehicleDriveOffSpeed' has a wrong offset!");
static_assert(offsetof(FSBZTrafficCivilians, VehicleDriveOffTurnSpeed) == 0x000038, "Member 'FSBZTrafficCivilians::VehicleDriveOffTurnSpeed' has a wrong offset!");

// ScriptStruct Starbreeze.SBZTrafficSwatVans
// 0x0020 (0x0020 - 0x0000)
struct FSBZTrafficSwatVans final
{
public:
	TArray<TSubclassOf<class ASBZWheeledVehicle>> VehicleArray;                                      // 0x0000(0x0010)(ZeroConstructor, Deprecated, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FSBZVehicleArrayElement>        WeightedVehicleArray;                              // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZTrafficSwatVans) == 0x000008, "Wrong alignment on FSBZTrafficSwatVans");
static_assert(sizeof(FSBZTrafficSwatVans) == 0x000020, "Wrong size on FSBZTrafficSwatVans");
static_assert(offsetof(FSBZTrafficSwatVans, VehicleArray) == 0x000000, "Member 'FSBZTrafficSwatVans::VehicleArray' has a wrong offset!");
static_assert(offsetof(FSBZTrafficSwatVans, WeightedVehicleArray) == 0x000010, "Member 'FSBZTrafficSwatVans::WeightedVehicleArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZTrafficFBIVan
// 0x0030 (0x0030 - 0x0000)
struct FSBZTrafficFBIVan final
{
public:
	TArray<struct FSBZVehicleArrayElement>        WeightedVehicleArray;                              // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         SpawnChance[0x4];                                  // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaveSpawnChance[0x3];                              // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZTrafficFBIVan) == 0x000008, "Wrong alignment on FSBZTrafficFBIVan");
static_assert(sizeof(FSBZTrafficFBIVan) == 0x000030, "Wrong size on FSBZTrafficFBIVan");
static_assert(offsetof(FSBZTrafficFBIVan, WeightedVehicleArray) == 0x000000, "Member 'FSBZTrafficFBIVan::WeightedVehicleArray' has a wrong offset!");
static_assert(offsetof(FSBZTrafficFBIVan, SpawnChance) == 0x000010, "Member 'FSBZTrafficFBIVan::SpawnChance' has a wrong offset!");
static_assert(offsetof(FSBZTrafficFBIVan, WaveSpawnChance) == 0x000020, "Member 'FSBZTrafficFBIVan::WaveSpawnChance' has a wrong offset!");

// ScriptStruct Starbreeze.SBZTrafficFirstResponders
// 0x0028 (0x0028 - 0x0000)
struct FSBZTrafficFirstResponders final
{
public:
	TArray<TSubclassOf<class ASBZWheeledVehicle>> VehicleArray;                                      // 0x0000(0x0010)(ZeroConstructor, Deprecated, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FSBZVehicleArrayElement>        WeightedVehicleArray;                              // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         AmountVehiclesToSpawn;                             // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmountVehiclesToWaitOn;                            // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZTrafficFirstResponders) == 0x000008, "Wrong alignment on FSBZTrafficFirstResponders");
static_assert(sizeof(FSBZTrafficFirstResponders) == 0x000028, "Wrong size on FSBZTrafficFirstResponders");
static_assert(offsetof(FSBZTrafficFirstResponders, VehicleArray) == 0x000000, "Member 'FSBZTrafficFirstResponders::VehicleArray' has a wrong offset!");
static_assert(offsetof(FSBZTrafficFirstResponders, WeightedVehicleArray) == 0x000010, "Member 'FSBZTrafficFirstResponders::WeightedVehicleArray' has a wrong offset!");
static_assert(offsetof(FSBZTrafficFirstResponders, AmountVehiclesToSpawn) == 0x000020, "Member 'FSBZTrafficFirstResponders::AmountVehiclesToSpawn' has a wrong offset!");
static_assert(offsetof(FSBZTrafficFirstResponders, AmountVehiclesToWaitOn) == 0x000024, "Member 'FSBZTrafficFirstResponders::AmountVehiclesToWaitOn' has a wrong offset!");

// ScriptStruct Starbreeze.SBZTrafficSpawnInfo
// 0x0080 (0x0080 - 0x0000)
struct FSBZTrafficSpawnInfo final
{
public:
	TSubclassOf<class ASBZWheeledVehicle>         VehicleActorClass;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZTrafficVehicleType                        VehicleType;                                       // 0x0008(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnTransform;                                    // 0x0010(0x0030)(Edit, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x40];                                      // 0x0040(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZTrafficSpawnInfo) == 0x000010, "Wrong alignment on FSBZTrafficSpawnInfo");
static_assert(sizeof(FSBZTrafficSpawnInfo) == 0x000080, "Wrong size on FSBZTrafficSpawnInfo");
static_assert(offsetof(FSBZTrafficSpawnInfo, VehicleActorClass) == 0x000000, "Member 'FSBZTrafficSpawnInfo::VehicleActorClass' has a wrong offset!");
static_assert(offsetof(FSBZTrafficSpawnInfo, VehicleType) == 0x000008, "Member 'FSBZTrafficSpawnInfo::VehicleType' has a wrong offset!");
static_assert(offsetof(FSBZTrafficSpawnInfo, SpawnTransform) == 0x000010, "Member 'FSBZTrafficSpawnInfo::SpawnTransform' has a wrong offset!");

// ScriptStruct Starbreeze.SBZTrafficObstacleInfo
// 0x0018 (0x0018 - 0x0000)
struct FSBZTrafficObstacleInfo final
{
public:
	class AActor*                                 ObstacleActor;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASBZWheeledVehicle*                     ObstacleVehicle;                                   // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASBZTrafficVolume*                      ObstacleTrafficVolume;                             // 0x0010(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZTrafficObstacleInfo) == 0x000008, "Wrong alignment on FSBZTrafficObstacleInfo");
static_assert(sizeof(FSBZTrafficObstacleInfo) == 0x000018, "Wrong size on FSBZTrafficObstacleInfo");
static_assert(offsetof(FSBZTrafficObstacleInfo, ObstacleActor) == 0x000000, "Member 'FSBZTrafficObstacleInfo::ObstacleActor' has a wrong offset!");
static_assert(offsetof(FSBZTrafficObstacleInfo, ObstacleVehicle) == 0x000008, "Member 'FSBZTrafficObstacleInfo::ObstacleVehicle' has a wrong offset!");
static_assert(offsetof(FSBZTrafficObstacleInfo, ObstacleTrafficVolume) == 0x000010, "Member 'FSBZTrafficObstacleInfo::ObstacleTrafficVolume' has a wrong offset!");

// ScriptStruct Starbreeze.SBZTrafficVehicleInfo
// 0x00B0 (0x00B0 - 0x0000)
struct alignas(0x10) FSBZTrafficVehicleInfo final
{
public:
	class ASBZWheeledVehicle*                     Vehicle;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ASBZSpline*>                     CurrentRoute;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	ESBZTrafficVehicleType                        VehicleType;                                       // 0x0018(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSBZTrafficObstacleInfo>        ObstacleArray;                                     // 0x0020(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class ASBZWheeledVehicle*>             BehindVehicleArray;                                // 0x0030(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	float                                         WantedCruisingSpeed;                               // 0x0040(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WantedTurnCruisingSpeed;                           // 0x0044(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WantedAcceleration;                                // 0x0048(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WantedDeceleration;                                // 0x004C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentCruisingSpeed;                              // 0x0050(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentAcceleration;                               // 0x0054(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentDeceleration;                               // 0x0058(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBraking;                                        // 0x005C(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopped;                                          // 0x005D(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E[0x2];                                       // 0x005E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StopLocation;                                      // 0x0060(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x44];                                      // 0x006C(0x0044)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZTrafficVehicleInfo) == 0x000010, "Wrong alignment on FSBZTrafficVehicleInfo");
static_assert(sizeof(FSBZTrafficVehicleInfo) == 0x0000B0, "Wrong size on FSBZTrafficVehicleInfo");
static_assert(offsetof(FSBZTrafficVehicleInfo, Vehicle) == 0x000000, "Member 'FSBZTrafficVehicleInfo::Vehicle' has a wrong offset!");
static_assert(offsetof(FSBZTrafficVehicleInfo, CurrentRoute) == 0x000008, "Member 'FSBZTrafficVehicleInfo::CurrentRoute' has a wrong offset!");
static_assert(offsetof(FSBZTrafficVehicleInfo, VehicleType) == 0x000018, "Member 'FSBZTrafficVehicleInfo::VehicleType' has a wrong offset!");
static_assert(offsetof(FSBZTrafficVehicleInfo, ObstacleArray) == 0x000020, "Member 'FSBZTrafficVehicleInfo::ObstacleArray' has a wrong offset!");
static_assert(offsetof(FSBZTrafficVehicleInfo, BehindVehicleArray) == 0x000030, "Member 'FSBZTrafficVehicleInfo::BehindVehicleArray' has a wrong offset!");
static_assert(offsetof(FSBZTrafficVehicleInfo, WantedCruisingSpeed) == 0x000040, "Member 'FSBZTrafficVehicleInfo::WantedCruisingSpeed' has a wrong offset!");
static_assert(offsetof(FSBZTrafficVehicleInfo, WantedTurnCruisingSpeed) == 0x000044, "Member 'FSBZTrafficVehicleInfo::WantedTurnCruisingSpeed' has a wrong offset!");
static_assert(offsetof(FSBZTrafficVehicleInfo, WantedAcceleration) == 0x000048, "Member 'FSBZTrafficVehicleInfo::WantedAcceleration' has a wrong offset!");
static_assert(offsetof(FSBZTrafficVehicleInfo, WantedDeceleration) == 0x00004C, "Member 'FSBZTrafficVehicleInfo::WantedDeceleration' has a wrong offset!");
static_assert(offsetof(FSBZTrafficVehicleInfo, CurrentCruisingSpeed) == 0x000050, "Member 'FSBZTrafficVehicleInfo::CurrentCruisingSpeed' has a wrong offset!");
static_assert(offsetof(FSBZTrafficVehicleInfo, CurrentAcceleration) == 0x000054, "Member 'FSBZTrafficVehicleInfo::CurrentAcceleration' has a wrong offset!");
static_assert(offsetof(FSBZTrafficVehicleInfo, CurrentDeceleration) == 0x000058, "Member 'FSBZTrafficVehicleInfo::CurrentDeceleration' has a wrong offset!");
static_assert(offsetof(FSBZTrafficVehicleInfo, bIsBraking) == 0x00005C, "Member 'FSBZTrafficVehicleInfo::bIsBraking' has a wrong offset!");
static_assert(offsetof(FSBZTrafficVehicleInfo, bStopped) == 0x00005D, "Member 'FSBZTrafficVehicleInfo::bStopped' has a wrong offset!");
static_assert(offsetof(FSBZTrafficVehicleInfo, StopLocation) == 0x000060, "Member 'FSBZTrafficVehicleInfo::StopLocation' has a wrong offset!");

// ScriptStruct Starbreeze.SBZTrafficGridlockInfo
// 0x0018 (0x0018 - 0x0000)
struct FSBZTrafficGridlockInfo final
{
public:
	TArray<class ASBZWheeledVehicle*>             VehicleArray;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	float                                         GridlockBreakTimer;                                // 0x0010(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZTrafficGridlockInfo) == 0x000008, "Wrong alignment on FSBZTrafficGridlockInfo");
static_assert(sizeof(FSBZTrafficGridlockInfo) == 0x000018, "Wrong size on FSBZTrafficGridlockInfo");
static_assert(offsetof(FSBZTrafficGridlockInfo, VehicleArray) == 0x000000, "Member 'FSBZTrafficGridlockInfo::VehicleArray' has a wrong offset!");
static_assert(offsetof(FSBZTrafficGridlockInfo, GridlockBreakTimer) == 0x000010, "Member 'FSBZTrafficGridlockInfo::GridlockBreakTimer' has a wrong offset!");

// ScriptStruct Starbreeze.SBZTrafficRoute
// 0x0018 (0x0018 - 0x0000)
struct FSBZTrafficRoute final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VehicleTypeFlags;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ASBZTrafficSpline*>              Path;                                              // 0x0008(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZTrafficRoute) == 0x000008, "Wrong alignment on FSBZTrafficRoute");
static_assert(sizeof(FSBZTrafficRoute) == 0x000018, "Wrong size on FSBZTrafficRoute");
static_assert(offsetof(FSBZTrafficRoute, Distance) == 0x000000, "Member 'FSBZTrafficRoute::Distance' has a wrong offset!");
static_assert(offsetof(FSBZTrafficRoute, VehicleTypeFlags) == 0x000004, "Member 'FSBZTrafficRoute::VehicleTypeFlags' has a wrong offset!");
static_assert(offsetof(FSBZTrafficRoute, Path) == 0x000008, "Member 'FSBZTrafficRoute::Path' has a wrong offset!");

// ScriptStruct Starbreeze.SBZTrafficRouteArray
// 0x0010 (0x0010 - 0x0000)
struct FSBZTrafficRouteArray final
{
public:
	TArray<struct FSBZTrafficRoute>               RouteArray;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZTrafficRouteArray) == 0x000008, "Wrong alignment on FSBZTrafficRouteArray");
static_assert(sizeof(FSBZTrafficRouteArray) == 0x000010, "Wrong size on FSBZTrafficRouteArray");
static_assert(offsetof(FSBZTrafficRouteArray, RouteArray) == 0x000000, "Member 'FSBZTrafficRouteArray::RouteArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZTrafficDestinationNode
// 0x0068 (0x0068 - 0x0000)
struct FSBZTrafficDestinationNode final
{
public:
	bool                                          bOccupied;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ASBZTrafficSpline*>              SpawnerArray;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TMap<class ASBZTrafficSpline*, struct FSBZTrafficRouteArray> RouteArrayGraph;                    // 0x0018(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZTrafficDestinationNode) == 0x000008, "Wrong alignment on FSBZTrafficDestinationNode");
static_assert(sizeof(FSBZTrafficDestinationNode) == 0x000068, "Wrong size on FSBZTrafficDestinationNode");
static_assert(offsetof(FSBZTrafficDestinationNode, bOccupied) == 0x000000, "Member 'FSBZTrafficDestinationNode::bOccupied' has a wrong offset!");
static_assert(offsetof(FSBZTrafficDestinationNode, SpawnerArray) == 0x000008, "Member 'FSBZTrafficDestinationNode::SpawnerArray' has a wrong offset!");
static_assert(offsetof(FSBZTrafficDestinationNode, RouteArrayGraph) == 0x000018, "Member 'FSBZTrafficDestinationNode::RouteArrayGraph' has a wrong offset!");

// ScriptStruct Starbreeze.SBZTrafficSpawnerNode
// 0x0070 (0x0070 - 0x0000)
struct FSBZTrafficSpawnerNode final
{
public:
	TArray<class ASBZTrafficSpline*>              RouteArray;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class ASBZTrafficSpline*>              DestinationArray;                                  // 0x0010(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TMap<class ASBZTrafficSpline*, struct FSBZTrafficRouteArray> RouteArrayGraph;                    // 0x0020(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZTrafficSpawnerNode) == 0x000008, "Wrong alignment on FSBZTrafficSpawnerNode");
static_assert(sizeof(FSBZTrafficSpawnerNode) == 0x000070, "Wrong size on FSBZTrafficSpawnerNode");
static_assert(offsetof(FSBZTrafficSpawnerNode, RouteArray) == 0x000000, "Member 'FSBZTrafficSpawnerNode::RouteArray' has a wrong offset!");
static_assert(offsetof(FSBZTrafficSpawnerNode, DestinationArray) == 0x000010, "Member 'FSBZTrafficSpawnerNode::DestinationArray' has a wrong offset!");
static_assert(offsetof(FSBZTrafficSpawnerNode, RouteArrayGraph) == 0x000020, "Member 'FSBZTrafficSpawnerNode::RouteArrayGraph' has a wrong offset!");

// ScriptStruct Starbreeze.SBZTrafficNode
// 0x0020 (0x0020 - 0x0000)
struct FSBZTrafficNode final
{
public:
	TArray<class ASBZTrafficSpline*>              ForwardArray;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SplineTypeFlags;                                   // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VehicleTypeFlags;                                  // 0x0018(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsSpawner : 1;                                    // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsDestination : 1;                                // 0x001C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZTrafficNode) == 0x000008, "Wrong alignment on FSBZTrafficNode");
static_assert(sizeof(FSBZTrafficNode) == 0x000020, "Wrong size on FSBZTrafficNode");
static_assert(offsetof(FSBZTrafficNode, ForwardArray) == 0x000000, "Member 'FSBZTrafficNode::ForwardArray' has a wrong offset!");
static_assert(offsetof(FSBZTrafficNode, Distance) == 0x000010, "Member 'FSBZTrafficNode::Distance' has a wrong offset!");
static_assert(offsetof(FSBZTrafficNode, SplineTypeFlags) == 0x000014, "Member 'FSBZTrafficNode::SplineTypeFlags' has a wrong offset!");
static_assert(offsetof(FSBZTrafficNode, VehicleTypeFlags) == 0x000018, "Member 'FSBZTrafficNode::VehicleTypeFlags' has a wrong offset!");

// ScriptStruct Starbreeze.SBZTrafficObstacle_Debug
// 0x0010 (0x0010 - 0x0000)
struct FSBZTrafficObstacle_Debug final
{
public:
	class ASBZWheeledVehicle*                     Vehicle;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ObstacleActor;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZTrafficObstacle_Debug) == 0x000008, "Wrong alignment on FSBZTrafficObstacle_Debug");
static_assert(sizeof(FSBZTrafficObstacle_Debug) == 0x000010, "Wrong size on FSBZTrafficObstacle_Debug");
static_assert(offsetof(FSBZTrafficObstacle_Debug, Vehicle) == 0x000000, "Member 'FSBZTrafficObstacle_Debug::Vehicle' has a wrong offset!");
static_assert(offsetof(FSBZTrafficObstacle_Debug, ObstacleActor) == 0x000008, "Member 'FSBZTrafficObstacle_Debug::ObstacleActor' has a wrong offset!");

// ScriptStruct Starbreeze.SBZTrafficControl
// 0x0028 (0x0028 - 0x0000)
struct FSBZTrafficControl final
{
public:
	class ASBZWheeledVehicle*                     Vehicle;                                           // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZTrafficVehicleControlType                 ControlType;                                       // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ServerSpeed;                                       // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraveledDistance;                                  // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ASBZSpline*>                     Path;                                              // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZTrafficControl) == 0x000008, "Wrong alignment on FSBZTrafficControl");
static_assert(sizeof(FSBZTrafficControl) == 0x000028, "Wrong size on FSBZTrafficControl");
static_assert(offsetof(FSBZTrafficControl, Vehicle) == 0x000000, "Member 'FSBZTrafficControl::Vehicle' has a wrong offset!");
static_assert(offsetof(FSBZTrafficControl, ControlType) == 0x000008, "Member 'FSBZTrafficControl::ControlType' has a wrong offset!");
static_assert(offsetof(FSBZTrafficControl, Value) == 0x00000C, "Member 'FSBZTrafficControl::Value' has a wrong offset!");
static_assert(offsetof(FSBZTrafficControl, ServerSpeed) == 0x000010, "Member 'FSBZTrafficControl::ServerSpeed' has a wrong offset!");
static_assert(offsetof(FSBZTrafficControl, TraveledDistance) == 0x000014, "Member 'FSBZTrafficControl::TraveledDistance' has a wrong offset!");
static_assert(offsetof(FSBZTrafficControl, Path) == 0x000018, "Member 'FSBZTrafficControl::Path' has a wrong offset!");

// ScriptStruct Starbreeze.SBZShownPopupInfo
// 0x0088 (0x0088 - 0x0000)
struct FSBZShownPopupInfo final
{
public:
	struct FSBZUIPopupData                        PopupData;                                         // 0x0000(0x0060)(Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x28];                                      // 0x0060(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZShownPopupInfo) == 0x000008, "Wrong alignment on FSBZShownPopupInfo");
static_assert(sizeof(FSBZShownPopupInfo) == 0x000088, "Wrong size on FSBZShownPopupInfo");
static_assert(offsetof(FSBZShownPopupInfo, PopupData) == 0x000000, "Member 'FSBZShownPopupInfo::PopupData' has a wrong offset!");

// ScriptStruct Starbreeze.SBZUIDefaultSoundEvents
// 0x0008 (0x0008 - 0x0000)
struct FSBZUIDefaultSoundEvents final
{
public:
	class UAkAudioEvent*                          ButtonFocusedEvent;                                // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZUIDefaultSoundEvents) == 0x000008, "Wrong alignment on FSBZUIDefaultSoundEvents");
static_assert(sizeof(FSBZUIDefaultSoundEvents) == 0x000008, "Wrong size on FSBZUIDefaultSoundEvents");
static_assert(offsetof(FSBZUIDefaultSoundEvents, ButtonFocusedEvent) == 0x000000, "Member 'FSBZUIDefaultSoundEvents::ButtonFocusedEvent' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeaponStats
// 0x0018 (0x0018 - 0x0000)
struct FSBZWeaponStats final
{
public:
	float                                         Damage;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Recoil;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Stability;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Accuracy;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Handling;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireRate;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWeaponStats) == 0x000004, "Wrong alignment on FSBZWeaponStats");
static_assert(sizeof(FSBZWeaponStats) == 0x000018, "Wrong size on FSBZWeaponStats");
static_assert(offsetof(FSBZWeaponStats, Damage) == 0x000000, "Member 'FSBZWeaponStats::Damage' has a wrong offset!");
static_assert(offsetof(FSBZWeaponStats, Recoil) == 0x000004, "Member 'FSBZWeaponStats::Recoil' has a wrong offset!");
static_assert(offsetof(FSBZWeaponStats, Stability) == 0x000008, "Member 'FSBZWeaponStats::Stability' has a wrong offset!");
static_assert(offsetof(FSBZWeaponStats, Accuracy) == 0x00000C, "Member 'FSBZWeaponStats::Accuracy' has a wrong offset!");
static_assert(offsetof(FSBZWeaponStats, Handling) == 0x000010, "Member 'FSBZWeaponStats::Handling' has a wrong offset!");
static_assert(offsetof(FSBZWeaponStats, FireRate) == 0x000014, "Member 'FSBZWeaponStats::FireRate' has a wrong offset!");

// ScriptStruct Starbreeze.SBZUITrainingData
// 0x0088 (0x0088 - 0x0000)
struct FSBZUITrainingData final
{
public:
	struct FSBZEquippableConfig                   Config;                                            // 0x0000(0x0070)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSBZWeaponStats                        WantedStats;                                       // 0x0070(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZUITrainingData) == 0x000008, "Wrong alignment on FSBZUITrainingData");
static_assert(sizeof(FSBZUITrainingData) == 0x000088, "Wrong size on FSBZUITrainingData");
static_assert(offsetof(FSBZUITrainingData, Config) == 0x000000, "Member 'FSBZUITrainingData::Config' has a wrong offset!");
static_assert(offsetof(FSBZUITrainingData, WantedStats) == 0x000070, "Member 'FSBZUITrainingData::WantedStats' has a wrong offset!");

// ScriptStruct Starbreeze.SBZUIWeaponStatWeightContainer
// 0x0060 (0x0060 - 0x0000)
struct FSBZUIWeaponStatWeightContainer final
{
public:
	TArray<float>                                 MeanInputArray;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, NativeAccessSpecifierPublic)
	TArray<float>                                 VarianceInputArray;                                // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, NativeAccessSpecifierPublic)
	TArray<float>                                 WeightHiddenArray;                                 // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, NativeAccessSpecifierPublic)
	TArray<float>                                 BiasHiddenArray;                                   // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, NativeAccessSpecifierPublic)
	TArray<float>                                 WeightOutputArray;                                 // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, NativeAccessSpecifierPublic)
	TArray<float>                                 BiasOutputArray;                                   // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZUIWeaponStatWeightContainer) == 0x000008, "Wrong alignment on FSBZUIWeaponStatWeightContainer");
static_assert(sizeof(FSBZUIWeaponStatWeightContainer) == 0x000060, "Wrong size on FSBZUIWeaponStatWeightContainer");
static_assert(offsetof(FSBZUIWeaponStatWeightContainer, MeanInputArray) == 0x000000, "Member 'FSBZUIWeaponStatWeightContainer::MeanInputArray' has a wrong offset!");
static_assert(offsetof(FSBZUIWeaponStatWeightContainer, VarianceInputArray) == 0x000010, "Member 'FSBZUIWeaponStatWeightContainer::VarianceInputArray' has a wrong offset!");
static_assert(offsetof(FSBZUIWeaponStatWeightContainer, WeightHiddenArray) == 0x000020, "Member 'FSBZUIWeaponStatWeightContainer::WeightHiddenArray' has a wrong offset!");
static_assert(offsetof(FSBZUIWeaponStatWeightContainer, BiasHiddenArray) == 0x000030, "Member 'FSBZUIWeaponStatWeightContainer::BiasHiddenArray' has a wrong offset!");
static_assert(offsetof(FSBZUIWeaponStatWeightContainer, WeightOutputArray) == 0x000040, "Member 'FSBZUIWeaponStatWeightContainer::WeightOutputArray' has a wrong offset!");
static_assert(offsetof(FSBZUIWeaponStatWeightContainer, BiasOutputArray) == 0x000050, "Member 'FSBZUIWeaponStatWeightContainer::BiasOutputArray' has a wrong offset!");

// ScriptStruct Starbreeze.SBZUser
// 0x0380 (0x0380 - 0x0000)
struct FSBZUser final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   PrivateDisplayName;                                // 0x0018(0x0018)(Protected, NativeAccessSpecifierProtected)
	class FString                                 UserId;                                            // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 PlatformUserId;                                    // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   PlatformDisplayName;                               // 0x0050(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FString                                 PlatformId;                                        // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESBZPlatform                                  Platform;                                          // 0x0078(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESBZFirstPartyPlatform                        FirstPartyPlatform;                                // 0x0079(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESBZOnlinePresenceState                       PresenceState;                                     // 0x007A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7B[0x1];                                       // 0x007B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LevelIndex;                                        // 0x007C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InfamyLevel;                                       // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RenownLevel;                                       // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsBlocked;                                        // 0x0088(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlatformBlocked;                                  // 0x0089(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlatformPlayer;                                   // 0x008A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8B[0x5];                                       // 0x008B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class FString>            PlatformUserIds;                                   // 0x0090(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UPaperSprite*                           PlatformIcon;                                      // 0x00E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPaperSprite*                           NebulaIcon;                                        // 0x00E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSBZUserActivity                       UserActivity;                                      // 0x00F0(0x00B8)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bCanCommunicateWith;                               // 0x01A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLocalPlayer;                                    // 0x01A9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPartyLeader;                                    // 0x01AA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AB[0x5];                                      // 0x01AB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPD3PlayerLoadout                      Loadout;                                           // 0x01B0(0x01C0)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_370[0x10];                                     // 0x0370(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZUser) == 0x000008, "Wrong alignment on FSBZUser");
static_assert(sizeof(FSBZUser) == 0x000380, "Wrong size on FSBZUser");
static_assert(offsetof(FSBZUser, DisplayName) == 0x000000, "Member 'FSBZUser::DisplayName' has a wrong offset!");
static_assert(offsetof(FSBZUser, PrivateDisplayName) == 0x000018, "Member 'FSBZUser::PrivateDisplayName' has a wrong offset!");
static_assert(offsetof(FSBZUser, UserId) == 0x000030, "Member 'FSBZUser::UserId' has a wrong offset!");
static_assert(offsetof(FSBZUser, PlatformUserId) == 0x000040, "Member 'FSBZUser::PlatformUserId' has a wrong offset!");
static_assert(offsetof(FSBZUser, PlatformDisplayName) == 0x000050, "Member 'FSBZUser::PlatformDisplayName' has a wrong offset!");
static_assert(offsetof(FSBZUser, PlatformId) == 0x000068, "Member 'FSBZUser::PlatformId' has a wrong offset!");
static_assert(offsetof(FSBZUser, Platform) == 0x000078, "Member 'FSBZUser::Platform' has a wrong offset!");
static_assert(offsetof(FSBZUser, FirstPartyPlatform) == 0x000079, "Member 'FSBZUser::FirstPartyPlatform' has a wrong offset!");
static_assert(offsetof(FSBZUser, PresenceState) == 0x00007A, "Member 'FSBZUser::PresenceState' has a wrong offset!");
static_assert(offsetof(FSBZUser, LevelIndex) == 0x00007C, "Member 'FSBZUser::LevelIndex' has a wrong offset!");
static_assert(offsetof(FSBZUser, InfamyLevel) == 0x000080, "Member 'FSBZUser::InfamyLevel' has a wrong offset!");
static_assert(offsetof(FSBZUser, RenownLevel) == 0x000084, "Member 'FSBZUser::RenownLevel' has a wrong offset!");
static_assert(offsetof(FSBZUser, bIsBlocked) == 0x000088, "Member 'FSBZUser::bIsBlocked' has a wrong offset!");
static_assert(offsetof(FSBZUser, bPlatformBlocked) == 0x000089, "Member 'FSBZUser::bPlatformBlocked' has a wrong offset!");
static_assert(offsetof(FSBZUser, bPlatformPlayer) == 0x00008A, "Member 'FSBZUser::bPlatformPlayer' has a wrong offset!");
static_assert(offsetof(FSBZUser, PlatformUserIds) == 0x000090, "Member 'FSBZUser::PlatformUserIds' has a wrong offset!");
static_assert(offsetof(FSBZUser, PlatformIcon) == 0x0000E0, "Member 'FSBZUser::PlatformIcon' has a wrong offset!");
static_assert(offsetof(FSBZUser, NebulaIcon) == 0x0000E8, "Member 'FSBZUser::NebulaIcon' has a wrong offset!");
static_assert(offsetof(FSBZUser, UserActivity) == 0x0000F0, "Member 'FSBZUser::UserActivity' has a wrong offset!");
static_assert(offsetof(FSBZUser, bCanCommunicateWith) == 0x0001A8, "Member 'FSBZUser::bCanCommunicateWith' has a wrong offset!");
static_assert(offsetof(FSBZUser, bIsLocalPlayer) == 0x0001A9, "Member 'FSBZUser::bIsLocalPlayer' has a wrong offset!");
static_assert(offsetof(FSBZUser, bIsPartyLeader) == 0x0001AA, "Member 'FSBZUser::bIsPartyLeader' has a wrong offset!");
static_assert(offsetof(FSBZUser, Loadout) == 0x0001B0, "Member 'FSBZUser::Loadout' has a wrong offset!");

// ScriptStruct Starbreeze.SBZVehicleInfo
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x10) FSBZVehicleInfo final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZVehicleInfo) == 0x000010, "Wrong alignment on FSBZVehicleInfo");
static_assert(sizeof(FSBZVehicleInfo) == 0x000050, "Wrong size on FSBZVehicleInfo");

// ScriptStruct Starbreeze.SBZVehicleSplineFollowingComponentReplicatedProperties
// 0x0018 (0x0018 - 0x0000)
struct FSBZVehicleSplineFollowingComponentReplicatedProperties final
{
public:
	TArray<class ASBZSpline*>                     Path;                                              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         TraveledDistance;                                  // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZVehicleSplineFollowingComponentReplicatedProperties) == 0x000008, "Wrong alignment on FSBZVehicleSplineFollowingComponentReplicatedProperties");
static_assert(sizeof(FSBZVehicleSplineFollowingComponentReplicatedProperties) == 0x000018, "Wrong size on FSBZVehicleSplineFollowingComponentReplicatedProperties");
static_assert(offsetof(FSBZVehicleSplineFollowingComponentReplicatedProperties, Path) == 0x000000, "Member 'FSBZVehicleSplineFollowingComponentReplicatedProperties::Path' has a wrong offset!");
static_assert(offsetof(FSBZVehicleSplineFollowingComponentReplicatedProperties, TraveledDistance) == 0x000010, "Member 'FSBZVehicleSplineFollowingComponentReplicatedProperties::TraveledDistance' has a wrong offset!");

// ScriptStruct Starbreeze.SBZLevelVOInfo
// 0x0040 (0x0040 - 0x0000)
struct FSBZLevelVOInfo final
{
public:
	struct FSoftObjectPath                        StringTable;                                       // 0x0000(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GSheetId;                                          // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         SheetsToExport;                                    // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZLevelVOInfo) == 0x000008, "Wrong alignment on FSBZLevelVOInfo");
static_assert(sizeof(FSBZLevelVOInfo) == 0x000040, "Wrong size on FSBZLevelVOInfo");
static_assert(offsetof(FSBZLevelVOInfo, StringTable) == 0x000000, "Member 'FSBZLevelVOInfo::StringTable' has a wrong offset!");
static_assert(offsetof(FSBZLevelVOInfo, GSheetId) == 0x000020, "Member 'FSBZLevelVOInfo::GSheetId' has a wrong offset!");
static_assert(offsetof(FSBZLevelVOInfo, SheetsToExport) == 0x000030, "Member 'FSBZLevelVOInfo::SheetsToExport' has a wrong offset!");

// ScriptStruct Starbreeze.SBZVotingMsgArgsServer
// 0x0078 (0x0078 - 0x0000)
struct alignas(0x08) FSBZVotingMsgArgsServer final
{
public:
	uint8                                         Pad_0[0x78];                                       // 0x0000(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZVotingMsgArgsServer) == 0x000008, "Wrong alignment on FSBZVotingMsgArgsServer");
static_assert(sizeof(FSBZVotingMsgArgsServer) == 0x000078, "Wrong size on FSBZVotingMsgArgsServer");

// ScriptStruct Starbreeze.SBZWeaponPresetModularConfigItem
// 0x0010 (0x0010 - 0x0000)
struct FSBZWeaponPresetModularConfigItem final
{
public:
	class USBZEquippablePartDataAsset*            Part;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USBZEquippablePartConfig*               Config;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWeaponPresetModularConfigItem) == 0x000008, "Wrong alignment on FSBZWeaponPresetModularConfigItem");
static_assert(sizeof(FSBZWeaponPresetModularConfigItem) == 0x000010, "Wrong size on FSBZWeaponPresetModularConfigItem");
static_assert(offsetof(FSBZWeaponPresetModularConfigItem, Part) == 0x000000, "Member 'FSBZWeaponPresetModularConfigItem::Part' has a wrong offset!");
static_assert(offsetof(FSBZWeaponPresetModularConfigItem, Config) == 0x000008, "Member 'FSBZWeaponPresetModularConfigItem::Config' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeaponPartProgressionCurrent
// 0x0098 (0x0098 - 0x0000)
struct FSBZWeaponPartProgressionCurrent final
{
public:
	int32                                         ProgressionLevel;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USBZWeaponPartDataAsset*                WeaponPart;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZWeaponPartApplyStatus                     WeaponPartApplyStatus;                             // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZWeaponPartLockReason                      WeaponPartLockReason;                              // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSBZSharedWeaponParentLock             SharedWeaponParentLock;                            // 0x0018(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSBZChallengeLock                      ChallengeLock;                                     // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int64                                         Price;                                             // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZCurrencyCode                              CurrencyCode;                                      // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DiscountAmount;                                    // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DiscountPercentage;                                // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         DiscountedPrice;                                   // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESBZItemCurrencyType                          CurrencyType;                                      // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              PurchaseAt;                                        // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ExpireAt;                                          // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              DiscountPurchaseAt;                                // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              DiscountExpireAt;                                  // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWeaponPartProgressionCurrent) == 0x000008, "Wrong alignment on FSBZWeaponPartProgressionCurrent");
static_assert(sizeof(FSBZWeaponPartProgressionCurrent) == 0x000098, "Wrong size on FSBZWeaponPartProgressionCurrent");
static_assert(offsetof(FSBZWeaponPartProgressionCurrent, ProgressionLevel) == 0x000000, "Member 'FSBZWeaponPartProgressionCurrent::ProgressionLevel' has a wrong offset!");
static_assert(offsetof(FSBZWeaponPartProgressionCurrent, WeaponPart) == 0x000008, "Member 'FSBZWeaponPartProgressionCurrent::WeaponPart' has a wrong offset!");
static_assert(offsetof(FSBZWeaponPartProgressionCurrent, WeaponPartApplyStatus) == 0x000010, "Member 'FSBZWeaponPartProgressionCurrent::WeaponPartApplyStatus' has a wrong offset!");
static_assert(offsetof(FSBZWeaponPartProgressionCurrent, WeaponPartLockReason) == 0x000011, "Member 'FSBZWeaponPartProgressionCurrent::WeaponPartLockReason' has a wrong offset!");
static_assert(offsetof(FSBZWeaponPartProgressionCurrent, SharedWeaponParentLock) == 0x000018, "Member 'FSBZWeaponPartProgressionCurrent::SharedWeaponParentLock' has a wrong offset!");
static_assert(offsetof(FSBZWeaponPartProgressionCurrent, ChallengeLock) == 0x000038, "Member 'FSBZWeaponPartProgressionCurrent::ChallengeLock' has a wrong offset!");
static_assert(offsetof(FSBZWeaponPartProgressionCurrent, Price) == 0x000050, "Member 'FSBZWeaponPartProgressionCurrent::Price' has a wrong offset!");
static_assert(offsetof(FSBZWeaponPartProgressionCurrent, CurrencyCode) == 0x000058, "Member 'FSBZWeaponPartProgressionCurrent::CurrencyCode' has a wrong offset!");
static_assert(offsetof(FSBZWeaponPartProgressionCurrent, DiscountAmount) == 0x00005C, "Member 'FSBZWeaponPartProgressionCurrent::DiscountAmount' has a wrong offset!");
static_assert(offsetof(FSBZWeaponPartProgressionCurrent, DiscountPercentage) == 0x000060, "Member 'FSBZWeaponPartProgressionCurrent::DiscountPercentage' has a wrong offset!");
static_assert(offsetof(FSBZWeaponPartProgressionCurrent, DiscountedPrice) == 0x000068, "Member 'FSBZWeaponPartProgressionCurrent::DiscountedPrice' has a wrong offset!");
static_assert(offsetof(FSBZWeaponPartProgressionCurrent, CurrencyType) == 0x000070, "Member 'FSBZWeaponPartProgressionCurrent::CurrencyType' has a wrong offset!");
static_assert(offsetof(FSBZWeaponPartProgressionCurrent, PurchaseAt) == 0x000078, "Member 'FSBZWeaponPartProgressionCurrent::PurchaseAt' has a wrong offset!");
static_assert(offsetof(FSBZWeaponPartProgressionCurrent, ExpireAt) == 0x000080, "Member 'FSBZWeaponPartProgressionCurrent::ExpireAt' has a wrong offset!");
static_assert(offsetof(FSBZWeaponPartProgressionCurrent, DiscountPurchaseAt) == 0x000088, "Member 'FSBZWeaponPartProgressionCurrent::DiscountPurchaseAt' has a wrong offset!");
static_assert(offsetof(FSBZWeaponPartProgressionCurrent, DiscountExpireAt) == 0x000090, "Member 'FSBZWeaponPartProgressionCurrent::DiscountExpireAt' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeaponViewKickBackData
// 0x0000 (0x0120 - 0x0120)
struct FSBZWeaponViewKickBackData final : public FSBZWeaponGunKickBackData
{
};
static_assert(alignof(FSBZWeaponViewKickBackData) == 0x000008, "Wrong alignment on FSBZWeaponViewKickBackData");
static_assert(sizeof(FSBZWeaponViewKickBackData) == 0x000120, "Wrong size on FSBZWeaponViewKickBackData");

// ScriptStruct Starbreeze.SBZWeaponSettingData
// 0x0010 (0x0010 - 0x0000)
struct FSBZWeaponSettingData final
{
public:
	float                                         SuppressorEffectValue[0x4];                        // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWeaponSettingData) == 0x000004, "Wrong alignment on FSBZWeaponSettingData");
static_assert(sizeof(FSBZWeaponSettingData) == 0x000010, "Wrong size on FSBZWeaponSettingData");
static_assert(offsetof(FSBZWeaponSettingData, SuppressorEffectValue) == 0x000000, "Member 'FSBZWeaponSettingData::SuppressorEffectValue' has a wrong offset!");

// ScriptStruct Starbreeze.SBZWeaponStickerPosition
// 0x0018 (0x0018 - 0x0000)
struct FSBZWeaponStickerPosition final
{
public:
	int8                                          PartIndex;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scale;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rotation;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnOtherSide;                                      // 0x000C(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Position;                                          // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZWeaponStickerPosition) == 0x000004, "Wrong alignment on FSBZWeaponStickerPosition");
static_assert(sizeof(FSBZWeaponStickerPosition) == 0x000018, "Wrong size on FSBZWeaponStickerPosition");
static_assert(offsetof(FSBZWeaponStickerPosition, PartIndex) == 0x000000, "Member 'FSBZWeaponStickerPosition::PartIndex' has a wrong offset!");
static_assert(offsetof(FSBZWeaponStickerPosition, Scale) == 0x000004, "Member 'FSBZWeaponStickerPosition::Scale' has a wrong offset!");
static_assert(offsetof(FSBZWeaponStickerPosition, Rotation) == 0x000008, "Member 'FSBZWeaponStickerPosition::Rotation' has a wrong offset!");
static_assert(offsetof(FSBZWeaponStickerPosition, bOnOtherSide) == 0x00000C, "Member 'FSBZWeaponStickerPosition::bOnOtherSide' has a wrong offset!");
static_assert(offsetof(FSBZWeaponStickerPosition, Position) == 0x000010, "Member 'FSBZWeaponStickerPosition::Position' has a wrong offset!");

// ScriptStruct Starbreeze.SBZDebugSnapshot
// 0x0040 (0x0040 - 0x0000)
struct FSBZDebugSnapshot final
{
public:
	struct FSBZWheeledVehicleReplicatedMovement   ServerState;                                       // 0x0000(0x0040)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZDebugSnapshot) == 0x000010, "Wrong alignment on FSBZDebugSnapshot");
static_assert(sizeof(FSBZDebugSnapshot) == 0x000040, "Wrong size on FSBZDebugSnapshot");
static_assert(offsetof(FSBZDebugSnapshot, ServerState) == 0x000000, "Member 'FSBZDebugSnapshot::ServerState' has a wrong offset!");

// ScriptStruct Starbreeze.SBZActiveGlobalCommentPermissionArray
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FSBZActiveGlobalCommentPermissionArray final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBZActiveGlobalCommentPermissionArray) == 0x000008, "Wrong alignment on FSBZActiveGlobalCommentPermissionArray");
static_assert(sizeof(FSBZActiveGlobalCommentPermissionArray) == 0x000010, "Wrong size on FSBZActiveGlobalCommentPermissionArray");

// ScriptStruct Starbreeze.StatLocalizationEntry
// 0x00A0 (0x00A0 - 0x0000)
struct FStatLocalizationEntry final
{
public:
	class FString                                 StatCode;                                          // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ObjectiveMultiple;                                 // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ObjectiveSingle;                                   // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            ObjectiveOverrides;                                // 0x0050(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStatLocalizationEntry) == 0x000008, "Wrong alignment on FStatLocalizationEntry");
static_assert(sizeof(FStatLocalizationEntry) == 0x0000A0, "Wrong size on FStatLocalizationEntry");
static_assert(offsetof(FStatLocalizationEntry, StatCode) == 0x000000, "Member 'FStatLocalizationEntry::StatCode' has a wrong offset!");
static_assert(offsetof(FStatLocalizationEntry, Name) == 0x000010, "Member 'FStatLocalizationEntry::Name' has a wrong offset!");
static_assert(offsetof(FStatLocalizationEntry, Description) == 0x000020, "Member 'FStatLocalizationEntry::Description' has a wrong offset!");
static_assert(offsetof(FStatLocalizationEntry, ObjectiveMultiple) == 0x000030, "Member 'FStatLocalizationEntry::ObjectiveMultiple' has a wrong offset!");
static_assert(offsetof(FStatLocalizationEntry, ObjectiveSingle) == 0x000040, "Member 'FStatLocalizationEntry::ObjectiveSingle' has a wrong offset!");
static_assert(offsetof(FStatLocalizationEntry, ObjectiveOverrides) == 0x000050, "Member 'FStatLocalizationEntry::ObjectiveOverrides' has a wrong offset!");

}

