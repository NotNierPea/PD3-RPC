#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: SBZLighting

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "SBZLighting_structs.hpp"


namespace SDK
{

// Class SBZLighting.SBZIrradianceOccluder
// 0x0008 (0x02B0 - 0x02A8)
class ASBZIrradianceOccluder final : public AActor
{
public:
	class USBZIrradianceOccluderComponent*        IrradianceOccluderComponent;                       // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SBZIrradianceOccluder">();
	}
	static class ASBZIrradianceOccluder* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASBZIrradianceOccluder>();
	}
};
static_assert(alignof(ASBZIrradianceOccluder) == 0x000008, "Wrong alignment on ASBZIrradianceOccluder");
static_assert(sizeof(ASBZIrradianceOccluder) == 0x0002B0, "Wrong size on ASBZIrradianceOccluder");
static_assert(offsetof(ASBZIrradianceOccluder, IrradianceOccluderComponent) == 0x0002A8, "Member 'ASBZIrradianceOccluder::IrradianceOccluderComponent' has a wrong offset!");

// Class SBZLighting.SBZIrradianceOccluderComponent
// 0x0000 (0x0230 - 0x0230)
class USBZIrradianceOccluderComponent final : public USceneComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SBZIrradianceOccluderComponent">();
	}
	static class USBZIrradianceOccluderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USBZIrradianceOccluderComponent>();
	}
};
static_assert(alignof(USBZIrradianceOccluderComponent) == 0x000010, "Wrong alignment on USBZIrradianceOccluderComponent");
static_assert(sizeof(USBZIrradianceOccluderComponent) == 0x000230, "Wrong size on USBZIrradianceOccluderComponent");

// Class SBZLighting.SBZLightVisibilityArea
// 0x0028 (0x02D0 - 0x02A8)
class ASBZLightVisibilityArea final : public AActor
{
public:
	TArray<class ALight*>                         Lights;                                            // 0x02A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ASBZLightVisibilityShape*>       Shapes;                                            // 0x02B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	ESBZLightVisibilityAreaAction                 Action;                                            // 0x02C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SBZLightVisibilityArea">();
	}
	static class ASBZLightVisibilityArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASBZLightVisibilityArea>();
	}
};
static_assert(alignof(ASBZLightVisibilityArea) == 0x000008, "Wrong alignment on ASBZLightVisibilityArea");
static_assert(sizeof(ASBZLightVisibilityArea) == 0x0002D0, "Wrong size on ASBZLightVisibilityArea");
static_assert(offsetof(ASBZLightVisibilityArea, Lights) == 0x0002A8, "Member 'ASBZLightVisibilityArea::Lights' has a wrong offset!");
static_assert(offsetof(ASBZLightVisibilityArea, Shapes) == 0x0002B8, "Member 'ASBZLightVisibilityArea::Shapes' has a wrong offset!");
static_assert(offsetof(ASBZLightVisibilityArea, Action) == 0x0002C8, "Member 'ASBZLightVisibilityArea::Action' has a wrong offset!");

// Class SBZLighting.SBZLightVisibilityAreaManager
// 0x0010 (0x02B8 - 0x02A8)
class ASBZLightVisibilityAreaManager final : public AActor
{
public:
	uint8                                         Pad_2A8[0x10];                                     // 0x02A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SBZLightVisibilityAreaManager">();
	}
	static class ASBZLightVisibilityAreaManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASBZLightVisibilityAreaManager>();
	}
};
static_assert(alignof(ASBZLightVisibilityAreaManager) == 0x000008, "Wrong alignment on ASBZLightVisibilityAreaManager");
static_assert(sizeof(ASBZLightVisibilityAreaManager) == 0x0002B8, "Wrong size on ASBZLightVisibilityAreaManager");

// Class SBZLighting.SBZLightVisibilityShape
// 0x0000 (0x02A8 - 0x02A8)
class ASBZLightVisibilityShape : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SBZLightVisibilityShape">();
	}
	static class ASBZLightVisibilityShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASBZLightVisibilityShape>();
	}
};
static_assert(alignof(ASBZLightVisibilityShape) == 0x000008, "Wrong alignment on ASBZLightVisibilityShape");
static_assert(sizeof(ASBZLightVisibilityShape) == 0x0002A8, "Wrong size on ASBZLightVisibilityShape");

// Class SBZLighting.SBZLightVisibilityBoxShape
// 0x0008 (0x02B0 - 0x02A8)
class ASBZLightVisibilityBoxShape final : public ASBZLightVisibilityShape
{
public:
	class UBoxComponent*                          BoxComponent;                                      // 0x02A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SBZLightVisibilityBoxShape">();
	}
	static class ASBZLightVisibilityBoxShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASBZLightVisibilityBoxShape>();
	}
};
static_assert(alignof(ASBZLightVisibilityBoxShape) == 0x000008, "Wrong alignment on ASBZLightVisibilityBoxShape");
static_assert(sizeof(ASBZLightVisibilityBoxShape) == 0x0002B0, "Wrong size on ASBZLightVisibilityBoxShape");
static_assert(offsetof(ASBZLightVisibilityBoxShape, BoxComponent) == 0x0002A8, "Member 'ASBZLightVisibilityBoxShape::BoxComponent' has a wrong offset!");

// Class SBZLighting.SBZSparseIrradianceHintVolume
// 0x0008 (0x0308 - 0x0300)
class ASBZSparseIrradianceHintVolume final : public AVolume
{
public:
	ESBZSparseIrradianceHintVolumeAction          Action;                                            // 0x0300(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLightingChannels                      LightingChannels;                                  // 0x0301(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_302[0x2];                                      // 0x0302(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RepulsionDistance;                                 // 0x0304(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SBZSparseIrradianceHintVolume">();
	}
	static class ASBZSparseIrradianceHintVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASBZSparseIrradianceHintVolume>();
	}
};
static_assert(alignof(ASBZSparseIrradianceHintVolume) == 0x000008, "Wrong alignment on ASBZSparseIrradianceHintVolume");
static_assert(sizeof(ASBZSparseIrradianceHintVolume) == 0x000308, "Wrong size on ASBZSparseIrradianceHintVolume");
static_assert(offsetof(ASBZSparseIrradianceHintVolume, Action) == 0x000300, "Member 'ASBZSparseIrradianceHintVolume::Action' has a wrong offset!");
static_assert(offsetof(ASBZSparseIrradianceHintVolume, LightingChannels) == 0x000301, "Member 'ASBZSparseIrradianceHintVolume::LightingChannels' has a wrong offset!");
static_assert(offsetof(ASBZSparseIrradianceHintVolume, RepulsionDistance) == 0x000304, "Member 'ASBZSparseIrradianceHintVolume::RepulsionDistance' has a wrong offset!");

}

